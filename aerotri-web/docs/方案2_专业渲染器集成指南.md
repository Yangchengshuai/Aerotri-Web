# 方案 2: 专业渲染器 + 3D Tiles 数据源集成指南

## 一、方案概述

### 1.1 核心思路

使用专业渲染器（如 SuperSplat 或 antimatter15/splat），但**数据源使用 3D Tiles**，而不是直接加载 PLY。

**优势**：
- ✅ **高质量渲染**：专业渲染器的完整 3DGS 支持
- ✅ **分块加载**：保持 3D Tiles 的分块优势
- ✅ **快速加载**：< 10 秒初始加载
- ✅ **按需加载**：只加载可见区域

### 1.2 架构设计

```
PLY 文件
    ↓
3D Tiles 转换（保持现有流程）
    ↓
3D Tiles (B3DM files)
    ↓
专业渲染器加载器
    ↓
按需加载 tiles
    ↓
转换为渲染器格式
    ↓
高质量 3DGS 渲染
```

## 二、推荐渲染器选择

### 2.1 SuperSplat ⭐⭐⭐⭐⭐

**GitHub**: https://github.com/playcanvas/supersplat

**特点**：
- 基于 WebGL/WebGPU
- 支持 PLY 文件直接加载
- 实时编辑功能
- 开源免费，PlayCanvas 维护

**集成难度**: 中等

**优势**：
- 功能完整
- 性能优化
- 活跃维护

### 2.2 antimatter15/splat ⭐⭐⭐⭐⭐

**GitHub**: https://github.com/antimatter15/splat

**特点**：
- 轻量级 Web 端 3DGS viewer
- 支持 .splat 格式
- 基于 WebGL，性能优秀
- 支持流式加载

**集成难度**: 低

**优势**：
- 轻量级
- 性能好
- 支持流式加载

## 三、实施步骤

### 阶段 1: 环境准备（1-2 天）

#### 步骤 1.1: 安装依赖

```bash
cd /root/work/aerotri-web/frontend

# 如果选择 SuperSplat
npm install @playcanvas/supersplat

# 如果选择 antimatter15/splat
npm install @antimatter15/splat
# 或直接使用 CDN
```

#### 步骤 1.2: 创建测试页面

创建独立的测试页面，验证渲染器功能：

```vue
<!-- frontend/src/components/GaussianSplatViewer.vue -->
<template>
  <div ref="container" class="gaussian-viewer"></div>
</template>

<script setup lang="ts">
import { onMounted, ref, onUnmounted } from 'vue'

const props = defineProps<{
  tilesetUrl: string
}>()

const container = ref<HTMLDivElement | null>(null)
let viewer: any = null

onMounted(() => {
  if (!container.value) return
  
  // 初始化渲染器
  // TODO: 根据选择的渲染器实现
})

onUnmounted(() => {
  // 清理资源
  if (viewer) {
    viewer.dispose()
  }
})
</script>

<style scoped>
.gaussian-viewer {
  width: 100%;
  height: 100%;
}
</style>
```

### 阶段 2: 3D Tiles 加载器实现（3-5 天）

#### 步骤 2.1: 实现 Tileset 解析

```typescript
// frontend/src/utils/tilesetLoader.ts

interface TileInfo {
  boundingVolume: {
    box?: number[]
    sphere?: number[]
  }
  content?: {
    uri: string
  }
  children?: TileInfo[]
}

export class TilesetLoader {
  private baseUrl: string
  
  constructor(baseUrl: string) {
    this.baseUrl = baseUrl
  }
  
  async loadTileset(): Promise<TileInfo> {
    const response = await fetch(`${this.baseUrl}/tileset.json`)
    return await response.json()
  }
  
  async loadTile(tileUri: string): Promise<ArrayBuffer> {
    const response = await fetch(`${this.baseUrl}/${tileUri}`)
    return await response.arrayBuffer()
  }
  
  // 根据相机位置选择需要加载的 tiles
  selectTiles(tileset: TileInfo, cameraPosition: [number, number, number]): TileInfo[] {
    // TODO: 实现 LOD 和视锥裁剪逻辑
    return []
  }
}
```

#### 步骤 2.2: B3DM 解析器

```typescript
// frontend/src/utils/b3dmParser.ts

export interface B3DMData {
  glb: ArrayBuffer
  featureTable?: any
  batchTable?: any
}

export class B3DMParser {
  static parse(b3dmBuffer: ArrayBuffer): B3DMData {
    const view = new DataView(b3dmBuffer)
    
    // 读取 B3DM header
    const magic = String.fromCharCode(...new Uint8Array(b3dmBuffer, 0, 4))
    if (magic !== 'b3dm') {
      throw new Error('Invalid B3DM file')
    }
    
    const version = view.getUint32(4, true)
    const byteLength = view.getUint32(8, true)
    const featureTableJSONByteLength = view.getUint32(12, true)
    const featureTableBinaryByteLength = view.getUint32(16, true)
    const batchTableJSONByteLength = view.getUint32(20, true)
    const batchTableBinaryByteLength = view.getUint32(24, true)
    
    // 计算 GLB 偏移
    const headerLength = 28
    const glbOffset = headerLength + 
      featureTableJSONByteLength + 
      featureTableBinaryByteLength + 
      batchTableJSONByteLength + 
      batchTableBinaryByteLength
    
    // 提取 GLB
    const glb = b3dmBuffer.slice(glbOffset)
    
    return {
      glb,
      featureTable: featureTableJSONByteLength > 0 ? 
        JSON.parse(new TextDecoder().decode(
          new Uint8Array(b3dmBuffer, headerLength, featureTableJSONByteLength)
        )) : undefined,
      batchTable: batchTableJSONByteLength > 0 ?
        JSON.parse(new TextDecoder().decode(
          new Uint8Array(b3dmBuffer, 
            headerLength + featureTableJSONByteLength + featureTableBinaryByteLength,
            batchTableJSONByteLength)
        )) : undefined
    }
  }
}
```

### 阶段 3: GLB 到渲染器格式转换（5-7 天）

#### 步骤 3.1: GLB 解析

```typescript
// frontend/src/utils/glbParser.ts

export interface GLBData {
  json: any
  buffers: ArrayBuffer[]
}

export class GLBParser {
  static parse(glbBuffer: ArrayBuffer): GLBData {
    const view = new DataView(glbBuffer)
    
    // 读取 GLB header
    const magic = String.fromCharCode(...new Uint8Array(glbBuffer, 0, 4))
    if (magic !== 'glTF') {
      throw new Error('Invalid GLB file')
    }
    
    const version = view.getUint32(4, true)
    const length = view.getUint32(8, true)
    
    // 读取 JSON chunk
    const jsonChunkLength = view.getUint32(12, true)
    const jsonChunkType = view.getUint32(16, true)
    const jsonStart = 20
    const jsonEnd = jsonStart + jsonChunkLength
    const jsonBytes = new Uint8Array(glbBuffer, jsonStart, jsonChunkLength)
    const json = JSON.parse(new TextDecoder().decode(jsonBytes))
    
    // 读取 Binary chunk
    const binaryChunkLength = view.getUint32(jsonEnd, true)
    const binaryChunkType = view.getUint32(jsonEnd + 4, true)
    const binaryStart = jsonEnd + 8
    const binary = glbBuffer.slice(binaryStart, binaryStart + binaryChunkLength)
    
    // 解析 buffers
    const buffers: ArrayBuffer[] = []
    if (json.buffers && json.buffers.length > 0) {
      buffers.push(binary)
    }
    
    return { json, buffers }
  }
}
```

#### 步骤 3.2: 提取 Gaussian Splatting 数据

```typescript
// frontend/src/utils/gaussianDataExtractor.ts

export interface GaussianData {
  positions: Float32Array
  rotations: Float32Array
  scales: Float32Array
  colors: Float32Array
  alphas: Float32Array
  shCoefficients?: Float32Array
  shDegree?: number
}

export class GaussianDataExtractor {
  static extract(glbData: GLBData): GaussianData {
    const { json, buffers } = glbData
    
    // 查找 KHR_gaussian_splatting 扩展
    const mesh = json.meshes?.[0]
    const extension = mesh?.extensions?.KHR_gaussian_splatting
    if (!extension) {
      throw new Error('KHR_gaussian_splatting extension not found')
    }
    
    // 提取 accessors
    const positionsAcc = json.accessors[extension.positions]
    const rotationsAcc = json.accessors[extension.rotations]
    const scalesAcc = json.accessors[extension.scales]
    const colorsAcc = json.accessors[extension.colors]
    const alphasAcc = json.accessors[extension.alphas]
    
    // 提取 buffer views
    const positionsBV = json.bufferViews[positionsAcc.bufferView]
    const rotationsBV = json.bufferViews[rotationsAcc.bufferView]
    const scalesBV = json.bufferViews[scalesAcc.bufferView]
    const colorsBV = json.bufferViews[colorsAcc.bufferView]
    const alphasBV = json.bufferViews[alphasAcc.bufferView]
    
    // 从 buffer 中提取数据
    const buffer = buffers[0]
    const positions = new Float32Array(
      buffer,
      positionsBV.byteOffset,
      positionsAcc.count * 3
    )
    const rotations = new Float32Array(
      buffer,
      rotationsBV.byteOffset,
      rotationsAcc.count * 4
    )
    const scales = new Float32Array(
      buffer,
      scalesBV.byteOffset,
      scalesAcc.count * 3
    )
    const colors = new Float32Array(
      buffer,
      colorsBV.byteOffset,
      colorsAcc.count * 3
    )
    const alphas = new Float32Array(
      buffer,
      alphasBV.byteOffset,
      alphasAcc.count
    )
    
    // 提取 SH 系数（如果存在）
    let shCoefficients: Float32Array | undefined
    let shDegree: number | undefined
    if (extension.sphericalHarmonics !== undefined) {
      const shAcc = json.accessors[extension.sphericalHarmonics]
      const shBV = json.bufferViews[shAcc.bufferView]
      shCoefficients = new Float32Array(
        buffer,
        shBV.byteOffset,
        shAcc.count
      )
      shDegree = extension.sphericalHarmonicsDegree || 0
    }
    
    return {
      positions,
      rotations,
      scales,
      colors,
      alphas,
      shCoefficients,
      shDegree
    }
  }
}
```

### 阶段 4: 渲染器集成（5-7 天）

#### 步骤 4.1: SuperSplat 集成示例

```typescript
// frontend/src/components/GaussianSplatViewer.vue (SuperSplat 版本)

<script setup lang="ts">
import { onMounted, ref, onUnmounted } from 'vue'
import { TilesetLoader } from '@/utils/tilesetLoader'
import { B3DMParser } from '@/utils/b3dmParser'
import { GLBParser } from '@/utils/glbParser'
import { GaussianDataExtractor } from '@/utils/gaussianDataExtractor'
// import SuperSplat viewer

const props = defineProps<{
  tilesetUrl: string
}>()

const container = ref<HTMLDivElement | null>(null)
let viewer: any = null
let tilesetLoader: TilesetLoader

onMounted(async () => {
  if (!container.value) return
  
  // 初始化 SuperSplat viewer
  // viewer = new SuperSplatViewer(container.value)
  
  // 加载 tileset
  tilesetLoader = new TilesetLoader(props.tilesetUrl)
  const tileset = await tilesetLoader.loadTileset()
  
  // 加载并渲染 tiles
  await loadAndRenderTiles(tileset)
})

async function loadAndRenderTiles(tileset: any) {
  // 选择需要加载的 tiles（基于相机位置）
  const tilesToLoad = tilesetLoader.selectTiles(tileset, [0, 0, 0])
  
  for (const tile of tilesToLoad) {
    if (tile.content?.uri) {
      // 加载 B3DM
      const b3dmBuffer = await tilesetLoader.loadTile(tile.content.uri)
      const b3dmData = B3DMParser.parse(b3dmBuffer)
      
      // 解析 GLB
      const glbData = GLBParser.parse(b3dmData.glb)
      
      // 提取 Gaussian 数据
      const gaussianData = GaussianDataExtractor.extract(glbData)
      
      // 添加到 SuperSplat viewer
      // viewer.addGaussianData(gaussianData)
    }
  }
}

onUnmounted(() => {
  if (viewer) {
    viewer.dispose()
  }
})
</script>
```

#### 步骤 4.2: antimatter15/splat 集成示例

```typescript
// frontend/src/components/GaussianSplatViewer.vue (antimatter15/splat 版本)

<script setup lang="ts">
import { onMounted, ref, onUnmounted } from 'vue'
// import SplatViewer from '@antimatter15/splat'

// 类似的实现，但使用 antimatter15/splat 的 API
</script>
```

## 四、优化策略

### 4.1 按需加载

- 只加载视野内的 tiles
- 根据相机距离选择 LOD
- 自动卸载不可见的 tiles

### 4.2 缓存策略

- 缓存已加载的 tiles
- 使用 IndexedDB 存储 tiles
- 实现 LRU 缓存策略

### 4.3 性能优化

- 使用 Web Workers 解析 B3DM/GLB
- 批量加载 tiles
- 使用 requestIdleCallback 延迟加载

## 五、测试计划

### 5.1 功能测试

1. Tileset 加载
2. B3DM 解析
3. GLB 解析
4. Gaussian 数据提取
5. 渲染器集成

### 5.2 性能测试

1. 初始加载时间
2. 内存占用
3. 帧率
4. 网络请求数量

### 5.3 兼容性测试

1. 不同浏览器
2. 不同设备
3. 不同网络条件

## 六、时间估算

| 阶段 | 时间 | 说明 |
|------|------|------|
| 环境准备 | 1-2 天 | 安装依赖，创建测试页面 |
| Tileset 加载器 | 3-5 天 | 实现 tileset 解析和 tile 选择 |
| B3DM/GLB 解析 | 2-3 天 | 实现解析器 |
| Gaussian 数据提取 | 2-3 天 | 实现数据提取 |
| 渲染器集成 | 5-7 天 | 集成 SuperSplat 或 antimatter15/splat |
| 优化和测试 | 3-5 天 | 性能优化和测试 |
| **总计** | **16-25 天** | **约 3-4 周** |

## 七、参考资源

1. **SuperSplat**: https://github.com/playcanvas/supersplat
2. **antimatter15/splat**: https://github.com/antimatter15/splat
3. **3D Tiles 规范**: https://github.com/CesiumGS/3d-tiles
4. **glTF 规范**: https://www.khronos.org/gltf/
5. **KHR_gaussian_splatting**: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_gaussian_splatting
