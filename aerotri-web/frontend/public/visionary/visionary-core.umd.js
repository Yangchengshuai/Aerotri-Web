(function(V,c){typeof exports=="object"&&typeof module<"u"?c(exports,require("gl-matrix"),require("three/webgpu"),require("three/examples/jsm/loaders/RGBELoader.js"),require("onnxruntime-web/webgpu"),require("three/examples/jsm/loaders/GLTFLoader.js"),require("three/examples/jsm/loaders/OBJLoader.js"),require("three/examples/jsm/loaders/FBXLoader.js"),require("three/examples/jsm/loaders/STLLoader.js"),require("three/examples/jsm/loaders/PLYLoader.js"),require("onnxruntime-web")):typeof define=="function"&&define.amd?define(["exports","gl-matrix","three/webgpu","three/examples/jsm/loaders/RGBELoader.js","onnxruntime-web/webgpu","three/examples/jsm/loaders/GLTFLoader.js","three/examples/jsm/loaders/OBJLoader.js","three/examples/jsm/loaders/FBXLoader.js","three/examples/jsm/loaders/STLLoader.js","three/examples/jsm/loaders/PLYLoader.js","onnxruntime-web"],c):(V=typeof globalThis<"u"?globalThis:V||self,c(V.VisionaryCore={},V.glMatrix,V.THREE,null,V.ort,V.THREE.GLTFLoader,V.THREE.OBJLoader,V.THREE.FBXLoader,V.THREE.STLLoader,V.THREE.PLYLoader,V.ort))})(this,(function(V,c,Zs,Xo,Qs,en,tn,as,sn,nn,on){"use strict";var xt=typeof document<"u"?document.currentScript:null;function Ct(a){const e=Object.create(null,{[Symbol.toStringTag]:{value:"Module"}});if(a){for(const t in a)if(t!=="default"){const s=Object.getOwnPropertyDescriptor(a,t);Object.defineProperty(e,t,s.get?s:{enumerable:!0,get:()=>a[t]})}}return e.default=a,Object.freeze(e)}const G=Ct(Zs),be=Ct(Qs),Fe=Ct(on);class Le{buffer;bindGroup;label;size;_data;device;static bindGroupLayout(e){return e.createBindGroupLayout({label:"uniform bind group layout",entries:[{binding:0,visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,buffer:{type:"uniform"}}]})}constructor(e,t,s){this.device=e,this.label=s;const n=t instanceof ArrayBuffer?new Uint8Array(t):new Uint8Array(t.buffer,t.byteOffset,t.byteLength);this.size=n.byteLength,this._data=new ArrayBuffer(this.size),new Uint8Array(this._data).set(n),this.buffer=e.createBuffer({label:s,size:this.size,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,mappedAtCreation:!1}),e.queue.writeBuffer(this.buffer,0,this._data),this.bindGroup=e.createBindGroup({label:s?`${s} bind group`:void 0,layout:Le.bindGroupLayout(e),entries:[{binding:0,resource:{buffer:this.buffer}}]})}get data(){return this._data.slice(0)}set dataBytes(e){if(e.byteLength!==this.size)throw new Error(`Uniform size mismatch: expected ${this.size}, got ${e.byteLength}`);this._data=e.slice(0)}setData(e){if(e.byteLength!==this.size)throw new Error(`Uniform size mismatch: expected ${this.size}, got ${e.byteLength}`);new Uint8Array(this._data).set(new Uint8Array(e.buffer,e.byteOffset,e.byteLength))}flush(e){(e||this.device).queue.writeBuffer(this.buffer,0,new Uint8Array(this._data))}clone(e){const t=e||this.device;return new Le(t,this._data,this.label)}destroy(){this.buffer.destroy()}}function Ne(a){return a*Math.PI/180}function ls(a,e){return e/(2*Math.tan(a*.5))}class et{min;max;constructor(e,t){this.min=c.vec3.clone(e),this.max=c.vec3.clone(t)}center(){const e=c.vec3.create();return c.vec3.add(e,this.min,this.max),c.vec3.scale(e,e,.5),e}radius(){return .5*c.vec3.distance(this.min,this.max)}}const rn=c.mat4.fromValues(1,0,0,0,0,-1,0,0,0,0,1,0,0,0,0,1);function an(a){const e=Math.sqrt(a);return Number.isInteger(e)?(e|0)-1:void 0}function Ve(a,e){const t=c.mat3.create();c.mat3.fromQuat(t,a);const s=c.mat3.fromValues(e[0],0,0,0,e[1],0,0,0,e[2]),n=c.mat3.create();c.mat3.multiply(n,t,s);const o=c.mat3.create();c.mat3.transpose(o,n);const i=c.mat3.create();return c.mat3.multiply(i,n,o),[i[0],i[1],i[2],i[4],i[5],i[8]]}function cs(a){if(a>=0)return 1/(1+Math.exp(-a));const e=Math.exp(a);return e/(1+e)}const us=new Float32Array(1),ln=new Uint32Array(us.buffer);function w(a,e={}){const{round:t="rne",ftz:s=!1,saturate:n=!1,canonicalNaN:o=!0,emulateLegacyExpCutoff:i}=e;us[0]=a;const r=ln[0]>>>0,l=r>>>31<<15,u=r>>>23&255,d=r&8388607;if(u===255)return d!==0?l|(o?32256:31744|d>>>13):l|31744;if(i!==void 0&&u<i)return l;let h=u-127+15;if(h>=31)return l|(n?31743:31744);if(h<=0){if(h<-10||s)return l;let p=d|8388608;const v=14-h;let b=p>>>v;if(t==="rne"){const y=(1<<v)-1,_=p&y,P=1<<v-1;if((_>P||_===P&&b&1)&&(b++,b===1024))return l|1024}return l|b}let m=d>>>13;if(t==="rne"){const p=d>>>12&1,v=d&4095;if(p&&(v!==0||m&1)&&(m++,m===1024&&(m=0,h++,h>=31)))return l|(n?31743:31744)}return l|h<<10|m}const cn=a=>(a+1)*(a+1);function un(a){const{props:e,iDC0:t,iDC1:s,iDC2:n,k:o,shU32:i}=a,r=[];for(let m=0;m<e.length;++m){const p=e[m];if(p.startsWith("f_rest_")){const v=Number(p.slice(7));r.push({idx:m,order:Number.isFinite(v)?v:1e9+m})}}r.sort((m,p)=>m.order-p.order);const l=cn(o)-1,u=l*3;r.length<u&&console.warn(`[copySH_f16] f_rest_* too few: have=${r.length}, need=${u}. Will pad zeros.`);const d=3+u;return d!==48&&console.warn(`[copySH_f16] k=${o} gives ${d} halfs; padding to 48 halfs for fixed 24 u32 stride.`),{copySH:(m,p,v=!1)=>{const b=l,y=new Uint16Array(48);y[0]=w(p[t]),y[1]=w(p[s]),y[2]=w(p[n]);let _=3;for(let P=0;P<b;++P){{const S=r[P]?.idx,M=S!==void 0?p[S]:0;y[_++]=w(M)}{const S=r[b+P]?.idx,M=S!==void 0?p[S]:0;y[_++]=w(M)}{const S=r[2*b+P]?.idx,M=S!==void 0?p[S]:0;y[_++]=w(M)}}for(;_<48;)y[_++]=0;for(let P=0;P<48;P+=2)i[m+(P>>1)]=y[P]&65535|(y[P+1]&65535)<<16;v&&console.log(`SH[k=${o}] DC (f16):`,y[0],y[1],y[2])},wordsPerPoint:24}}function dn(a){return Number.isFinite(a[0])&&Number.isFinite(a[1])&&Number.isFinite(a[2])}function Mt(a,e=!0){if(a.length===0)return{centroid:[0,0,0]};let t=0,s=0,n=0;for(const[_,P,S]of a)t+=_,s+=P,n+=S;const o=a.length,i=[t/o,s/o,n/o];if(a.length<3)return{centroid:i};let r=0,l=0,u=0,d=0,f=0,h=0;for(const[_,P,S]of a){const M=_-i[0],j=P-i[1],F=S-i[2];r+=M*M,l+=M*j,u+=M*F,d+=j*j,f+=j*F,h+=F*F}let m=1,p=1,v=1;const b=20;for(let _=0;_<b;_++){const P=r*m+l*p+u*v,S=l*m+d*p+f*v,M=u*m+f*p+h*v,j=Math.hypot(P,S,M);if(j<1e-10)break;m=P/j,p=S/j,v=M/j}let y=[m,p,v];return e&&y[1]<0&&(y=[-y[0],-y[1],-y[2]]),dn(y)?{centroid:i,normal:y}:{centroid:i}}const ds=new WeakMap,fs=new WeakMap;function ft(a){const e=ds.get(a);if(e)return e;const t=a.createBindGroupLayout({label:"point cloud bind group layout",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:3,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}}]});return ds.set(a,t),t}function Tt(a){const e=fs.get(a);if(e)return e;const t=a.createBindGroupLayout({label:"Point Cloud Render Bind Group Layout",entries:[{binding:2,visibility:GPUShaderStage.VERTEX,buffer:{type:"read-only-storage"}}]});return fs.set(a,t),t}const Ut={SPLAT_STRIDE:32};class We{splat2DBuffer;gaussianBufferGPU;shBufferGPU;_bindGroup;_renderBindGroup;numPoints;shDeg;bbox;compressed;colorMode="sh";center;up;transform=new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]);mipSplatting;kernelSize;backgroundColor;_gaussianScaling=1;_maxShDeg=3;_kernelSize=.1;_opacityScale=1;_cutoffScale=1;_rendermode=0;uniforms;modelParamsUniforms;static bindGroupLayout(e){return ft(e)}static renderBindGroupLayout(e){return Tt(e)}constructor(e,t,s){this.numPoints=t.numPoints(),this.shDeg=t.shDegree(),this._maxShDeg=this.shDeg,this.bbox=new et(t.bbox().min,t.bbox().max),this.center=t.center?c.vec3.fromValues(t.center[0],t.center[1],t.center[2]):c.vec3.fromValues(0,0,0),this.up=t.up?c.vec3.fromValues(t.up[0],t.up[1],t.up[2]):null,this.compressed=!1,s?(this.gaussianBufferGPU=s.gaussianBuffer,this.shBufferGPU=s.shBuffer,console.log("ğŸŒŸ PointCloud created with external GPU buffers (no CPU upload)")):(this.gaussianBufferGPU=e.createBuffer({label:"gaussians/storage",size:t.gaussianBuffer().byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),e.queue.writeBuffer(this.gaussianBufferGPU,0,t.gaussianBuffer()),this.shBufferGPU=e.createBuffer({label:"sh/storage",size:t.shCoefsBuffer().byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),e.queue.writeBuffer(this.shBufferGPU,0,t.shCoefsBuffer())),this.splat2DBuffer=e.createBuffer({label:"splat2d/storage",size:Math.max(1,this.numPoints)*Ut.SPLAT_STRIDE,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST|GPUBufferUsage.INDIRECT});const n=new Uint32Array([this.numPoints,this.shDeg,0,0]);this.uniforms=new Le(e,n,"pointcloud uniforms");const o=new ArrayBuffer(128),i=new Float32Array(o),r=new Uint32Array(o);for(let d=0;d<16;d++)i[d]=d%5===0?1:0;r[16]=0,r[17]=this.numPoints,i[18]=this._gaussianScaling,r[19]=this._maxShDeg,i[20]=this._kernelSize,i[21]=this._opacityScale,i[22]=this._cutoffScale,r[23]=this._rendermode,r[24]=1,r[25]=1,i[26]=1,i[27]=0,i[28]=1,i[29]=0,this.modelParamsUniforms=new Le(e,o,"model params");const l=ft(e);this._bindGroup=e.createBindGroup({label:"pointcloud/bg",layout:l,entries:[{binding:0,resource:{buffer:this.gaussianBufferGPU}},{binding:1,resource:{buffer:this.shBufferGPU}},{binding:2,resource:{buffer:this.splat2DBuffer}},{binding:3,resource:{buffer:this.uniforms.buffer}}]});const u=Tt(e);this._renderBindGroup=e.createBindGroup({label:"pointcloud/render/bg",layout:u,entries:[{binding:2,resource:{buffer:this.splat2DBuffer}}]})}bindGroup(){return this._bindGroup}renderBindGroup(){return this._renderBindGroup}replaceStorageBuffers(e,t){this.gaussianBufferGPU=t.gaussianBuffer,this.shBufferGPU=t.shBuffer;const s=ft(e);this._bindGroup=e.createBindGroup({label:"pointcloud/bg",layout:s,entries:[{binding:0,resource:{buffer:this.gaussianBufferGPU}},{binding:1,resource:{buffer:this.shBufferGPU}},{binding:2,resource:{buffer:this.splat2DBuffer}},{binding:3,resource:{buffer:this.uniforms.buffer}}]})}getSplatBuffer(){return{gaussianBuffer:this.gaussianBufferGPU,shBuffer:this.shBufferGPU,numPoints:this.numPoints,shDegree:this.shDeg,bbox:this.bbox}}updateModelParamsBuffer(e,t=0){const s=new ArrayBuffer(128),n=new Float32Array(s),o=new Uint32Array(s);for(let i=0;i<16;i++)n[i]=e[i];o[16]=t,o[17]=this.numPoints,n[18]=this._gaussianScaling,o[19]=this._maxShDeg,n[20]=this._kernelSize,n[21]=this._opacityScale,n[22]=this._cutoffScale,o[23]=this._rendermode,o[24]=1,o[25]=1,n[26]=1,n[27]=0,n[28]=1,n[29]=0,this.modelParamsUniforms.setData(new DataView(s))}setTransform(e){const t=e instanceof Float32Array?e:new Float32Array(e);this.transform.set(t),this.updateModelParamsBuffer(this.transform,0)}updateModelParamsWithOffset(e,t){this.updateModelParamsBuffer(e,t)}setGaussianScaling(e){this._gaussianScaling=e,console.log(`[PointCloud] Gaussian scaling set to: ${e}`)}getGaussianScaling(){return this._gaussianScaling}setMaxShDeg(e){this._maxShDeg=Math.max(0,Math.min(3,e)),console.log(`[PointCloud] Max SH degree set to: ${this._maxShDeg}`)}getMaxShDeg(){return this._maxShDeg}setKernelSize(e){this._kernelSize=Math.max(0,e),console.log(`[PointCloud] Kernel size set to: ${this._kernelSize}`)}getKernelSize(){return this._kernelSize}setOpacityScale(e){this._opacityScale=Math.max(0,e),console.log(`[PointCloud] Opacity scale set to: ${this._opacityScale}`)}getOpacityScale(){return this._opacityScale}setCutoffScale(e){this._cutoffScale=Math.max(.1,e),console.log(`[PointCloud] Cutoff scale set to: ${this._cutoffScale}`)}getCutoffScale(){return this._cutoffScale}setRenderMode(e){this._rendermode=Math.max(0,Math.min(2,e)),console.log(`[PointCloud] Render mode set to: ${this._rendermode}`)}getRenderMode(){return this._rendermode}}var Pe=(a=>(a.STOPPED="stopped",a.PLAYING="playing",a.PAUSED="paused",a))(Pe||{});class fn{_playbackState=Pe.STOPPED;_animationSpeed=1;_eventListeners=[];get playbackState(){return this._playbackState}get animationSpeed(){return this._animationSpeed}get isPlaying(){return this._playbackState===Pe.PLAYING}get isPaused(){return this._playbackState===Pe.PAUSED}get isStopped(){return this._playbackState===Pe.STOPPED}play(e=1){this._animationSpeed=Math.max(.1,e),this._playbackState=Pe.PLAYING,this._emitEvent({type:"play",timestamp:performance.now(),data:{speed:this._animationSpeed}}),console.log(`ğŸ¬ Animation started at ${this._animationSpeed}x speed`)}pause(){this._playbackState===Pe.PLAYING?(this._playbackState=Pe.PAUSED,this._emitEvent({type:"pause",timestamp:performance.now()}),console.log("â¸ï¸ Animation paused")):console.warn("Cannot pause: animation is not playing")}resume(){this._playbackState===Pe.PAUSED?(this._playbackState=Pe.PLAYING,this._emitEvent({type:"resume",timestamp:performance.now()}),console.log("â–¶ï¸ Animation resumed")):console.warn("Cannot resume: animation is not paused")}stop(){this._playbackState=Pe.STOPPED,this._emitEvent({type:"stop",timestamp:performance.now()}),console.log("â¹ï¸ Animation stopped")}setSpeed(e){const t=this._animationSpeed;this._animationSpeed=Math.max(.1,e),t!==this._animationSpeed&&(this._emitEvent({type:"speedChange",timestamp:performance.now(),data:{oldSpeed:t,newSpeed:this._animationSpeed}}),console.log(`ğŸ¯ Animation speed changed from ${t}x to ${this._animationSpeed}x`))}getSpeed(){return this._animationSpeed}reset(){this._playbackState=Pe.STOPPED,this._animationSpeed=1,this._emitEvent({type:"stop",timestamp:performance.now(),data:{reset:!0}}),console.log("ğŸ”„ Animation state reset")}addEventListener(e){this._eventListeners.push(e)}removeEventListener(e){const t=this._eventListeners.indexOf(e);t>-1&&this._eventListeners.splice(t,1)}clearEventListeners(){this._eventListeners=[]}getStateInfo(){return{playbackState:this._playbackState,animationSpeed:this._animationSpeed,isPlaying:this.isPlaying,isPaused:this.isPaused,isStopped:this.isStopped}}_emitEvent(e){this._eventListeners.forEach(t=>{try{t(e)}catch(s){console.error("Error in animation state event listener:",s)}})}}var ht=(a=>(a.FIXED_DELTA="fixed_delta",a.VARIABLE_DELTA="variable_delta",a))(ht||{});class Bt{static calculateDeltaTime(e){const{mode:t,currentTime:s,lastUpdateTime:n,fixedDeltaTime:o,maxDeltaTime:i}=e;switch(t){case"fixed_delta":return o;case"variable_delta":if(n===0)return 0;let r=(s-n)/1e3;return r=Math.min(Math.max(r,0),i),r;default:return console.warn(`Unknown time update mode: ${t}, using fixed delta`),o}}static isValidMode(e){return Object.values(ht).includes(e)}static fromString(e){return this.isValidMode(e)?e:(console.warn(`Invalid time update mode: ${e}, defaulting to FIXED_DELTA`),"fixed_delta")}static getDefaultFixedDeltaTime(){return .016*1.1}static getDefaultMaxDeltaTime(){return .05}static getModeDescription(e){switch(e){case"fixed_delta":return"å›ºå®šæ—¶é—´æ­¥é•¿ - æ¯å¸§ä½¿ç”¨å›ºå®šçš„æ—¶é—´å¢é‡ï¼Œç¡®ä¿åŠ¨ç”»æ’­æ”¾ç¨³å®š";case"variable_delta":return"å¯å˜æ—¶é—´æ­¥é•¿ - æ ¹æ®å®é™…å¸§é—´éš”è®¡ç®—æ—¶é—´å¢é‡ï¼Œæ›´æ¥è¿‘çœŸå®æ—¶é—´";default:return"æœªçŸ¥æ¨¡å¼"}}}class Gt{_frameTime=-1;_lastUpdateTime=0;_config;constructor(e={}){this._config={timeScale:1,timeOffset:0,timeUpdateMode:"fixed_delta",animationSpeed:1,fixedDeltaTime:Bt.getDefaultFixedDeltaTime(),maxDeltaTime:Bt.getDefaultMaxDeltaTime(),...e}}get frameTime(){return this._frameTime}get config(){return{...this._config}}updateConfig(e){this._config={...this._config,...e}}setTimeScale(e){this._config.timeScale=Math.max(.01,e),console.log(`[TimeCalculator] Time scale set to: ${this._config.timeScale}`)}getTimeScale(){return this._config.timeScale}setTimeOffset(e){this._config.timeOffset=e,console.log(`[TimeCalculator] Time offset set to: ${this._config.timeOffset}`)}getTimeOffset(){return this._config.timeOffset}setTimeUpdateMode(e){this._config.timeUpdateMode=e,e==="variable_delta"&&(this._lastUpdateTime=0),console.log(`[TimeCalculator] Time update mode set to: ${e}`)}getTimeUpdateMode(){return this._config.timeUpdateMode}setAnimationSpeed(e){this._config.animationSpeed=Math.max(.1,e),console.log(`[TimeCalculator] Animation speed set to: ${this._config.animationSpeed}`)}getAnimationSpeed(){return this._config.animationSpeed}calculateTime(e=performance.now(),t=!0,s=!1){let n=0,o=!1;t&&!s?(this._lastUpdateTime,this._config.timeScale,this._config.animationSpeed,this._config.timeUpdateMode,this._config.fixedDeltaTime,this._config.maxDeltaTime,n=Bt.calculateDeltaTime({mode:this._config.timeUpdateMode,currentTime:e,lastUpdateTime:this._lastUpdateTime,fixedDeltaTime:this._config.fixedDeltaTime,maxDeltaTime:this._config.maxDeltaTime}),n*=this._config.timeScale*this._config.animationSpeed,this._frameTime+=n,o=!0):s&&this._config.timeUpdateMode==="variable_delta"&&(this._lastUpdateTime=e),this._lastUpdateTime=e;const i=this.getAdjustedTime();return{deltaTime:n,frameTime:this._frameTime,adjustedTime:i,shouldUpdate:o}}getAdjustedTime(){return(this._frameTime-this._config.timeOffset)*this._config.timeScale}setTime(e){this._frameTime=e,this._lastUpdateTime=0,console.log(`[TimeCalculator] Time set to: ${e.toFixed(3)}s`)}resetTime(){this._frameTime=0,this._lastUpdateTime=0,console.log("[TimeCalculator] Time reset to 0")}getStats(){return{frameTime:this._frameTime,adjustedTime:this.getAdjustedTime(),timeScale:this._config.timeScale,timeOffset:this._config.timeOffset,timeUpdateMode:this._config.timeUpdateMode,animationSpeed:this._config.animationSpeed,lastUpdateTime:this._lastUpdateTime}}clone(){const e=new Gt(this._config);return e._frameTime=this._frameTime,e._lastUpdateTime=this._lastUpdateTime,e}}const hs=-.5;class hn{animationState;timeCalculator;config;frameCount=0;eventListeners=[];constructor(e={}){this.config={timeScale:1,timeOffset:0,timeUpdateMode:"fixed_delta",animationSpeed:1,fixedDeltaTime:.016*1.1,maxDeltaTime:.05,...e},this.animationState=new fn,this.timeCalculator=new Gt(this.config),this.animationState.addEventListener(t=>{this._emitEvent(t)})}start(e){this.animationState.play(e)}pause(){this.animationState.pause()}resume(){this.animationState.resume()}stop(){this.animationState.stop(),this.frameCount=0}setTime(e){this.timeCalculator.setTime(e),this._emitEvent({type:"timeChange",timestamp:performance.now(),data:{time:e}})}setSpeed(e){this.animationState.setSpeed(e),this.timeCalculator.setAnimationSpeed(e)}setTimeScale(e){this.timeCalculator.setTimeScale(e),this.config.timeScale=e}setTimeOffset(e){this.timeCalculator.setTimeOffset(e),this.config.timeOffset=e}setTimeUpdateMode(e){this.timeCalculator.setTimeUpdateMode(e),this.config.timeUpdateMode=e}startAnimation(e=1){this.start(e)}pauseAnimation(){this.pause()}resumeAnimation(){this.resume()}stopAnimation(){this.stop()}setAnimationTime(e){this.setTime(e)}setAnimationSpeed(e){this.setSpeed(e)}getAnimationSpeed(){return this.animationState.getSpeed()}getTimeScale(){return this.timeCalculator.getTimeScale()}getTimeOffset(){return this.timeCalculator.getTimeOffset()}getTimeUpdateMode(){return this.timeCalculator.getTimeUpdateMode()}update(e){const t=this.timeCalculator.calculateTime(e,this.animationState.isPlaying,this.animationState.isPaused);return t.shouldUpdate&&this.frameCount++,t.adjustedTime}getCurrentTime(){return this.timeCalculator.getAdjustedTime()}getFrameTime(){return this.timeCalculator.frameTime}isFallbackPreviewMode(){return this.timeCalculator.frameTime<hs}isPlaying(){return this.animationState.isPlaying}isPaused(){return this.animationState.isPaused}isStopped(){return this.animationState.isStopped}supportsAnimation(){return!0}getStats(){const e=this.timeCalculator.getStats(),t=this.animationState.getStateInfo();return{currentTime:e.frameTime,adjustedTime:e.adjustedTime,timeScale:e.timeScale,timeOffset:e.timeOffset,timeUpdateMode:e.timeUpdateMode,animationSpeed:e.animationSpeed,playbackState:t.playbackState,isPlaying:t.isPlaying,isPaused:t.isPaused,isStopped:t.isStopped,lastUpdateTime:e.lastUpdateTime,frameCount:this.frameCount}}clearEventListeners(){this.eventListeners=[],this.animationState.clearEventListeners()}_emitEvent(e){this.eventListeners.forEach(t=>{try{t(e)}catch(s){console.error("Error in timeline event listener:",s)}})}static FALLBACK_PREVIEW_THRESHOLD=hs}class Be extends We{_countBuf;onnxGenerator;timeline;gaussianPrecision;colorPrecision;is_loop=!0;colorMode;colorChannels;constructor(e,t,s,n,o,i=48,r){let l;switch(i){case 3:l=0;break;case 12:l=1;break;case 27:l=2;break;case 48:l=3;break;default:console.warn(`âš ï¸ Unexpected color channels: ${i}, Maybe rgb channels`),l=3}console.log(`ğŸ¨ DynamicPointCloud: ${i} channels â†’ SH degree ${l}`);const u={numPoints:()=>n,shDegree:()=>l,bbox:()=>({min:[-1,-1,-1],max:[1,1,1]}),center:[0,0,0],up:null,gaussianBuffer:()=>new ArrayBuffer(0),shCoefsBuffer:()=>new ArrayBuffer(0)};super(e,u,{gaussianBuffer:t,shBuffer:s}),this.colorChannels=i,this.colorMode=i===4?"rgb":"sh",console.log(`ğŸ¨ Color mode set: ${this.colorMode} (${this.colorChannels} channels)`),this._countBuf=o,this.gaussianPrecision=r?.gaussian,this.colorPrecision=r?.color,this.timeline=new hn({timeScale:1,timeOffset:0,timeUpdateMode:"fixed_delta",animationSpeed:1}),console.log("ğŸŒŸ DynamicPointCloud created with direct GPU buffers (no CPU upload)")}countBuffer(){return this._countBuf}setOnnxGenerator(e){this.onnxGenerator=e,console.log("ğŸ”— ONNX generator linked for dynamic updates")}getGaussianPrecision(){return this.gaussianPrecision}getColorPrecision(){return this.colorPrecision}setPrecisionForShader(){const e=this.modelParamsUniforms.data,t=new DataView(e),s=n=>{switch(n){case"float32":return 0;case"float16":return 1;case"int8":return 2;case"uint8":return 3;default:return 1}};this.gaussianPrecision&&(t.setUint32(96,s(this.gaussianPrecision.dataType),!0),typeof this.gaussianPrecision.scale=="number"&&t.setFloat32(104,this.gaussianPrecision.scale,!0),typeof this.gaussianPrecision.zeroPoint=="number"&&t.setFloat32(108,this.gaussianPrecision.zeroPoint,!0)),this.colorPrecision&&(t.setUint32(100,s(this.colorPrecision.dataType),!0),typeof this.colorPrecision.scale=="number"&&t.setFloat32(112,this.colorPrecision.scale,!0),typeof this.colorPrecision.zeroPoint=="number"&&t.setFloat32(116,this.colorPrecision.zeroPoint,!0)),this.modelParamsUniforms.dataBytes=e}applyFP16(e,t,s){this.replaceStorageBuffers(e,{gaussianBuffer:t,shBuffer:s}),this.gaussianPrecision={dataType:"float16",bytesPerElement:2},this.colorPrecision={dataType:"float16",bytesPerElement:2},this.setPrecisionForShader()}async update(e,t,s,n,o){if(!this.onnxGenerator){console.warn("âš ï¸ No ONNX generator available for dynamic update");return}var i=0;i=this.timeline.getCurrentTime(),i=i*.4%1,this.timeline.isFallbackPreviewMode()&&(i=s??0,i=i*.4,i=i%1);try{const r=this.onnxGenerator.getInputNames(),l=c.mat4.create();c.mat4.multiply(l,e,t),this.is_loop?i=i%1:i=Math.max(0,Math.min(i,1));const u={cameraMatrix:new Float32Array(l),projectionMatrix:n?new Float32Array(n):void 0,time:i};await this.onnxGenerator.generate(u)}catch(r){console.error("âŒ Dynamic update failed:",r)}}startAnimation(e=1){this.timeline.startAnimation(e)}pauseAnimation(){this.timeline.pauseAnimation()}resumeAnimation(){this.timeline.resumeAnimation()}stopAnimation(){this.timeline.stopAnimation()}setAnimationTime(e){this.timeline.setAnimationTime(e)}setAnimationSpeed(e){this.timeline.setAnimationSpeed(e)}getAnimationSpeed(){return this.timeline.getAnimationSpeed()}get isAnimationRunning(){return this.timeline.isPlaying()}get isAnimationPaused(){return this.timeline.isPaused()}get isAnimationStopped(){return this.timeline.isStopped()}setTimeScale(e){this.timeline.setTimeScale(e)}getTimeScale(){return this.timeline.getTimeScale()}setTimeOffset(e){this.timeline.setTimeOffset(e)}setAnimationIsLoop(e){this.is_loop=e}getTimeOffset(){return this.timeline.getTimeOffset()}getFrameTime(){return this.timeline.getCurrentTime()}resetFrameTime(){this.timeline.setTime(0)}setTimeUpdateMode(e){this.timeline.setTimeUpdateMode(e)}getTimeUpdateMode(){return this.timeline.getTimeUpdateMode()==="fixed_delta"?ht.FIXED_DELTA:ht.VARIABLE_DELTA}getPerformanceStats(){return{...this.timeline.getStats(),hasOnnxGenerator:!!this.onnxGenerator,colorMode:this.colorMode,colorChannels:this.colorChannels,numPoints:this.numPoints}}dispose(){this.timeline.clearEventListeners(),console.log("ğŸ§¹ DynamicPointCloud disposed")}}const ms=Object.freeze(Object.defineProperty({__proto__:null,BUFFER_CONFIG:Ut,DynamicPointCloud:Be,PointCloud:We,getBindGroupLayout:ft,getRenderBindGroupLayout:Tt},Symbol.toStringTag,{value:"Module"})),mn=`// enable f16;
const KERNEL_SIZE:f32 = 0.3;
//const MAX_SH_DEG:u32 = <injected>u;


override SH_LAYOUT_CHANNEL_MAJOR : bool = false;
override USE_RAW_COLOR : bool = false;

const SH_C0:f32 = 0.28209479177387814;

const SH_C1 = 0.4886025119029199;
const SH_C2 = array<f32,5>(
    1.0925484305920792,
    -1.0925484305920792,
    0.31539156525252005,
    -1.0925484305920792,
    0.5462742152960396
);

const SH_C3 = array<f32,7>(
    -0.5900435899266435,
    2.890611442640554,
    -0.4570457994644658,
    0.3731763325901154,
    -0.4570457994644658,
    1.445305721320277,
    -0.5900435899266435
);


struct CameraUniforms {
    view: mat4x4<f32>,
    view_inv: mat4x4<f32>,
    proj: mat4x4<f32>,
    proj_inv: mat4x4<f32>,
    
    viewport: vec2<f32>,
    focal: vec2<f32>
};

struct Gaussian {
    pos_opacity: array<u32,2>,
    cov: array<u32,3>
}

struct Splat {
     // 4x f16 packed as u32
    v_0: u32, v_1: u32,
    // 2x f16 packed as u32 (NDC x,y)
    pos: u32,
    // NDC z (high precision)
    posz: f32,
    // rgba packed as f16
    color_0: u32,color_1: u32
};

struct DrawIndirect {
    /// The number of gaussians to draw.
    vertex_count: u32,
    /// The number of instances to draw.
    instance_count: atomic<u32>,
    /// The Index of the first vertex to draw.
    base_vertex: u32,
    /// The instance ID of the first instance to draw.
    /// Has to be 0, unless [\`Features::INDIRECT_FIRST_INSTANCE\`](crate::Features::INDIRECT_FIRST_INSTANCE) is enabled.
    base_instance: u32,
}

struct DispatchIndirect {
    dispatch_x: atomic<u32>,
    dispatch_y: u32,
    dispatch_z: u32,
}

struct SortInfos {
    keys_size: atomic<u32>,     // essentially contains the same info as instance_count in DrawIndirect
    padded_size: u32,
    passes: u32,
    even_pass: u32,
    odd_pass: u32,
}

struct RenderSettings {
    clipping_box_min: vec4<f32>,
    clipping_box_max: vec4<f32>,
    max_sh_deg: u32,
    show_env_map: u32,
    mip_spatting: u32,
    kernel_size: f32,
    walltime: f32,
    scene_extend: f32,
    center: vec3<f32>,
}

override DISCARD_BY_WORLD_TRACE   : bool = false;  // å¯é€‰ï¼šworld-space è¿‘ä¼¼é˜ˆå€¼
override MAX_WORLD_TRACE          : f32  = 0.25;   // åæ–¹å·®è¿¹ä¸Šé™ï¼ˆå•ä½â‰ˆç±³^2ï¼ŒæŒ‰ä½ çš„å°ºåº¦è°ƒï¼‰

@group(0) @binding(0)
var<uniform> camera: CameraUniforms;

// Shared buffer - read as different types based on gaussDataType
@group(1) @binding(0) 
var<storage,read> gaussians_packed : array<u32>; // Uint32Array backing

@group(1) @binding(1)
var<storage, read> color_buffer : array<u32>; // Uint32Array backing

@group(1) @binding(2) 
var<storage,read_write> points_2d : array<Splat>;



@group(2) @binding(0)
var<storage, read_write> sort_infos: SortInfos;
@group(2) @binding(1)
var<storage, read_write> sort_depths : array<u32>;
@group(2) @binding(2)
var<storage, read_write> sort_indices : array<u32>;
@group(2) @binding(3)
var<storage, read_write> sort_dispatch: DispatchIndirect;

@group(3) @binding(0)
var<uniform> render_settings: RenderSettings;

// Phase B M1: per-model params
struct ModelParams {
    model: mat4x4<f32>,
    baseOffset: u32,
    num_points: u32,  // Dynamic point count from ONNX (was _pad0)
    gaussianScaling: f32,  // æ¯ä¸ªæ¨¡å‹çš„ç‹¬ç«‹é«˜æ–¯ç¼©æ”¾å‚æ•°
    maxShDeg: u32,        // çƒè°ç­‰çº§
    kernelSize: f32,      // äºŒç»´æ ¸å¤§å°
    opacityScale: f32,    // é€æ˜åº¦å€æ•°
    cutoffScale: f32,     // æœ€å¤§åƒç´ æ¯”ä¾‹å€æ•°
    rendermode: u32,      // æ¸²æŸ“æ¨¡å¼: 0=é¢œè‰², 1=æ³•çº¿, 2=æ·±åº¦
    // å¤šç²¾åº¦æ”¯æŒ
    gaussDataType: u32,   // 0=f32, 1=f16, 2=i8, 3=u8
    colorDataType: u32,
    gaussScale: f32,
    gaussZeroPoint: f32,
    colorScale: f32,
    colorZeroPoint: f32,
}

@group(3) @binding(1)
var<uniform> uModel: ModelParams;






// Helper: read gaussian pos+opacity based on precision
fn read_gaussian_pos_opacity(idx: u32) -> vec4<f32> {
  if (uModel.gaussDataType == 0u) {
    // FP32: 4 consecutive f32s
    let base = idx * 10u;
    return vec4<f32>(
      bitcast<f32>(gaussians_packed[base + 0u]),
      bitcast<f32>(gaussians_packed[base + 1u]),
      bitcast<f32>(gaussians_packed[base + 2u]),
      bitcast<f32>(gaussians_packed[base + 3u])
    );
  } else {
    // FP16: packed as 2 u32s (pos_xy + pos_z_opacity)
    let w0 = gaussians_packed[idx * 5u + 0u];
    let w1 = gaussians_packed[idx * 5u + 1u];
    let a = unpack2x16float(w0);
    let b = unpack2x16float(w1);
    return vec4<f32>(a.x, a.y, b.x, b.y);
  }
}

// Helper: read gaussian covariance (6 floats) based on precision
fn read_gaussian_cov(idx: u32) -> array<f32,6> {
  if (uModel.gaussDataType == 0u) {
    // FP32: 6 consecutive f32s starting at idx*10+4
    let base = idx * 10u + 4u;
    return array<f32,6>(
      bitcast<f32>(gaussians_packed[base + 0u]),
      bitcast<f32>(gaussians_packed[base + 1u]),
      bitcast<f32>(gaussians_packed[base + 2u]),
      bitcast<f32>(gaussians_packed[base + 3u]),
      bitcast<f32>(gaussians_packed[base + 4u]),
      bitcast<f32>(gaussians_packed[base + 5u])
    );
  } else {
    // FP16: packed as 3 u32s
    let a = unpack2x16float(gaussians_packed[idx * 5u + 2u]);
    let b = unpack2x16float(gaussians_packed[idx * 5u + 3u]);
    let c = unpack2x16float(gaussians_packed[idx * 5u + 4u]);
    return array<f32,6>(a.x, a.y, b.x, b.y, c.x, c.y);
  }
}

// ---- å°å·¥å…·ï¼šè®¡ç®—è¯¥ç‚¹çš„èµ·å§‹ word ä¸‹æ ‡ ----
fn base_word_of(splat_idx: u32) -> u32 {
    if (USE_RAW_COLOR) {
        // RGB ç›´æ¥é¢œè‰²ï¼šæ¯ç‚¹çš„å­˜å‚¨å­—æ•°å–å†³äºé¢œè‰²ç²¾åº¦
        if (uModel.colorDataType == 0u) { // fp32: 3 words
            return splat_idx * 3u;
        } else if (uModel.colorDataType == 1u) { // fp16: 2 words (4 halfs)
            return splat_idx * 2u;
        } else { // int8/uint8: 1 word (4 bytes)
            return splat_idx * 1u;
        }
    }
    // SHï¼šæŒ‰ç²¾åº¦å’Œé€šé“æ•°è®¡ç®—
    if (uModel.colorDataType == 0u) {
      // FP32: 48 channels (degree 3) = 48 words
      return splat_idx * 48u;
    } else {
      // FP16: 48 channels = 48 halfs = 24 words
      return splat_idx * 24u;
    }
}

// è¯»ç¬¬ word_idx ä¸ª u32
fn read_word(splat_idx: u32, word_idx: u32) -> u32 {
  return color_buffer[base_word_of(splat_idx) + word_idx];
}

// ===== è¯»åŠç²¾â€œæ ‡é‡â€ï¼šçº¿æ€§ half ä¸‹æ ‡ï¼ˆ0,1,2,3, ...ï¼‰=====
fn read_half_at(splat_idx: u32, half_idx: u32) -> f32 {
  let w = read_word(splat_idx, half_idx >> 1u);
  let p = unpack2x16float(w);                 // vec2<f32>ï¼Œä½/é«˜ half
  // å¦‚æœ half_idx æ˜¯å¥‡æ•°å–é«˜ä½ï¼Œå¦åˆ™å–ä½ä½
  return select(p.x, p.y, (half_idx & 1u) == 1u);
}

// ===== è¿ç»­é¢œè‰²ï¼šç›´æ¥è¯»å–å‰ä¸‰ä¸ª half ä½œä¸ºæœ€ç»ˆ RGB =====
// è¯»å–é¢œè‰²åˆ†é‡ï¼ˆä¾æ®æ•°æ®ç±»å‹ï¼‰
fn read_color_channel(splat_idx: u32, channel_idx: u32) -> f32 {
  if (uModel.colorDataType == 0u) {
    // fp32ï¼šæ¯é€šé“ 1 word
    let w = read_word(splat_idx, channel_idx);
    return bitcast<f32>(w);
  } else if (uModel.colorDataType == 1u) {
    // fp16ï¼šæŒ‰ half è¯»å–
    return read_half_at(splat_idx, channel_idx);
  } else {
    // int8/uint8ï¼šä» word ä¸­æå– 8-bitï¼Œç„¶ååé‡åŒ–
    let packed = read_word(splat_idx, channel_idx >> 2u);
    let byte_off = (channel_idx & 3u) * 8u;
    let q = extractBits(i32(packed), byte_off, 8u);
    return f32(q) * uModel.colorScale + uModel.colorZeroPoint;
  }
}

fn fetch_rgb_no_sh(splat_idx: u32) -> vec3<f32> {
  return vec3<f32>(
    read_color_channel(splat_idx, 0u),
    read_color_channel(splat_idx, 1u),
    read_color_channel(splat_idx, 2u)
  );
}

fn sh_coef_interleaved(splat_idx: u32, c_idx: u32) -> vec3<f32> {
  // c_idx âˆˆ [0 .. (deg+1)^2-1]ï¼Œæ¯ä¸ªç³»æ•° 3 ä¸ª half è¿ç€
  let h0 = c_idx * 3u;
  return vec3<f32>(
    read_color_channel(splat_idx, h0 + 0u),
    read_color_channel(splat_idx, h0 + 1u),
    read_color_channel(splat_idx, h0 + 2u)
  );
}

// æ–°çš„ï¼šchannel-majorï¼ˆ[Rdc,Gdc,Bdc, R1..Rm, G1..Gm, B1..Bm]ï¼‰
fn sh_coef_channel_major(splat_idx: u32, c_idx: u32) -> vec3<f32> {
  if (c_idx == 0u) {
    // DC
    return vec3<f32>(
      read_color_channel(splat_idx, 0u),
      read_color_channel(splat_idx, 1u),
      read_color_channel(splat_idx, 2u)
    );
  }
  // AC
  let m  = (uModel.maxShDeg + 1u) * (uModel.maxShDeg + 1u) - 1u; // æ¯é€šé“ AC æ•°
  let k  = c_idx - 1u;                   // ç¬¬ k ä¸ª ACï¼Œk âˆˆ [0..m-1]
  let r  = read_color_channel(splat_idx, 3u + k);
  let g  = read_color_channel(splat_idx, 3u + m + k);
  let b  = read_color_channel(splat_idx, 3u + 2u*m + k);
  return vec3<f32>(r, g, b);
}

// ç»Ÿä¸€å…¥å£ï¼šæ ¹æ®å¸ƒå±€é€‰æ‹©
fn sh_coef(splat_idx: u32, c_idx: u32) -> vec3<f32> {
  return select(
    sh_coef_interleaved(splat_idx, c_idx),
    sh_coef_channel_major(splat_idx, c_idx),
    SH_LAYOUT_CHANNEL_MAJOR
  );
}




fn evaluate_sh(dir: vec3<f32>, v_idx: u32, sh_deg: u32) -> vec3<f32> {
    var result = SH_C0 * sh_coef(v_idx, 0u) ;
    // sh_deg = 0;
    if sh_deg > 0u {

        let x = dir.x;
        let y = dir.y;
        let z = dir.z;

        result += - SH_C1 * y * sh_coef(v_idx, 1u) + SH_C1 * z * sh_coef(v_idx, 2u) - SH_C1 * x * sh_coef(v_idx, 3u);

        if sh_deg > 1u {

            let xx = dir.x * dir.x;
            let yy = dir.y * dir.y;
            let zz = dir.z * dir.z;
            let xy = dir.x * dir.y;
            let yz = dir.y * dir.z;
            let xz = dir.x * dir.z;

            result += SH_C2[0] * xy * sh_coef(v_idx, 4u) + SH_C2[1] * yz * sh_coef(v_idx, 5u) + SH_C2[2] * (2.0 * zz - xx - yy) * sh_coef(v_idx, 6u) + SH_C2[3] * xz * sh_coef(v_idx, 7u) + SH_C2[4] * (xx - yy) * sh_coef(v_idx, 8u);

            if sh_deg > 2u {
                result += SH_C3[0] * y * (3.0 * xx - yy) * sh_coef(v_idx, 9u) + SH_C3[1] * xy * z * sh_coef(v_idx, 10u) + SH_C3[2] * y * (4.0 * zz - xx - yy) * sh_coef(v_idx, 11u) + SH_C3[3] * z * (2.0 * zz - 3.0 * xx - 3.0 * yy) * sh_coef(v_idx, 12u) + SH_C3[4] * x * (4.0 * zz - xx - yy) * sh_coef(v_idx, 13u) + SH_C3[5] * z * (xx - yy) * sh_coef(v_idx, 14u) + SH_C3[6] * x * (xx - 3.0 * yy) * sh_coef(v_idx, 15u);
            }
        }
    }
    result += 0.5;

    return result;
}


fn evaluate_color(dir: vec3<f32>, v_idx: u32, sh_deg: u32) -> vec3<f32> {
    if (USE_RAW_COLOR) {
        // ç›´æ¥é¢œè‰²ï¼ˆ0..1ï¼‰ï¼Œä¸åš +0.5
        return fetch_rgb_no_sh(v_idx);
    } else {
        // çƒè°è·¯å¾„ï¼ševaluate_sh already adds 0.5 at the end
        return evaluate_sh(dir, v_idx, sh_deg);
    }
}


fn cov_coefs(v_idx: u32) -> array<f32,6> {
    return read_gaussian_cov(v_idx);
}


// normal calculation
fn inverse_sym3(m: mat3x3<f32>) -> mat3x3<f32> {
    // m = [[a,b,c],[b,d,e],[c,e,f]]
    let a = m[0][0]; let b = m[0][1]; let c = m[0][2];
    let d = m[1][1]; let e = m[1][2];
    let f = m[2][2];

    let co00 = d*f - e*e;
    let co01 = c*e - b*f;
    let co02 = b*e - c*d;
    let co11 = a*f - c*c;
    let co12 = c*b - a*e;
    let co22 = a*d - b*b;

    let det = a*co00 + b*co01 + c*co02;
    let eps = 1e-12;
    let inv_det = select(1.0/det, 1.0/eps, abs(det) < eps);

    // å¯¹ç§°ï¼šåªéœ€å¡«ä¸Šä¸‰è§’
    var inv = mat3x3<f32>(
        vec3<f32>(co00, co01, co02),
        vec3<f32>(co01, co11, co12),
        vec3<f32>(co02, co12, co22)
    );
    return inv * inv_det;
}

fn smallest_evec_via_power(Sigma_world: mat3x3<f32>) -> vec3<f32> {
    let invS = inverse_sym3(Sigma_world);
    // é€‰ä¸ªç¨³å®šçš„åˆå§‹å‘é‡ï¼ˆå–åˆ—å’Œå¯ä»¥é¿å…é€€åŒ–ï¼‰
    var v = normalize(invS[0] + invS[1] + invS[2]);
    // å°‘é‡è¿­ä»£å³å¯ï¼ˆ3~5 æ¬¡ï¼‰
    v = normalize(invS * v);
    v = normalize(invS * v);
    v = normalize(invS * v);
    return v; // æœªå®šå‘ï¼Œä¹‹åå¯æŒ‰ç›¸æœºç¿»è½¬
}

fn normal_view_dependent(Sigma_world: mat3x3<f32>, cam_world: vec3<f32>, x_world: vec3<f32>) -> vec3<f32> {
    let v = normalize(cam_world - x_world);                // ä»ç‚¹æŒ‡å‘ç›¸æœº
    let invS = inverse_sym3(Sigma_world);
    var n = normalize(invS * v);                           // âˆ Î£^{-1} v
    // ä½¿æ³•çº¿æœå‘ç›¸æœºï¼ˆå¯é€‰ï¼‰
    if (dot(n, v) < 0.0) { n = -n; }
    return n;
}


@compute @workgroup_size(256,1,1)
fn preprocess(@builtin(global_invocation_id) gid: vec3<u32>, @builtin(num_workgroups) wgs: vec3<u32>) {
    let idx = gid.x;
    // Use dynamic point count from ONNX instead of full gaussian array length
    if idx >= uModel.num_points  {
   //     return;
    }
    if idx > 500000  {
       // return;
    }
    let focal = camera.focal;
    let viewport = camera.viewport;
    let pos_op = read_gaussian_pos_opacity(idx);
    let xyz_local = pos_op.xyz;
    let xyz = (uModel.model * vec4<f32>(xyz_local, 1.)).xyz;
    var opacity = pos_op.w * uModel.opacityScale;

    
    // uModel.maxShDeg = 0;

    var camspace = camera.view * vec4<f32>(xyz, 1.);
    let pos2d = camera.proj * camspace;
    let bounds = 1.2 * pos2d.w;
    let z = pos2d.z / pos2d.w;

    if uModel.baseOffset == 0u && idx == 0u {
        atomicAdd(&sort_dispatch.dispatch_x, 1u);   // safety addition to always have an unfull block at the end of the buffer
    }

    // TODO bring back frustrum culling
    // M1: no world-space clipping here to avoid sparse writes
    // if any(xyz < render_settings.clipping_box_min.xyz) || any(xyz > render_settings.clipping_box_max.xyz) { return; }


    // M1: disable frustum culling to keep dense writes
    if z <= 0. || z >= 1. || pos2d.x < -bounds || pos2d.x > bounds || pos2d.y < -bounds || pos2d.y > bounds { return; }

    if (opacity <0.02)
    {
        return;
    }


    if (opacity > 0.98)
    {
      //  return;
    }

    let cov_sparse = cov_coefs(idx);

    
    var scale_mod = 0.;

    scale_mod = 1.0;
    let scaling = uModel.gaussianScaling * scale_mod * 1.0f;

    // --- 1) å±€éƒ¨åæ–¹å·®ï¼ˆä¿æŒä¸å˜ï¼‰
    let Sigma_local = mat3x3<f32>(
        cov_sparse[0], cov_sparse[1], cov_sparse[2],
        cov_sparse[1], cov_sparse[3], cov_sparse[4],
        cov_sparse[2], cov_sparse[4], cov_sparse[5]
    ) * scaling * scaling;

    // --- 2) ç”¨æ¨¡å‹çŸ©é˜µçš„çº¿æ€§éƒ¨åˆ†æŠŠåæ–¹å·®ä» local å˜åˆ° world
    // æ³¨æ„ï¼šWGSL æŒ‰åˆ—å­˜å‚¨ï¼Œè¿™é‡Œå– model çš„å‰ä¸‰åˆ—ä½œä¸º 3x3 çº¿æ€§éƒ¨åˆ†
    let A = mat3x3<f32>(
        uModel.model[0].xyz,  // ç¬¬0åˆ—
        uModel.model[1].xyz,  // ç¬¬1åˆ—
        uModel.model[2].xyz   // ç¬¬2åˆ—
    );
    let Sigma_world = A * Sigma_local * transpose(A);

    // --- 3 ä½ çš„ Jï¼ˆcam â†’ NDCï¼‰çš„å†™æ³•å¯ä»¥æ²¿ç”¨
    let J = mat3x3<f32>(
        focal.x / camspace.z,  0.0,                         -(focal.x * camspace.x) / (camspace.z * camspace.z),
        0.0,                  -focal.y / camspace.z,        (focal.y * camspace.y) / (camspace.z * camspace.z),
        0.0,                   0.0,                          0.0
    );

    // --- 4) å– view çš„ 3x3 çº¿æ€§éƒ¨åˆ†ï¼ˆworld â†’ cameraï¼‰
    let W = transpose(mat3x3<f32>(
        camera.view[0].xyz,
        camera.view[1].xyz,
        camera.view[2].xyz
    ));

    // --- 5) æ­£ç¡®çš„ç»„åˆï¼šT = J * Vï¼Œç„¶å Î£_ndc = T Î£_world T^T
    let T   = W * J;
    let cov = transpose(T) * Sigma_world * T;



    if (true) {
        let world_trace = Sigma_local[0][0] + Sigma_local[1][1] + Sigma_local[2][2];
        if (world_trace > 1000.0000002) {
            //return;
        }
    }


    let kernel_size = uModel.kernelSize;
    if bool(render_settings.mip_spatting) {
        // according to Mip-Splatting by Yu et al. 2023
        let det_0 = max(1e-6, cov[0][0] * cov[1][1] - cov[0][1] * cov[0][1]);
        let det_1 = max(1e-6, (cov[0][0] + kernel_size) * (cov[1][1] + kernel_size) - cov[0][1] * cov[0][1]);
        var coef = sqrt(det_0 / (det_1 + 1e-6) + 1e-6);

        if det_0 <= 1e-6 || det_1 <= 1e-6 {
            coef = 0.0;
        }
        opacity *= coef;
    }

    //opacity = 0.1;

    let diagonal1 = cov[0][0] + kernel_size;
    let offDiagonal = cov[0][1];
    let diagonal2 = cov[1][1] + kernel_size;

    let mid = 0.5 * (diagonal1 + diagonal2);
    let radius = length(vec2<f32>((diagonal1 - diagonal2) / 2.0, offDiagonal));
    // eigenvalues of the 2D screen space splat
    let lambda1 = mid + radius;
    let lambda2 = max(mid - radius, 0.1);

    let diagonalVector = normalize(vec2<f32>(offDiagonal, lambda1 - diagonal1));
    // scaled eigenvectors in screen space 
    let v1 = sqrt(2.0 * lambda1) * diagonalVector * uModel.cutoffScale;
    let v2 = sqrt(2.0 * lambda2) * vec2<f32>(diagonalVector.y, -diagonalVector.x) * uModel.cutoffScale;

    let v_center = pos2d.xyzw / pos2d.w;

    let camera_pos = camera.view_inv[3].xyz;
    // let dir = normalize(xyz - camera_pos);
    // DEBUG: prepare color var (assigned after store_idx is known)



    let t = uModel.model[3].xyz;

    // --- ä¸–ç•Œç›¸æœºä½ç½®
    let cam_world = camera.view_inv[3].xyz;

    // --- è®¡ç®— s^2 ï¼ˆç­‰æ¯”ç¼©æ”¾ä¸‹ä¸‰åˆ—é•¿åº¦å¹³æ–¹ç›¸ç­‰ï¼Œå–å‡å€¼æ›´ç¨³ï¼‰
    let s2 = max(
        1e-12,
        (dot(A[0], A[0]) + dot(A[1], A[1]) + dot(A[2], A[2])) / 3.0
    );

    // --- cam_local = A^{-1} * (cam_world - t) = (A^T / s^2) * (cam_world - t)
    let cam_local = (transpose(A) * (cam_world - t)) / s2;

    // --- ç”¨å±€éƒ¨æ–¹å‘è¯„ä¼° SH
    let dir_local = normalize(xyz_local - cam_local);



    var color: vec4<f32>;
    
    
    // color = vec4<f32>(sh_coef(0, 1u),opacity);

    // M1 (revised): use global contiguous index to avoid per-dispatch uniform dependency
    let store_idx = atomicAdd(&sort_infos.keys_size, 1u);
    let global_index = store_idx;
    // æ ¹æ®æ¸²æŸ“æ¨¡å¼é€‰æ‹©ä¸åŒçš„é¢œè‰²
    if (uModel.rendermode == 0u) {
        // æ¨¡å¼0: æ­£å¸¸é¢œè‰² (SH evaluation or direct RGB)
        color = vec4<f32>(
            max(vec3<f32>(0.), evaluate_color(dir_local, idx, uModel.maxShDeg)),
            opacity
        );
    } else if (uModel.rendermode == 1u) {
        // æ¨¡å¼1: æ³•çº¿å¯è§†åŒ–ï¼ˆè§†è§’æ— å…³ï¼šæœ€å°ç‰¹å¾å‘é‡ï¼Œä½¿ç”¨è‡ªèº«åˆ†é‡ç¡®å®šç¬¦å·ï¼Œé¿å…è§†è§’è§¦å‘ç¿»è½¬ï¼‰
        var n_world = smallest_evec_via_power(Sigma_world);

        // é€‰æœ€å¤§å¹…å€¼åˆ†é‡çš„ç¬¦å·ä½œä¸ºé”šç‚¹ï¼Œä¿è¯ç¬¦å·åœ¨ä¸åŒè§†è§’ä¸‹ä¿æŒä¸€è‡´
        let abs_n = abs(n_world);
        if (abs_n.x >= abs_n.y && abs_n.x >= abs_n.z) {
            if (n_world.x < 0.0) { n_world = -n_world; }
        } else if (abs_n.y >= abs_n.z) {
            if (n_world.y < 0.0) { n_world = -n_world; }
        } else {
            if (n_world.z < 0.0) { n_world = -n_world; }
        }

        // å½’ä¸€åŒ–ï¼Œé¿å…é•¿åº¦æ¼‚ç§»/æ•°å€¼å™ªå£°ï¼›é€€åŒ–æ—¶ç»™é»˜è®¤æ–¹å‘
        let n_len = length(n_world);
        if (n_len < 1e-8) {
            n_world = vec3<f32>(0.0, 0.0, 1.0);
        } else {
            n_world = n_world / n_len;
        }

        // å¯è§†åŒ–æ—¶ç¼–ç åˆ°é¢œè‰² [0,1]
        let n_rgb = clamp(0.5 * (n_world + vec3<f32>(1.0, 1.0, 1.0)), vec3<f32>(0.0), vec3<f32>(1.0));
        color = vec4<f32>(n_rgb, opacity);
    } else if (uModel.rendermode == 2u) {
        // æ¨¡å¼2: æ·±åº¦å¯è§†åŒ–ï¼ˆä½¿ç”¨é€è§†é™¤æ³•åçš„ NDC æ·±åº¦ï¼Œ0..1ï¼‰
        let depth_ndc = 1.0 - clamp(pos2d.z / pos2d.w, 0.0, 1.0);
        color = vec4<f32>(depth_ndc, depth_ndc, depth_ndc, opacity);
    } else {
        // é»˜è®¤: æ­£å¸¸é¢œè‰²
        color = vec4<f32>(
            max(vec3<f32>(0.), evaluate_color(dir_local, idx, uModel.maxShDeg)),
            1
        );
    }

    let v = vec4<f32>(v1 / viewport, v2 / viewport);
    points_2d[store_idx] = Splat(
        pack2x16float(v.xy), pack2x16float(v.zw),
        pack2x16float(v_center.xy),
        v_center.z,
        pack2x16float(color.rg), pack2x16float(color.ba),
    );
    // filling the sorting buffers and the indirect sort dispatch buffer
    let znear = -camera.proj[3][2] / camera.proj[2][2];
    let zfar = -camera.proj[3][2] / (camera.proj[2][2] - (1.));
    // filling the sorting buffers and the indirect sort dispatch buffer
    sort_depths[store_idx] = bitcast<u32>(zfar - pos2d.z) ;//u32(f32(0xffffffu) - pos2d.z / zfar * f32(0xffffffu));
    sort_indices[store_idx] = store_idx;

    let keys_per_wg = 256u * 15u;         // Caution: if workgroup size (256) or keys per thread (15) changes the dispatch is wrong!!
    if (global_index % keys_per_wg) == 0u {
        atomicAdd(&sort_dispatch.dispatch_x, 1u);
    }
}`,ps=`// we cutoff at 1/255 alpha value 
const CUTOFF:f32 = 2.3539888583335364; // = sqrt(log(255))

struct VertexOutput {
    @builtin(position) position: vec4<f32>,
    @location(0) screen_pos: vec2<f32>,
    @location(1) color: vec4<f32>,
};

struct VertexInput {
    @location(0) v: vec4<f32>,
    @location(1) pos: vec4<f32>,
    @location(2) color: vec4<f32>,
};

struct Splat {
     // 4x f16 packed as u32
    v_0: u32, v_1: u32,
    // 2x f16 packed as u32 (NDC x,y)
    pos: u32,
    // NDC z (high precision)
    posz: f32,
    // rgba packed as f16
    color_0: u32,color_1: u32,
};

@group(0) @binding(2)
var<storage, read> points_2d : array<Splat>;
@group(1) @binding(4)
var<storage, read> indices : array<u32>;

@vertex
fn vs_main(
    @builtin(vertex_index) in_vertex_index: u32,
    @builtin(instance_index) in_instance_index: u32
) -> VertexOutput {
    var out: VertexOutput;

    let vertex = points_2d[indices[in_instance_index] + 0u];

    // scaled eigenvectors in screen space 
    let v1 = unpack2x16float(vertex.v_0);
    let v2 = unpack2x16float(vertex.v_1);

    let v_center_xy = unpack2x16float(vertex.pos);
    let v_center_z = vertex.posz;

    // splat rectangle with left lower corner at (-1,-1)
    // and upper right corner at (1,1)
    let x = f32(in_vertex_index % 2u == 0u) * 2. - (1.);
    let y = f32(in_vertex_index < 2u) * 2. - (1.);

    let position = vec2<f32>(x, y) * CUTOFF;

    let offset = 2. * mat2x2<f32>(v1, v2) * position;
    let z_ndc = clamp(v_center_z, 0.0, 1.0);
    out.position = vec4<f32>(v_center_xy + offset, z_ndc, 1.);
    out.screen_pos = position;
    out.color = vec4<f32>(unpack2x16float(vertex.color_0), unpack2x16float(vertex.color_1));
    return out;
}

@fragment
fn fs_main(in: VertexOutput) -> @location(0) vec4<f32> {
    let a = dot(in.screen_pos, in.screen_pos);
    if a > 2. * CUTOFF {
        discard;
    }
    let b = min(0.99, exp(-a) * in.color.a);
    return vec4<f32>(in.color.rgb, 1.) * b;
}`,pn=`// shader implementing gpu radix sort. More information in the beginning of gpu_rs.rs
// info: 

// also the workgroup sizes are added in these prepasses
// before the pipeline is started the following constant definitionis are prepended to this shadercode

// const histogram_sg_size
// const histogram_wg_size
// const rs_radix_log2
// const rs_radix_size
// const rs_keyval_size
// const rs_histogram_block_rows
// const rs_scatter_block_rows

struct GeneralInfo{
    keys_size: u32,
    padded_size: u32,
    passes: u32,
    even_pass: u32,
    odd_pass: u32,
};

@group(0) @binding(0)
var<storage, read_write> infos: GeneralInfo;
@group(0) @binding(1)
var<storage, read_write> histograms : array<atomic<u32>>;
@group(0) @binding(2)
var<storage, read_write> keys : array<u32>;
@group(0) @binding(3)
var<storage, read_write> keys_b : array<u32>;
@group(0) @binding(4)
var<storage, read_write> payload_a : array<u32>;
@group(0) @binding(5)
var<storage, read_write> payload_b : array<u32>;

// layout of the histograms buffer
//   +---------------------------------+ <-- 0
//   | histograms[keyval_size]         |
//   +---------------------------------+ <-- keyval_size                           * histo_size
//   | partitions[scatter_blocks_ru-1] |
//   +---------------------------------+ <-- (keyval_size + scatter_blocks_ru - 1) * histo_size
//   | workgroup_ids[keyval_size]      |
//   +---------------------------------+ <-- (keyval_size + scatter_blocks_ru - 1) * histo_size + workgroup_ids_size

// --------------------------------------------------------------------------------------------------------------
// Filling histograms and keys with default values (also resets the pass infos for odd and even scattering)
// --------------------------------------------------------------------------------------------------------------
@compute @workgroup_size({histogram_wg_size})
fn zero_histograms(@builtin(global_invocation_id) gid : vec3<u32>, @builtin(num_workgroups) nwg: vec3<u32>) {
    if gid.x == 0u {
        infos.even_pass = 0u;
        infos.odd_pass = 1u;    // has to be one, as on the first call to even pass + 1 % 2 is calculated
    }
    // here the histograms are set to zero and the partitions are set to 0xfffffffff to avoid sorting problems
    let scatter_wg_size = histogram_wg_size;
    let scatter_block_kvs = scatter_wg_size * rs_scatter_block_rows;
    let scatter_blocks_ru = (infos.keys_size + scatter_block_kvs - 1u) / scatter_block_kvs;
    
    let histo_size = rs_radix_size;
    var n = (rs_keyval_size + scatter_blocks_ru - 1u) * histo_size;
    let b = n;
    if infos.keys_size < infos.padded_size {
        n += infos.padded_size - infos.keys_size;
    }
    
    let line_size = nwg.x * {histogram_wg_size}u;
    for (var cur_index = gid.x; cur_index < n; cur_index += line_size){
        if cur_index >= n {
            return;
        }
            
        if cur_index  < rs_keyval_size * histo_size {
            atomicStore(&histograms[cur_index], 0u);
        }
        else if cur_index < b {
            atomicStore(&histograms[cur_index], 0u);
        }
        else {
            keys[infos.keys_size + cur_index - b] = 0xFFFFFFFFu;
        }
    }
}

// --------------------------------------------------------------------------------------------------------------
// Calculating the histograms
// --------------------------------------------------------------------------------------------------------------
var<workgroup> smem : array<atomic<u32>, rs_radix_size>;
var<private> kv : array<u32, rs_histogram_block_rows>;
fn zero_smem(lid: u32) {
    if lid < rs_radix_size {
        atomicStore(&smem[lid], 0u);
    }
}

fn histogram_pass(pass_: u32, lid: u32) {
    zero_smem(lid);
    workgroupBarrier();
    
    for (var j = 0u; j < rs_histogram_block_rows; j++) {
        let u_val = bitcast<u32>(kv[j]);
        let digit = extractBits(u_val, pass_ * rs_radix_log2, rs_radix_log2);
        atomicAdd(&smem[digit], 1u);
    }
    
    workgroupBarrier();
    let histogram_offset = rs_radix_size * pass_ + lid;
    if lid < rs_radix_size && atomicLoad(&smem[lid]) >= 0u {
        atomicAdd(&histograms[histogram_offset], atomicLoad(&smem[lid]));
    }
}

// the workgrpu_size can be gotten on the cpu by by calling pipeline.get_bind_group_layout(0).unwrap().get_local_workgroup_size();
fn fill_kv(wid: u32, lid: u32) {
    let rs_block_keyvals : u32 = rs_histogram_block_rows * histogram_wg_size;
    let kv_in_offset = wid * rs_block_keyvals + lid;
    for (var i = 0u; i < rs_histogram_block_rows; i++) {
        let pos = kv_in_offset + i * histogram_wg_size;
        kv[i] = keys[pos];
    }
}
fn fill_kv_keys_b(wid: u32, lid: u32) {
    let rs_block_keyvals : u32 = rs_histogram_block_rows * histogram_wg_size;
    let kv_in_offset = wid * rs_block_keyvals + lid;
    for (var i = 0u; i < rs_histogram_block_rows; i++) {
        let pos = kv_in_offset + i * histogram_wg_size;
        kv[i] = keys_b[pos];
    }
}
@compute @workgroup_size({histogram_wg_size})
fn calculate_histogram(@builtin(workgroup_id) wid : vec3<u32>, @builtin(local_invocation_id) lid : vec3<u32>) {
    // efficient loading of multiple values
    fill_kv(wid.x, lid.x);
    
    // Accumulate and store histograms for passes
    histogram_pass(3u, lid.x);
    histogram_pass(2u, lid.x);
    // if infos.passes > 2u {
        histogram_pass(1u, lid.x);
    // }
    // if infos.passes > 3u {
        histogram_pass(0u, lid.x);
    // }
}

// --------------------------------------------------------------------------------------------------------------
// Prefix sum over histogram
// --------------------------------------------------------------------------------------------------------------
fn prefix_reduce_smem(lid: u32) {
    var offset = 1u;
    for (var d = rs_radix_size >> 1u; d > 0u; d = d >> 1u) { // sum in place tree
        workgroupBarrier();
        if lid < d {
            let ai = offset * (2u * lid + 1u) - 1u;
            let bi = offset * (2u * lid + 2u) - 1u;
            // smem[bi] += smem[ai];
            atomicAdd(&smem[bi], atomicLoad(&smem[ai]));
        }
        offset = offset << 1u;
    }
    
    if lid == 0u { 
        // smem[rs_radix_size - 1u] = 0u;
        atomicStore(&smem[rs_radix_size - 1u], 0u);
    } // clear the last element
        
    for (var d = 1u; d < rs_radix_size; d = d << 1u) {
        offset = offset >> 1u;
        workgroupBarrier();
        if lid < d {
            let ai = offset * (2u * lid + 1u) - 1u;
            let bi = offset * (2u * lid + 2u) - 1u;
            
            // let t = smem[ai];
            let t     = atomicLoad(&smem[ai]);
            // smem[ai]  = smem[bi];
            atomicStore(&smem[ai], atomicLoad(&smem[bi]));
            // smem[bi] += t;
            atomicAdd(&smem[bi], t);
        }
    }
}
@compute @workgroup_size({prefix_wg_size})
fn prefix_histogram(@builtin(workgroup_id) wid: vec3<u32>, @builtin(local_invocation_id) lid : vec3<u32>) {
    // the work group  id is the pass, and is inverted in the next line, such that pass 3 is at the first position in the histogram buffer
    let histogram_base = (rs_keyval_size - 1u - wid.x) * rs_radix_size;
    let histogram_offset = histogram_base + lid.x;
    
    // the following coode now corresponds to the prefix calc code in fuchsia/../shaders/prefix.h
    // however the implementation is taken from https://www.eecs.umich.edu/courses/eecs570/hw/parprefix.pdf listing 2 (better overview, nw subgroup arithmetic)
    // this also means that only half the amount of workgroups is spawned (one workgroup calculates for 2 positioons)
    // the smemory is used from the previous section
    // smem[lid.x] = histograms[histogram_offset];
    atomicStore(&smem[lid.x], atomicLoad(&histograms[histogram_offset]));
    // smem[lid.x + {prefix_wg_size}u] = histograms[histogram_offset + {prefix_wg_size}u];
    atomicStore(&smem[lid.x + {prefix_wg_size}u], atomicLoad(&histograms[histogram_offset + {prefix_wg_size}u]));

    prefix_reduce_smem(lid.x);
    workgroupBarrier();
    
    // histograms[histogram_offset] = smem[lid.x];
    atomicStore(&histograms[histogram_offset], atomicLoad(&smem[lid.x]));
    // histograms[histogram_offset + {prefix_wg_size}u] = smem[lid.x + {prefix_wg_size}u];
    atomicStore(&histograms[histogram_offset + {prefix_wg_size}u], atomicLoad(&smem[lid.x + {prefix_wg_size}u]));
}

// --------------------------------------------------------------------------------------------------------------
// Scattering the keys
// --------------------------------------------------------------------------------------------------------------
// General note: Only 2 sweeps needed here
var<workgroup> scatter_smem: array<u32, rs_mem_dwords>; // note: rs_mem_dwords is caclulated in the beginngin of gpu_rs.rs
//            | Dwords                                    | Bytes
//  ----------+-------------------------------------------+--------
//  Lookback  | 256                                       | 1 KB
//  Histogram | 256                                       | 1 KB
//  Prefix    | 4-84                                      | 16-336
//  Reorder   | RS_WORKGROUP_SIZE * RS_SCATTER_BLOCK_ROWS | 2-8 KB
fn partitions_base_offset() -> u32 { return rs_keyval_size * rs_radix_size;}
fn smem_prefix_offset() -> u32 { return rs_radix_size + rs_radix_size;}
fn rs_prefix_sweep_0(idx: u32) -> u32 { return scatter_smem[smem_prefix_offset() + rs_mem_sweep_0_offset + idx];}
fn rs_prefix_sweep_1(idx: u32) -> u32 { return scatter_smem[smem_prefix_offset() + rs_mem_sweep_1_offset + idx];}
fn rs_prefix_sweep_2(idx: u32) -> u32 { return scatter_smem[smem_prefix_offset() + rs_mem_sweep_2_offset + idx];}
fn rs_prefix_load(lid: u32, idx: u32) -> u32 { return scatter_smem[rs_radix_size + lid + idx];}
fn rs_prefix_store(lid: u32, idx: u32, val: u32) { scatter_smem[rs_radix_size + lid + idx] = val;}
fn is_first_local_invocation(lid: u32) -> bool { return lid == 0u;}
fn histogram_load(digit: u32) -> u32 {
    //  return smem[digit];
    return atomicLoad(&smem[digit]);
}// scatter_smem[rs_radix_size + digit];}

fn histogram_store(digit: u32, count: u32) { 
    // smem[digit] = count;
    atomicStore(&smem[digit], count);
} // scatter_smem[rs_radix_size + digit] = count; }
const rs_partition_mask_status : u32 = 0xC0000000u;
const rs_partition_mask_count : u32 = 0x3FFFFFFFu;
var<private> kr : array<u32, rs_scatter_block_rows>;
var<private> pv : array<u32, rs_scatter_block_rows>;

fn fill_kv_even(wid: u32, lid: u32) {
    let subgroup_id = lid / histogram_sg_size;
    let subgroup_invoc_id = lid - subgroup_id * histogram_sg_size;
    let subgroup_keyvals = rs_scatter_block_rows * histogram_sg_size;
    let rs_block_keyvals : u32 = rs_histogram_block_rows * histogram_wg_size;
    let kv_in_offset = wid * rs_block_keyvals + subgroup_id * subgroup_keyvals + subgroup_invoc_id;
    for (var i = 0u; i < rs_histogram_block_rows; i++) {
        let pos = kv_in_offset + i * histogram_sg_size;
        kv[i] = keys[pos];
    }
    for (var i = 0u; i < rs_histogram_block_rows; i++) {
        let pos = kv_in_offset + i * histogram_sg_size;
        pv[i] = payload_a[pos];
    }
}
fn fill_kv_odd(wid: u32, lid: u32) {
    let subgroup_id = lid / histogram_sg_size;
    let subgroup_invoc_id = lid - subgroup_id * histogram_sg_size;
    let subgroup_keyvals = rs_scatter_block_rows * histogram_sg_size;
    let rs_block_keyvals : u32 = rs_histogram_block_rows * histogram_wg_size;
    let kv_in_offset = wid * rs_block_keyvals + subgroup_id * subgroup_keyvals + subgroup_invoc_id;
    for (var i = 0u; i < rs_histogram_block_rows; i++) {
        let pos = kv_in_offset + i * histogram_sg_size;
        kv[i] = keys_b[pos];
    }
    for (var i = 0u; i < rs_histogram_block_rows; i++) {
        let pos = kv_in_offset + i * histogram_sg_size;
        pv[i] = payload_b[pos];
    }
}
fn scatter(pass_: u32, lid: vec3<u32>, gid: vec3<u32>, wid: vec3<u32>, nwg: vec3<u32>, partition_status_invalid: u32, partition_status_reduction: u32, partition_status_prefix: u32) {
    let partition_mask_invalid = partition_status_invalid << 30u;
    let partition_mask_reduction = partition_status_reduction << 30u;
    let partition_mask_prefix = partition_status_prefix << 30u;
    // kv_filling is done in the scatter_even and scatter_odd functions to account for front and backbuffer switch
    // in the reference there is a nulling of the smmem here, was moved to line 251 as smem is used in the code until then

    // The following implements conceptually the same as the
    // Emulate a "match" operation with broadcasts for small subgroup sizes (line 665 ff in scatter.glsl)
    // The difference however is, that instead of using subrgoupBroadcast each thread stores
    // its current number in the smem at lid.x, and then looks up their neighbouring values of the subgroup
    let subgroup_id = lid.x / histogram_sg_size;
    let subgroup_offset = subgroup_id * histogram_sg_size;
    let subgroup_tid = lid.x - subgroup_offset;
    let subgroup_count = {scatter_wg_size}u / histogram_sg_size;
    for (var i = 0u; i < rs_scatter_block_rows; i++) {
        let u_val = bitcast<u32>(kv[i]);
        let digit = extractBits(u_val, pass_ * rs_radix_log2, rs_radix_log2);
        // smem[lid.x] = digit;
        atomicStore(&smem[lid.x], digit);
        var count = 0u;
        var rank = 0u;
        
        for (var j = 0u; j < histogram_sg_size; j++) {
            // if smem[subgroup_offset + j] == digit {
            if atomicLoad(&smem[subgroup_offset + j]) == digit {
                count += 1u;
                if j <= subgroup_tid {
                    rank += 1u;
                }
            }
        }
        
        kr[i] = (count << 16u) | rank;
    }
    
    zero_smem(lid.x);   // now zeroing the smmem as we are now accumulating the histogram there
    workgroupBarrier();

    // The final histogram is stored in the smem buffer
    for (var i = 0u; i < subgroup_count; i++) {
        if subgroup_id == i {
            for (var j = 0u; j < rs_scatter_block_rows; j++) {
                let v = bitcast<u32>(kv[j]);
                let digit = extractBits(v, pass_ * rs_radix_log2, rs_radix_log2);
                let prev = histogram_load(digit);
                let rank = kr[j] & 0xFFFFu;
                let count = kr[j] >> 16u;
                kr[j] = prev + rank;

                if rank == count {
                    histogram_store(digit, (prev + count));
                }
                
                // TODO: check if the barrier here is needed
            }            
        }
        workgroupBarrier();
    }
    // kr filling is now done and contains the total offset for each value to be able to 
    // move the values into order without having any collisions
    
    // we do not check for single work groups (is currently not assumed to occur very often)
    let partition_offset = lid.x + partitions_base_offset();    // is correct, the partitions pointer does not change
    let partition_base = wid.x * rs_radix_size;
    if wid.x == 0u {
        // special treating for the first workgroup as the data might be read back by later workgroups
        // corresponds to rs_first_prefix_store
        let hist_offset = pass_ * rs_radix_size + lid.x;
        if lid.x < rs_radix_size {
            // let exc = histograms[hist_offset];
            let exc = atomicLoad(&histograms[hist_offset]);
            let red = histogram_load(lid.x);// scatter_smem[rs_keyval_size + lid.x];
            
            scatter_smem[lid.x] = exc;
            
            let inc = exc + red;

            atomicStore(&histograms[partition_offset], inc | partition_mask_prefix);
        }
    }
    else {
        // standard case for the "inbetween" workgroups
        
        // rs_reduction_store, only for inbetween workgroups
        if lid.x < rs_radix_size && wid.x < nwg.x - 1u {
            let red = histogram_load(lid.x);
            atomicStore(&histograms[partition_offset + partition_base], red | partition_mask_reduction);
        }
        
        // rs_loopback_store
        if lid.x < rs_radix_size {
            var partition_base_prev = partition_base - rs_radix_size;
            var exc                 = 0u;

            // Note: Each workgroup invocation can proceed independently.
            // Subgroups and workgroups do NOT have to coordinate.
            while true {
                //let prev = atomicLoad(&histograms[partition_offset]);// histograms[partition_offset + partition_base_prev];
                let prev = atomicLoad(&histograms[partition_base_prev + partition_offset]);// histograms[partition_offset + partition_base_prev];
                if (prev & rs_partition_mask_status) == partition_mask_invalid {
                    continue;
                }
                exc += prev & rs_partition_mask_count;
                if (prev & rs_partition_mask_status) != partition_mask_prefix {
                    // continue accumulating reduction
                    partition_base_prev -= rs_radix_size;
                    continue;
                }

                // otherwise save the exclusive scan and atomically transform the
                // reduction into an inclusive prefix status math: reduction + 1 = prefix
                scatter_smem[lid.x] = exc;

                if wid.x < nwg.x - 1u { // only store when inbetween, skip for last workgrup
                    atomicAdd(&histograms[partition_offset + partition_base], exc | (1u << 30u));
                }
                break;
            }
        }
    }
    // speial case for last workgroup is also done in the "inbetween" case
    
    // compute exclusive prefix scan of histogram
    // corresponds to rs_prefix
    // TODO make shure that the data is put into smem
    prefix_reduce_smem(lid.x);
    workgroupBarrier();

    // convert keyval rank to local index, corresponds to rs_rank_to_local
    for (var i = 0u; i < rs_scatter_block_rows; i++) {
        let v = bitcast<u32>(kv[i]);
        let digit = extractBits(v, pass_ * rs_radix_log2, rs_radix_log2);
        let exc   = histogram_load(digit);
        let idx   = exc + kr[i];
        
        kr[i] |= (idx << 16u);
    }
    workgroupBarrier();
    
    // reorder kv[] and kr[], corresponds to rs_reorder
    let smem_reorder_offset = rs_radix_size;
    let smem_base = smem_reorder_offset + lid.x;  // as we are in smem, the radix_size offset is not needed
  
        // keyvalues ----------------------------------------------
        // store keyval to sorted location
        for (var j = 0u; j < rs_scatter_block_rows; j++) {
            let smem_idx = smem_reorder_offset + (kr[j] >> 16u) - 1u;
            
            scatter_smem[smem_idx] = bitcast<u32>(kv[j]);
        }
        workgroupBarrier();

        // Load keyval dword from sorted location
        for (var j = 0u; j < rs_scatter_block_rows; j++) {
            kv[j] = scatter_smem[smem_base + j * {scatter_wg_size}u];
        }
        workgroupBarrier();
        // payload ----------------------------------------------
        // store payload to sorted location
        for (var j = 0u; j < rs_scatter_block_rows; j++) {
            let smem_idx = smem_reorder_offset + (kr[j] >> 16u) - 1u;
            
            scatter_smem[smem_idx] = pv[j];
        }
        workgroupBarrier();

        // Load payload dword from sorted location
        for (var j = 0u; j < rs_scatter_block_rows; j++) {
            pv[j] = scatter_smem[smem_base + j * {scatter_wg_size}u];
        }
        workgroupBarrier();
    //}
    
    // store the digit-index to sorted location
    for (var i = 0u; i < rs_scatter_block_rows; i++) {
        let smem_idx = smem_reorder_offset + (kr[i] >> 16u) - 1u;
        scatter_smem[smem_idx] = kr[i];
    }
    workgroupBarrier();

    // Load kr[] from sorted location -- we only need the rank
    for (var i = 0u; i < rs_scatter_block_rows; i++) {
        kr[i] = scatter_smem[smem_base + i * {scatter_wg_size}u] & 0xFFFFu;
    }
    
    // convert local index to a global index, corresponds to rs_local_to_global
    for (var i = 0u; i < rs_scatter_block_rows; i++) {
        let v = bitcast<u32>(kv[i]);
        let digit = extractBits(v, pass_ * rs_radix_log2, rs_radix_log2);
        let exc   = scatter_smem[digit];

        kr[i] += exc - 1u;
    }
    
    // the storing is done in the scatter_even and scatter_odd functions as the front and back buffer changes
}
@compute @workgroup_size({scatter_wg_size})
fn scatter_even(@builtin(workgroup_id) wid: vec3<u32>, @builtin(local_invocation_id) lid: vec3<u32>, @builtin(global_invocation_id) gid: vec3<u32>, @builtin(num_workgroups) nwg: vec3<u32>) {
    if gid.x == 0u {
        infos.odd_pass = (infos.odd_pass + 1u) % 2u; // for this to work correctly the odd_pass has to start 1
    }
    let cur_pass = infos.even_pass * 2u;
    
    // load from keys, store to keys_b
    fill_kv_even(wid.x, lid.x);
    
    let partition_status_invalid = 0u;
    let partition_status_reduction = 1u;
    let partition_status_prefix = 2u;
    scatter(cur_pass, lid, gid, wid, nwg, partition_status_invalid, partition_status_reduction, partition_status_prefix);

    // store keyvals to their new locations, corresponds to rs_store
    for (var i = 0u; i < rs_scatter_block_rows; i++) {
        keys_b[kr[i]] = kv[i];
    }
    for (var i = 0u; i < rs_scatter_block_rows; i++) {
        payload_b[kr[i]] = pv[i];
    }
}
@compute @workgroup_size({scatter_wg_size})
fn scatter_odd(@builtin(workgroup_id) wid: vec3<u32>, @builtin(local_invocation_id) lid: vec3<u32>, @builtin(global_invocation_id) gid: vec3<u32>, @builtin(num_workgroups) nwg: vec3<u32>) {
    if gid.x == 0u {
        infos.even_pass = (infos.even_pass + 1u) % 2u; // for this to work correctly the even_pass has to start at 0
    }
    let cur_pass = infos.odd_pass * 2u + 1u;

    // load from keys_b, store to keys
    fill_kv_odd(wid.x, lid.x);

    let partition_status_invalid = 2u;
    let partition_status_reduction = 3u;
    let partition_status_prefix = 0u;
    scatter(cur_pass, lid, gid, wid, nwg, partition_status_invalid, partition_status_reduction, partition_status_prefix);

    // store keyvals to their new locations, corresponds to rs_store
    for (var i = 0u; i < rs_scatter_block_rows; i++) {
        keys[kr[i]] = kv[i];
    }
    for (var i = 0u; i < rs_scatter_block_rows; i++) {
        payload_a[kr[i]] = pv[i];
    }

    // the indirect buffer is reset after scattering via write buffer, see record_scatter_indirect for details
}
`,Je=256,At=8,mt=1<<At,gs=32/At,tt=15,Et=tt,gn=128,ys=256;function yn(a){const e=a.slice();for(let t=e.length-1;t>0;t--){const s=Math.floor(Math.random()*(t+1));[e[t],e[s]]=[e[s],e[t]]}return e}class je{bindGroupLayout;renderBindGroupLayout;preprocessBindGroupLayout;zero_p;histogram_p;prefix_p;scatter_even_p;scatter_odd_p;subgroupSize;constructor(){}static async create(e,t){console.debug("Searching for the maximum subgroup size...");const s=[16,32,16,8,1];for(const n of s){console.debug(`Testing sorting with subgroup size ${n}`);try{const o=new je;if(await o.initializeWithSubgroupSize(e,n),await o.testSort(e,t))return console.log(`Subgroup size ${n} works.`),o}catch(o){console.warn(`Subgroup size ${n} failed during pipeline creation or test run.`,o)}}throw new Error("GPURSSorter::create() No working subgroup size was found. Unable to use sorter.")}async initializeWithSubgroupSize(e,t){this.subgroupSize=t,this.bindGroupLayout=this.createBindGroupLayout(e),this.renderBindGroupLayout=je.createRenderBindGroupLayout(e),this.preprocessBindGroupLayout=je.createPreprocessBindGroupLayout(e);const s=e.createPipelineLayout({label:"radix sort pipeline layout",bindGroupLayouts:[this.bindGroupLayout]}),n=this.processShaderTemplate(pn),o=e.createShaderModule({label:"Radix sort shader",code:n});this.zero_p=await e.createComputePipelineAsync({label:"Zero the histograms",layout:s,compute:{module:o,entryPoint:"zero_histograms"}}),this.histogram_p=await e.createComputePipelineAsync({label:"calculate_histogram",layout:s,compute:{module:o,entryPoint:"calculate_histogram"}}),this.prefix_p=await e.createComputePipelineAsync({label:"prefix_histogram",layout:s,compute:{module:o,entryPoint:"prefix_histogram"}}),this.scatter_even_p=await e.createComputePipelineAsync({label:"scatter_even",layout:s,compute:{module:o,entryPoint:"scatter_even"}}),this.scatter_odd_p=await e.createComputePipelineAsync({label:"scatter_odd",layout:s,compute:{module:o,entryPoint:"scatter_odd"}})}processShaderTemplate(e){const t=Math.max(1,this.subgroupSize|0),s=Math.floor(mt/t),n=Math.floor(s/t),i=mt+Et*ys,r=0,l=r+s,u=l+n,d=`const histogram_sg_size: u32 = ${t}u;
            const histogram_wg_size: u32 = ${Je}u;
            const rs_radix_log2: u32 = ${At}u;
            const rs_radix_size: u32 = ${mt}u;
            const rs_keyval_size: u32 = ${gs}u;
            const rs_histogram_block_rows: u32 = ${tt}u;
            const rs_scatter_block_rows: u32 = ${Et}u;
            const rs_mem_dwords: u32 = ${i}u;
            const rs_mem_sweep_0_offset: u32 = ${r}u;
            const rs_mem_sweep_1_offset: u32 = ${l}u;
            const rs_mem_sweep_2_offset: u32 = ${u}u;
            `;let f=e.replace(/{histogram_wg_size}/g,Je.toString()).replace(/{prefix_wg_size}/g,gn.toString()).replace(/{scatter_wg_size}/g,ys.toString());return d+f}async testSort(e,t){const n=new Float32Array(yn(Array.from({length:8192},(u,d)=>8191-d))),o=new Float32Array(Array.from({length:8192},(u,d)=>d)),i=this.createSortStuff(e,8192);t.writeBuffer(i.key_a,0,n.buffer);const r=e.createCommandEncoder({label:"GPURSSorter test_sort"});this.recordSort(i,8192,r),t.submit([r.finish()]),await e.queue.onSubmittedWorkDone();const l=await this.downloadBuffer(e,t,i.key_a,"f32");for(let u=0;u<8192;u++)if(l[u]!==o[u])return console.error(`Sort failed at index ${u}. Expected ${o[u]}, got ${l[u]}`),!1;return!0}createSortStuff(e,t){const{key_a:s,key_b:n,payload_a:o,payload_b:i}=this.createKeyvalBuffers(e,t,4),r=this.createInternalMemBuffer(e,t),{sorter_uni:l,sorter_dis:u,sorter_bg:d}=this.createBindGroup(e,t,r,s,n,o,i),f=this.createRenderBindGroup(e,l,o),h=this.createPreprocessBindGroup(e,l,u,s,o);return{numPoints:t,num_points:t,sortedIndices:o,indirectBuffer:u,sorter_uni:l,sorter_dis:u,sorter_bg:d,sorter_render_bg:f,sorter_bg_pre:h,internal_mem:r,key_a:s,key_b:n,payload_a:o,payload_b:i}}recordSort(e,t,s){const n=e,o=4;this.recordCalculateHistogram(n.sorter_bg,t,s),this.recordPrefixHistogram(n.sorter_bg,o,s),this.recordScatterKeys(n.sorter_bg,o,t,s)}recordSortIndirect_one(e,t,s){const n=e,o=4,i=s.beginComputePass({label:"Radix Sort :: Indirect Histogram Pass"});i.setBindGroup(0,n.sorter_bg),i.setPipeline(this.zero_p),i.dispatchWorkgroupsIndirect(t,0),i.setPipeline(this.histogram_p),i.dispatchWorkgroupsIndirect(t,0),i.end(),this.recordPrefixHistogram(n.sorter_bg,o,s);const r=s.beginComputePass({label:"Radix Sort :: Indirect Scatter Pass"});r.setBindGroup(0,n.sorter_bg),r.setPipeline(this.scatter_even_p),r.dispatchWorkgroupsIndirect(t,0),r.setPipeline(this.scatter_odd_p),r.dispatchWorkgroupsIndirect(t,0),r.setPipeline(this.scatter_even_p),r.dispatchWorkgroupsIndirect(t,0),r.setPipeline(this.scatter_odd_p),r.dispatchWorkgroupsIndirect(t,0),r.end()}recordSortIndirect(e,t,s){const n=e,o=4;{const r=s.beginComputePass({label:"RS::Zero (Indirect)"});r.setBindGroup(0,n.sorter_bg),r.setPipeline(this.zero_p),r.dispatchWorkgroupsIndirect(t,0),r.end()}{const r=s.beginComputePass({label:"RS::Histogram (Indirect)"});r.setBindGroup(0,n.sorter_bg),r.setPipeline(this.histogram_p),r.dispatchWorkgroupsIndirect(t,0),r.end()}this.recordPrefixHistogram(n.sorter_bg,o,s);const i=(r,l)=>{const u=s.beginComputePass({label:l});u.setBindGroup(0,n.sorter_bg),u.setPipeline(r),u.dispatchWorkgroupsIndirect(t,0),u.end()};i(this.scatter_even_p,"RS::Scatter0_even (Indirect)"),i(this.scatter_odd_p,"RS::Scatter1_odd (Indirect)"),i(this.scatter_even_p,"RS::Scatter2_even (Indirect)"),i(this.scatter_odd_p,"RS::Scatter3_odd (Indirect)")}static createRenderBindGroupLayout(e){return e.createBindGroupLayout({label:"Radix Sort Render Bind Group Layout",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE|GPUShaderStage.VERTEX,buffer:{type:"read-only-storage"}},{binding:4,visibility:GPUShaderStage.COMPUTE|GPUShaderStage.VERTEX,buffer:{type:"read-only-storage"}}]})}static createPreprocessBindGroupLayout(e){return e.createBindGroupLayout({label:"Radix Sort Preprocess Bind Group Layout",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:3,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]})}recordResetIndirectBuffer(e,t,s){const n=new Uint32Array([0]);s.writeBuffer(e,0,n),s.writeBuffer(t,0,n)}createBindGroupLayout(e){return e.createBindGroupLayout({label:"Radix Sort Bind Group Layout",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:3,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:4,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:5,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]})}getScatterHistogramSizes(e){const t=Je*Et,s=Math.ceil(e/t),n=s*t,o=Je*tt,r=Math.ceil(n/o)*o;return{scatter_blocks_ru:s,count_ru_histo:r}}createKeyvalBuffers(e,t,s){const n=Je*tt,i=(Math.floor((t+n)/n)+1)*n*Float32Array.BYTES_PER_ELEMENT,r=e.createBuffer({label:"Radix data buffer a",size:i,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC}),l=e.createBuffer({label:"Radix data buffer b",size:i,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC});s!==4&&console.warn("Currently only 4-byte payloads are fully supported, matching the original Rust implementation.");const u=Math.max(1,t*s),d=e.createBuffer({label:"Radix payload buffer a",size:u,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC}),f=e.createBuffer({label:"Radix payload buffer b",size:u,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC});return{key_a:r,key_b:l,payload_a:d,payload_b:f}}createInternalMemBuffer(e,t){const{scatter_blocks_ru:s}=this.getScatterHistogramSizes(t),n=mt*Uint32Array.BYTES_PER_ELEMENT,o=(gs+s-1+1)*n;return e.createBuffer({label:"Internal radix sort buffer",size:o,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC})}createBindGroup(e,t,s,n,o,i,r){const{scatter_blocks_ru:l,count_ru_histo:u}=this.getScatterHistogramSizes(t),d={keys_size:t,padded_size:u,passes:4,even_pass:0,odd_pass:0},f=e.createBuffer({label:"Radix uniform buffer",size:5*Uint32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC,mappedAtCreation:!0});new Uint32Array(f.getMappedRange()).set([d.keys_size,d.padded_size,d.passes,d.even_pass,d.odd_pass]),f.unmap();const h={dispatch_x:l,dispatch_y:1,dispatch_z:1},m=e.createBuffer({label:"Dispatch indirect buffer",size:3*Uint32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.INDIRECT,mappedAtCreation:!0});new Uint32Array(m.getMappedRange()).set([h.dispatch_x,h.dispatch_y,h.dispatch_z]),m.unmap();const p=e.createBindGroup({label:"Radix bind group",layout:this.bindGroupLayout,entries:[{binding:0,resource:{buffer:f}},{binding:1,resource:{buffer:s}},{binding:2,resource:{buffer:n}},{binding:3,resource:{buffer:o}},{binding:4,resource:{buffer:i}},{binding:5,resource:{buffer:r}}]});return{sorter_uni:f,sorter_dis:m,sorter_bg:p}}createRenderBindGroup(e,t,s){return e.createBindGroup({label:"Render bind group",layout:this.renderBindGroupLayout,entries:[{binding:0,resource:{buffer:t}},{binding:4,resource:{buffer:s}}]})}createPreprocessBindGroup(e,t,s,n,o){return e.createBindGroup({label:"Preprocess bind group",layout:this.preprocessBindGroupLayout,entries:[{binding:0,resource:{buffer:t}},{binding:1,resource:{buffer:n}},{binding:2,resource:{buffer:o}},{binding:3,resource:{buffer:s}}]})}recordCalculateHistogram(e,t,s){const{count_ru_histo:n}=this.getScatterHistogramSizes(t),o=Je*tt,i=Math.ceil(n/o);{const r=s.beginComputePass({label:"RS::Zero"});r.setBindGroup(0,e),r.setPipeline(this.zero_p),r.dispatchWorkgroups(i,1,1),r.end()}{const r=s.beginComputePass({label:"RS::Histogram"});r.setBindGroup(0,e),r.setPipeline(this.histogram_p),r.dispatchWorkgroups(i,1,1),r.end()}}recordPrefixHistogram(e,t,s){const n=s.beginComputePass({label:"Radix Sort :: Prefix Sum Pass"});n.setPipeline(this.prefix_p),n.setBindGroup(0,e),n.dispatchWorkgroups(t,1,1),n.end()}recordScatterKeys(e,t,s,n){if(t!==4)throw new Error("Only 4 passes are supported for 32-bit keys.");const{scatter_blocks_ru:o}=this.getScatterHistogramSizes(s),i=(r,l)=>{const u=n.beginComputePass({label:l});u.setBindGroup(0,e),u.setPipeline(r),u.dispatchWorkgroups(o,1,1),u.end()};i(this.scatter_even_p,"RS::Scatter0_even"),i(this.scatter_odd_p,"RS::Scatter1_odd"),i(this.scatter_even_p,"RS::Scatter2_even"),i(this.scatter_odd_p,"RS::Scatter3_odd")}async downloadBuffer(e,t,s,n){const o=e.createBuffer({label:"Download buffer",size:s.size,usage:GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST}),i=e.createCommandEncoder({label:"Copy encoder"});i.copyBufferToBuffer(s,0,o,0,s.size),t.submit([i.finish()]),await o.mapAsync(GPUMapMode.READ);const r=o.getMappedRange();let l;return n==="f32"?l=new Float32Array(r.slice(0)):l=new Uint32Array(r.slice(0)),o.unmap(),o.destroy(),l}}async function _n(a,e,t=0,s=4){const n=a.createBuffer({size:s,usage:GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST,label:"debug-staging-buffer"}),o=a.createCommandEncoder();o.copyBufferToBuffer(e,t,n,0,s),a.queue.submit([o.finish()]),await a.queue.onSubmittedWorkDone(),await n.mapAsync(GPUMapMode.READ);const i=n.getMappedRange(0,s),r=new ArrayBuffer(s);return new Uint8Array(r).set(new Uint8Array(i)),n.unmap(),n.destroy(),r}async function _s(a,e,t=0){const s=await _n(a,e,t,4);return new Uint32Array(s)[0]}async function ws(a,e){return await _s(a,e,0)}async function bs(a,e){const t=await _s(a,e,68);return console.log(`ğŸ” DEBUG: ModelParams.num_points (offset 68) = ${t}`),t}async function wn(a,e,t,s){if(console.log("ğŸ” === GPU COUNT DEBUG TRACE ==="),console.log(`ğŸ“Š Max points allocated: ${s}`),e){const n=await ws(a,e);console.log(`ğŸ“Š ONNX inference count: ${n}`);const o=await bs(a,t);console.log(`ğŸ“Š ModelParams count: ${o}`),n===o?console.log("âœ… Count successfully propagated from ONNX to shader uniforms"):(console.log(`âŒ Count mismatch! ONNX=${n}, ModelParams=${o}`),console.log("âš ï¸ The buffer copy may have failed or timing is wrong")),o===s&&console.log("âš ï¸ WARNING: Using maxPoints instead of dynamic count!")}else{console.log("â„¹ï¸ No ONNX count buffer (static model)");const n=await bs(a,t);console.log(`ğŸ“Š ModelParams count: ${n}`)}console.log("ğŸ” === END DEBUG TRACE ===")}class vs{pipeline;pipelineLayout;cameraUniforms;settingsUniforms;shDegree=3;device;m_useRawColor=!1;scratchCameraBuffer=new ArrayBuffer(272);scratchCameraView=new Float32Array(this.scratchCameraBuffer);scratchSettingsBuffer=new ArrayBuffer(80);scratchSettingsView=new DataView(this.scratchSettingsBuffer);async initialize(e,t,s=!1){this.device=e,this.shDegree=t,this.cameraUniforms=new Le(e,new ArrayBuffer(272),"Camera Uniforms"),this.settingsUniforms=new Le(e,new ArrayBuffer(80),"Settings Uniforms"),this.pipelineLayout=e.createPipelineLayout({label:"preprocess pipeline layout",bindGroupLayouts:[Le.bindGroupLayout(e),this.getPointCloudBindGroupLayout(e),this.getSortBindGroupLayout(e),this.getSettingsAndModelParamsBGL(e)]});const n=mn.replace("<injected>",t.toString()),o=e.createShaderModule({label:"preprocess.wgsl",code:n});this.pipeline=e.createComputePipeline({label:"preprocess pipeline",layout:this.pipelineLayout,compute:{module:o,entryPoint:"preprocess",constants:{USE_RAW_COLOR:s?1:0}}}),this.m_useRawColor=s,console.log(`ğŸ“ Preprocessor initialized with SH degree ${t}, raw color: ${s}`)}dispatchModel(e,t){if(this.packCameraUniforms(e.camera,e.viewport),this.packSettingsUniforms(e.pointCloud,e.settings),e.pointCloud.updateModelParamsWithOffset(e.modelMatrix,e.baseOffset),this.cameraUniforms.flush(this.device),this.settingsUniforms.flush(this.device),"setPrecisionForShader"in e.pointCloud&&typeof e.pointCloud.setPrecisionForShader=="function")try{e.pointCloud.setPrecisionForShader()}catch{}e.countBuffer?(e.pointCloud.modelParamsUniforms.flush(this.device),t.copyBufferToBuffer(e.countBuffer,0,e.pointCloud.modelParamsUniforms.buffer,68,4)):e.pointCloud.modelParamsUniforms.flush(this.device);const s=t.beginComputePass({label:"preprocess compute pass (global/M1)"});s.setPipeline(this.pipeline),s.setBindGroup(0,this.cameraUniforms.bindGroup);const n=this.pipeline.getBindGroupLayout(1),o=e.pointCloud.getSplatBuffer(),i=this.device.createBindGroup({label:"preprocess/pc-global-bg",layout:n,entries:[{binding:0,resource:{buffer:o.gaussianBuffer}},{binding:1,resource:{buffer:o.shBuffer}},{binding:2,resource:{buffer:e.global.splat2D}},{binding:3,resource:{buffer:e.pointCloud.uniforms.buffer}}]});s.setBindGroup(1,i),s.setBindGroup(2,this.getSortBindGroup(e.sortStuff));const r=this.pipeline.getBindGroupLayout(3),l=this.device.createBindGroup({layout:r,entries:[{binding:0,resource:{buffer:this.settingsUniforms.buffer}},{binding:1,resource:{buffer:e.pointCloud.modelParamsUniforms.buffer}}]});s.setBindGroup(3,l);const d=Math.ceil(e.pointCloud.numPoints/256);s.dispatchWorkgroups(d,1,1),s.end()}getBindGroupLayout(e){return this.pipeline.getBindGroupLayout(0)}packCameraUniforms(e,t){const s=this.scratchCameraView,n=e.viewMatrix();s.set(n,0);const o=this.invertMatrix4(n);s.set(o,16);const i=e.projMatrix(),r=this.multiplyMatrix4(rn,i);s.set(r,32);const l=this.invertMatrix4(i);s.set(l,48),s[64]=t[0],s[65]=t[1];const u=e.projection.focal(t);s[66]=u[0],s[67]=u[1],this.cameraUniforms.setData(s)}packSettingsUniforms(e,t){const s=this.scratchSettingsView;let n=0;s.setFloat32(n+0,t.clippingBoxMin[0],!0),s.setFloat32(n+4,t.clippingBoxMin[1],!0),s.setFloat32(n+8,t.clippingBoxMin[2],!0),s.setFloat32(n+12,0,!0),n+=16,s.setFloat32(n+0,t.clippingBoxMax[0],!0),s.setFloat32(n+4,t.clippingBoxMax[1],!0),s.setFloat32(n+8,t.clippingBoxMax[2],!0),s.setFloat32(n+12,0,!0),n+=16,s.setFloat32(n,t.gaussianScaling,!0),n+=4,s.setUint32(n,t.maxSHDegree,!0),n+=4,s.setUint32(n,t.showEnvMap?1:0,!0),n+=4,s.setUint32(n,t.mipSplatting?1:0,!0),n+=4,s.setFloat32(n,t.kernelSize,!0),n+=4,s.setFloat32(n,t.walltime,!0),n+=4,s.setFloat32(n,t.sceneExtend,!0),n+=4,n=64,s.setFloat32(n+0,t.center[0],!0),s.setFloat32(n+4,t.center[1],!0),s.setFloat32(n+8,t.center[2],!0),s.setFloat32(n+12,0,!0),this.settingsUniforms.setData(s)}identityMat4(){return new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])}async debugCountValues(){this._debugCountBuffer&&(console.log("=== PREPROCESSOR DEBUG ==="),await wn(this.device,this._debugCountBuffer,this.modelParamsUniforms?.buffer||null,this._debugMaxPoints||0))}getPointCloudBindGroupLayout(e){return e.createBindGroupLayout({label:"Point Cloud Bind Group Layout",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:3,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}}]})}getSortBindGroupLayout(e){return e.createBindGroupLayout({label:"Sort Preprocess Bind Group Layout",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}},{binding:3,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}]})}getSettingsAndModelParamsBGL(e){return e.createBindGroupLayout({label:"Settings + ModelParams BGL",entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}}]})}getSortBindGroup(e){return e.sorter_bg_pre}invertMatrix4(e){const t=new Float32Array(16),s=e;t[0]=s[5]*s[10]*s[15]-s[5]*s[11]*s[14]-s[9]*s[6]*s[15]+s[9]*s[7]*s[14]+s[13]*s[6]*s[11]-s[13]*s[7]*s[10],t[4]=-s[4]*s[10]*s[15]+s[4]*s[11]*s[14]+s[8]*s[6]*s[15]-s[8]*s[7]*s[14]-s[12]*s[6]*s[11]+s[12]*s[7]*s[10],t[8]=s[4]*s[9]*s[15]-s[4]*s[11]*s[13]-s[8]*s[5]*s[15]+s[8]*s[7]*s[13]+s[12]*s[5]*s[11]-s[12]*s[7]*s[9],t[12]=-s[4]*s[9]*s[14]+s[4]*s[10]*s[13]+s[8]*s[5]*s[14]-s[8]*s[6]*s[13]-s[12]*s[5]*s[10]+s[12]*s[6]*s[9],t[1]=-s[1]*s[10]*s[15]+s[1]*s[11]*s[14]+s[9]*s[2]*s[15]-s[9]*s[3]*s[14]-s[13]*s[2]*s[11]+s[13]*s[3]*s[10],t[5]=s[0]*s[10]*s[15]-s[0]*s[11]*s[14]-s[8]*s[2]*s[15]+s[8]*s[3]*s[14]+s[12]*s[2]*s[11]-s[12]*s[3]*s[10],t[9]=-s[0]*s[9]*s[15]+s[0]*s[11]*s[13]+s[8]*s[1]*s[15]-s[8]*s[3]*s[13]-s[12]*s[1]*s[11]+s[12]*s[3]*s[9],t[13]=s[0]*s[9]*s[14]-s[0]*s[10]*s[13]-s[8]*s[1]*s[14]+s[8]*s[2]*s[13]+s[12]*s[1]*s[10]-s[12]*s[2]*s[9],t[2]=s[1]*s[6]*s[15]-s[1]*s[7]*s[14]-s[5]*s[2]*s[15]+s[5]*s[3]*s[14]+s[13]*s[2]*s[7]-s[13]*s[3]*s[6],t[6]=-s[0]*s[6]*s[15]+s[0]*s[7]*s[14]+s[4]*s[2]*s[15]-s[4]*s[3]*s[14]-s[12]*s[2]*s[7]+s[12]*s[3]*s[6],t[10]=s[0]*s[5]*s[15]-s[0]*s[7]*s[13]-s[4]*s[1]*s[15]+s[4]*s[3]*s[13]+s[12]*s[1]*s[7]-s[12]*s[3]*s[5],t[14]=-s[0]*s[5]*s[14]+s[0]*s[6]*s[13]+s[4]*s[1]*s[14]-s[4]*s[2]*s[13]-s[12]*s[1]*s[6]+s[12]*s[2]*s[5],t[3]=-s[1]*s[6]*s[11]+s[1]*s[7]*s[10]+s[5]*s[2]*s[11]-s[5]*s[3]*s[10]-s[9]*s[2]*s[7]+s[9]*s[3]*s[6],t[7]=s[0]*s[6]*s[11]-s[0]*s[7]*s[10]-s[4]*s[2]*s[11]+s[4]*s[3]*s[10]+s[8]*s[2]*s[7]-s[8]*s[3]*s[6],t[11]=-s[0]*s[5]*s[11]+s[0]*s[7]*s[9]+s[4]*s[1]*s[11]-s[4]*s[3]*s[9]-s[8]*s[1]*s[7]+s[8]*s[3]*s[5],t[15]=s[0]*s[5]*s[10]-s[0]*s[6]*s[9]-s[4]*s[1]*s[10]+s[4]*s[2]*s[9]+s[8]*s[1]*s[6]-s[8]*s[2]*s[5];let n=s[0]*t[0]+s[1]*t[4]+s[2]*t[8]+s[3]*t[12];if(Math.abs(n)<1e-8)throw new Error("Matrix not invertible");n=1/n;for(let o=0;o<16;o++)t[o]*=n;return t}multiplyMatrix4(e,t){const s=e,n=t,o=new Float32Array(16);for(let i=0;i<4;i++){const r=s[i],l=s[i+4],u=s[i+8],d=s[i+12];o[i]=r*n[0]+l*n[1]+u*n[2]+d*n[3],o[i+4]=r*n[4]+l*n[5]+u*n[6]+d*n[7],o[i+8]=r*n[8]+l*n[9]+u*n[10]+d*n[11],o[i+12]=r*n[12]+l*n[13]+u*n[14]+d*n[15]}return o}}const bn=.3;class kt{device;format;shDegree;compressed;debug;pipeline;pipelineDepth;useDepth=!1;depthFormat="depth24plus";pipelineLayout;drawIndirectBuffer;sorter;preprocessorSH;preprocessorRGB;sortResourcesCache=new WeakMap;globalCapacity=0;globalBuffers=null;constructor(e,t,s,n=!1){"device"in e?(this.device=e.device,this.format=e.format,this.shDegree=e.shDegree,this.compressed=e.compressed??!1,this.debug=e.debug??!1):(this.device=e,this.format=t,this.shDegree=s,this.compressed=n,this.debug=!1)}async ensureSorter(){await this.initialize()}async initialize(){await this.initializeSorter(),await this.initializePreprocessor(),this.createPipelineLayout(),this.createRenderPipeline(),this.createIndirectDrawBuffer(),this.ensureGlobalCapacity(1e6);try{globalThis.gaussianRenderer=this}catch{}this.debug&&console.log(`GaussianRenderer initialized: ${this.format}, SH degree ${this.shDegree}, global capacity ${this.globalCapacity}`)}render(e,t){const s=this.getSortResources(t);e.setBindGroup(0,t.renderBindGroup()),e.setBindGroup(1,s.sorter_render_bg),e.setPipeline(this.useDepth&&this.pipelineDepth?this.pipelineDepth:this.pipeline),e.drawIndirect(this.drawIndirectBuffer,0)}setDepthEnabled(e){this.useDepth=!!e}setDepthFormat(e){this.depthFormat!==e&&(this.depthFormat=e,this.createDepthPipeline(),globalThis.GS_DEPTH_DEBUG&&(console.log("[GaussianRenderer] Depth format changed to:",e),console.log("[GaussianRenderer] Depth pipeline recreated")))}createDepthPipeline(){const e=this.device.createShaderModule({label:"Gaussian Shader Module",code:ps});this.pipelineDepth=this.device.createRenderPipeline({label:`Gaussian Render Pipeline (Depth-${this.depthFormat})`,layout:this.pipelineLayout,vertex:{module:e,entryPoint:"vs_main",buffers:[]},fragment:{module:e,entryPoint:"fs_main",targets:[{format:this.format,blend:{color:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"},alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"}}}]},primitive:{topology:"triangle-strip",frontFace:"ccw"},depthStencil:{format:this.depthFormat,depthWriteEnabled:!1,depthCompare:"less"},multisample:{}})}getPipelineInfo(){return{format:this.format,bindGroupLayouts:[We.renderBindGroupLayout(this.device),je.createRenderBindGroupLayout(this.device)]}}getRenderStats(e){const t=this.sortResourcesCache.get(e);return{gaussianCount:e.numPoints,visibleSplats:t?.num_points??0,memoryUsage:this.estimateMemoryUsage(e)}}prepareMulti(e,t,s,n){if(s.length===0)return;const o=[];let i=0;for(const r of s)o.push(i),i+=r.numPoints;if(this._dlog("[prepareMulti] total points =",i,"offsets =",o),this.ensureGlobalCapacity(i),!!this.globalBuffers){this._dlog("[prepareMulti] using global capacity =",this.globalCapacity),this.sorter.recordResetIndirectBuffer(this.globalBuffers.sortStuff.sorter_dis,this.globalBuffers.sortStuff.sorter_uni,t);for(let r=0;r<s.length;r++){const l=s[r],u=o[r];this._dlog(`[prepareMulti] dispatch model #${r} baseOffset=${u} count=${l.numPoints}`);let d;"countBuffer"in l&&typeof l.countBuffer=="function"&&(d=l.countBuffer(),d&&this._dlog(`[prepareMulti] Model #${r} has ONNX count buffer`));const h=this.getColorMode(l)==="rgb"?this.preprocessorRGB:this.preprocessorSH,m=this.buildRenderSettings(l,n);h.dispatchModel({camera:n.camera,viewport:n.viewport,pointCloud:l,sortStuff:this.globalBuffers.sortStuff,settings:m,modelMatrix:l.transform,baseOffset:u,global:{splat2D:this.globalBuffers.splat2D},countBuffer:d},e)}this.sorter.recordSortIndirect(this.globalBuffers.sortStuff,this.globalBuffers.sortStuff.sorter_dis,e),e.copyBufferToBuffer(this.globalBuffers.sortStuff.sorter_uni,0,this.drawIndirectBuffer,4,4),this._dlog("[prepareMulti] recorded global sort & updated instanceCount from sorter_uni")}}renderMulti(e,t){this.globalBuffers&&(e.setBindGroup(0,this.globalBuffers.renderBG),e.setBindGroup(1,this.globalBuffers.sortStuff.sorter_render_bg),e.setPipeline(this.useDepth&&this.pipelineDepth?this.pipelineDepth:this.pipeline),e.drawIndirect(this.drawIndirectBuffer,0))}async initializeSorter(){this.sorter=await je.create(this.device,this.device.queue)}async initializePreprocessor(){this.preprocessorSH=new vs,await this.preprocessorSH.initialize(this.device,this.shDegree,!1),this.preprocessorRGB=new vs,await this.preprocessorRGB.initialize(this.device,0,!0),console.log("Initialized dual preprocessors: SH and RGB modes")}getColorMode(e){return e.colorMode}createPipelineLayout(){this.pipelineLayout=this.device.createPipelineLayout({label:"Gaussian Renderer Pipeline Layout",bindGroupLayouts:[We.renderBindGroupLayout(this.device),je.createRenderBindGroupLayout(this.device)]})}createRenderPipeline(){const e=this.device.createShaderModule({label:"Gaussian Shader Module",code:ps});this.pipeline=this.device.createRenderPipeline({label:"Gaussian Render Pipeline",layout:this.pipelineLayout,vertex:{module:e,entryPoint:"vs_main",buffers:[]},fragment:{module:e,entryPoint:"fs_main",targets:[{format:this.format,blend:{color:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"},alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"}}}]},primitive:{topology:"triangle-strip",frontFace:"ccw"},multisample:{}}),this.createDepthPipeline()}createIndirectDrawBuffer(){this.drawIndirectBuffer=this.device.createBuffer({label:"Gaussian Indirect Draw Buffer",size:16,usage:GPUBufferUsage.INDIRECT|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC}),this.device.queue.writeBuffer(this.drawIndirectBuffer,0,new Uint32Array([4,0,0,0]))}getSortResources(e){let t=this.sortResourcesCache.get(e);return(!t||t.num_points!==e.numPoints)&&(t=this.sorter.createSortStuff(this.device,e.numPoints),this.sortResourcesCache.set(e,t),this.debug&&console.log(`Created sort resources for ${e.numPoints} points`)),t}buildRenderSettings(e,t){const s=e.bbox,n=e.center,o=s.min,i=s.max,r=Math.max(Math.abs(i[0]-o[0]),Math.abs(i[1]-o[1]),Math.abs(i[2]-o[2]));return{maxSHDegree:Math.min(t.maxSHDegree??e.shDeg,this.shDegree),showEnvMap:t.showEnvMap??!0,mipSplatting:t.mipSplatting??e.mipSplatting??!1,kernelSize:t.kernelSize??e.kernelSize??bn,walltime:t.walltime??1,sceneExtend:t.sceneExtend??r,center:new Float32Array([t.sceneCenter?.[0]??n[0],t.sceneCenter?.[1]??n[1],t.sceneCenter?.[2]??n[2]]),clippingBoxMin:new Float32Array([t.clippingBox?.min[0]??o[0],t.clippingBox?.min[1]??o[1],t.clippingBox?.min[2]??o[2]]),clippingBoxMax:new Float32Array([t.clippingBox?.max[0]??i[0],t.clippingBox?.max[1]??i[1],t.clippingBox?.max[2]??i[2]])}}estimateMemoryUsage(e){const t=e.numPoints*128,s=e.numPoints*8*2;return t+s}async ensureGlobalCapacity(e){const t=Math.max(1,e);if(this.globalBuffers&&t<=this.globalCapacity)return;this._dlog("[ensureGlobalCapacity] grow needed. needed=",t,"oldCap=",this.globalCapacity);const s=Math.ceil(t*1.25);if(this.globalBuffers){try{this.globalBuffers.splat2D.destroy()}catch{}this.globalBuffers=null}for(;!this.sorter;)await new Promise(l=>setTimeout(l,100));const n=this.sorter.createSortStuff(this.device,s),o=this.device.createBuffer({label:`global/splat2d(cap=${s})`,size:s*Ut.SPLAT_STRIDE,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC}),i=We.renderBindGroupLayout(this.device),r=this.device.createBindGroup({label:"global/render/bg",layout:i,entries:[{binding:2,resource:{buffer:o}}]});this.globalBuffers={splat2D:o,renderBG:r,sortStuff:n},this.globalCapacity=s,this._dlog("[ensureGlobalCapacity] new capacity =",this.globalCapacity)}async readInstanceCountDebug(){const e=this.device.createBuffer({label:"debug/instanceCount",size:4,usage:GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST}),t=this.device.createCommandEncoder({label:"debug/enc"});t.copyBufferToBuffer(this.drawIndirectBuffer,4,e,0,4),this.device.queue.submit([t.finish()]),await this.device.queue.onSubmittedWorkDone(),await e.mapAsync(GPUMapMode.READ);const s=new Uint32Array(e.getMappedRange())[0];return e.unmap(),e.destroy(),console.log("[debug] instanceCount =",s),s}async debugONNXCount(){if(console.log("=== RENDERER DEBUG: ONNX Count Pipeline ==="),this._debugCountBuffer){const e=this.preprocessorSH;"debugCountValues"in e&&typeof e.debugCountValues=="function"&&await e.debugCountValues();const t=this._debugPointCloud;t&&console.log(`PointCloud.numPoints = ${t.numPoints}`)}else console.log("No ONNX count buffer to debug")}async readPayloadSampleDebug(e=8){if(!this.globalBuffers)throw new Error("globalBuffers not ready");const t=this.globalBuffers.sortStuff.payload_a,s=Math.min(t.size,e*4),n=this.device.createBuffer({label:"debug/payloadSample",size:s,usage:GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST}),o=this.device.createCommandEncoder({label:"debug/payloadEnc"});o.copyBufferToBuffer(t,0,n,0,s),this.device.queue.submit([o.finish()]),await this.device.queue.onSubmittedWorkDone(),await n.mapAsync(GPUMapMode.READ);const i=new Uint32Array(n.getMappedRange().slice(0));return n.unmap(),n.destroy(),console.log("[debug] payload[0..",e,")=",Array.from(i)),i}_dlog(...e){try{globalThis.GS_DEBUG_LOGS&&console.log(...e)}catch{}}}const xe=a=>document.querySelector(a);class vn{canvas=xe("#canvas");loadingOverlay=xe("#loadingOverlay");progressFill=document.querySelector("#loadingOverlay .progress-fill");progressText=document.querySelector("#loadingOverlay .progress-text");errorModal=xe("#errorModal");errorMessage=xe("#errorMessage");closeError=xe("#closeError");noWebGPU=xe("#noWebGPU");dropZone=xe("#dropZone");browseBtn=xe("#browseButton");fileInput=xe("#fileInput");togglePanelBtn=xe("#togglePanel");fpsEl=xe("#fps");pointCountEl=xe("#pointCount")}function pt(a,e){a?.classList.toggle("hidden",e)}function Ss(a,e,t){return Math.max(e,Math.min(t,a))}class Sn{dom;callbacks;controller;lastX=0;lastY=0;draggingL=!1;draggingR=!1;constructor(e,t,s){this.dom=e,this.callbacks=s,this.controller=t}bindEvents(e){this.bindFileHandling(),this.bindCameraControls(e),this.bindModalControls()}bindFileHandling(){this.dom.dropZone.addEventListener("dragover",e=>{e.preventDefault(),this.dom.dropZone.classList.add("dragover")}),this.dom.dropZone.addEventListener("dragleave",()=>{this.dom.dropZone.classList.remove("dragover")}),this.dom.dropZone.addEventListener("drop",async e=>{e.preventDefault(),this.dom.dropZone.classList.remove("dragover");const t=e.dataTransfer?.files?.[0];t&&await this.callbacks.onFileLoad(t)}),this.dom.browseBtn.addEventListener("click",()=>{this.dom.fileInput.click()}),this.dom.fileInput.addEventListener("change",async()=>{const e=this.dom.fileInput.files?.[0];e&&(await this.callbacks.onFileLoad(e),this.dom.fileInput.value="")}),this.dom.togglePanelBtn?.addEventListener("click",()=>{document.querySelector(".side-panel")?.classList.toggle("collapsed")})}bindCameraControls(e){e.addEventListener("mousedown",t=>{t.button===0&&(this.draggingL=!0,this.controller.leftMousePressed=!0),t.button===2&&(this.draggingR=!0,this.controller.rightMousePressed=!0),this.lastX=t.clientX,this.lastY=t.clientY}),window.addEventListener("mouseup",t=>{t.button===0&&(this.draggingL=!1,this.controller.leftMousePressed=!1),t.button===2&&(this.draggingR=!1,this.controller.rightMousePressed=!1)}),window.addEventListener("mousemove",t=>{const s=t.clientX-this.lastX,n=t.clientY-this.lastY;this.lastX=t.clientX,this.lastY=t.clientY,(this.draggingL||this.draggingR)&&this.controller.processMouse(s,n)}),e.addEventListener("wheel",t=>{t.preventDefault(),this.controller.processScroll(t.deltaY>0?.05:-.05)},{passive:!1}),window.addEventListener("keydown",t=>{this.controller.processKeyboard(t.code,!0)}),window.addEventListener("keyup",t=>{this.controller.processKeyboard(t.code,!1)}),e.addEventListener("contextmenu",t=>t.preventDefault())}bindModalControls(){this.dom.closeError.addEventListener("click",()=>{pt(this.dom.errorModal,!0)})}}const Ps=new URL("data:application/octet-stream;base64,CAgSB3B5dG9yY2gaBTIuNS4wOlgKNRIFZHVtbXkaCkNvbnN0YW50XzEiCENvbnN0YW50KhYKBXZhbHVlKgoIARAGSgQBAAAAoAEEEgptYWluX2dyYXBoYhMKBWR1bW15EgoKCAgGEgQKAggBQgIQEQ==",typeof document>"u"&&typeof location>"u"?require("url").pathToFileURL(__filename).href:typeof document>"u"?location.href:xt&&xt.tagName.toUpperCase()==="SCRIPT"&&xt.src||new URL("visionary-core.umd.js",document.baseURI).href).toString();async function gt(){const a=globalThis;if(a.__ORT_WEBGPU_SINGLETON__)return a.__ORT_WEBGPU_SINGLETON__;try{const e=await import("onnxruntime-web/webgpu");return a.__ORT_WEBGPU_SINGLETON__=e,e}catch{return null}}async function Pn(a){const e=await gt();if(!e)return;e.env.wasm.numThreads=1,e.env.logLevel="warning",e.env.wasm.wasmPaths?console.log("[WebGPU] Using existing WASM paths:",e.env.wasm.wasmPaths):(e.env.wasm.wasmPaths="/src/ort/",console.log("[WebGPU] Setting default WASM paths:",e.env.wasm.wasmPaths));const t=await fetch(a);if(!t.ok)throw new Error(`[ORT] Failed to fetch dummy model: ${a}`);const s=await t.arrayBuffer();await e.InferenceSession.create(s,{executionProviders:["webgpu"]})}async function xn(a){const e=await gt();if(!e)return null;try{const t=e.env.webgpu;if(t){const s=t.device;if(s){const n=s instanceof Promise?await s:s;if(n)return console.log("[WebGPU] Reusing existing ORT device from obtainOrtDevice"),n}}}catch(t){console.warn("[WebGPU] Could not check existing ORT device:",t)}if(a.adapter)try{const t=e.env.webgpu||{};e.env.webgpu=t;const s=t.adapter;if(s){if(s!==a.adapter)try{const n=Object.getOwnPropertyDescriptor(t,"adapter");n&&n.writable!==!1?t.adapter=a.adapter:console.warn("[WebGPU] Adapter is read-only, keeping existing adapter")}catch(n){console.warn("[WebGPU] Could not update adapter (may be read-only, which is OK):",n)}}else try{t.adapter=a.adapter}catch(n){console.warn("[WebGPU] Could not set adapter (may be read-only):",n)}}catch(t){console.warn("[WebGPU] Could not access ORT webgpu environment:",t)}try{const t=e.env.webgpu;if(t){const s=t.device;if(s){const n=s instanceof Promise?await s:s;if(n)return n}}}catch(t){console.warn("[WebGPU] Could not get device from ORT env:",t)}if(a.dummyModelUrl)try{await Pn(a.dummyModelUrl);const t=await gt();if(t)try{const s=t.env.webgpu?.device;if(s){const n=s instanceof Promise?await s:s;if(n)return n}}catch{}}catch(t){console.warn("[WebGPU] Failed to create dummy session:",t)}return null}async function Cn(a){const e=[];a.features.has("shader-f16")&&e.push("shader-f16"),a.features.has("timestamp-query")&&e.push("timestamp-query"),a.features.has("chromium-experimental-timestamp-query-inside-passes")&&e.push("chromium-experimental-timestamp-query-inside-passes");const t=a.limits,s={maxStorageBufferBindingSize:t.maxStorageBufferBindingSize,maxBufferSize:t.maxBufferSize??t.maxStorageBufferBindingSize,maxComputeWorkgroupStorageSize:Math.min(32768,t.maxComputeWorkgroupStorageSize),maxComputeInvocationsPerWorkgroup:t.maxComputeInvocationsPerWorkgroup,maxComputeWorkgroupSizeX:t.maxComputeWorkgroupSizeX,maxComputeWorkgroupSizeY:t.maxComputeWorkgroupSizeY,maxComputeWorkgroupSizeZ:t.maxComputeWorkgroupSizeZ},n=await a.requestDevice({requiredFeatures:e,requiredLimits:s});return n.label||(n.label="app-device"),n}async function Ft(a,e={}){if(!navigator.gpu)return console.error("WebGPU not supported in this environment."),null;const t=await gt();let s=null,n=null;if(e.preferShareWithOrt!==!1&&t)try{const r=t.env.webgpu;if(r){const l=r.device;l&&(s=l instanceof Promise?await l:l,s&&(console.log("[WebGPU] Reusing existing ORT device for new canvas"),n=r.adapter))}}catch(r){console.warn("[WebGPU] Could not get existing ORT device:",r)}if(s){if(!n){try{n=t?.env?.webgpu?.adapter}catch{}n||(n=await navigator.gpu.requestAdapter({powerPreference:e.adapterPowerPreference}))}}else{if(n=await navigator.gpu.requestAdapter({powerPreference:e.adapterPowerPreference}),!n)throw new Error("No WebGPU adapter found");if(e.preferShareWithOrt!==!1&&t)if(s=await xn({adapter:n,dummyModelUrl:e.dummyModelUrl??null}),s){if(s&&!n)try{n=t.env?.webgpu?.adapter}catch{}}else{const r=!!e.allowOwnDeviceWhenOrtPresent,l="[WebGPU init] ORT detected but failed to obtain its device. "+(r?"Proceeding with app-owned device (do NOT use ORT later).":"Refusing to create a separate device to avoid future mismatch.- Provide a valid dummyModelUrl, ORdisable preferShareWithOrt, ORensure a single ORT import.");if(console.warn(l),!r)throw new Error("ORT present but cannot acquire ORT device (strict mode)")}if(!s){if(!n&&(n=await navigator.gpu.requestAdapter({powerPreference:e.adapterPowerPreference}),!n))throw new Error("No WebGPU adapter found");s=await Cn(n)}}s.pushErrorScope("out-of-memory"),s.pushErrorScope("validation"),await s.popErrorScope().then(r=>console.warn("validation:",r)),await s.popErrorScope().then(r=>console.warn("oom:",r)),s.lost.then(r=>console.error("device lost:",r.message,r.reason));const o=a.getContext("webgpu");if(!o)throw new Error("Failed to get WebGPU canvas context");const i=navigator.gpu.getPreferredCanvasFormat();return o.configure({device:s,format:i,alphaMode:"premultiplied"}),console.log(`[WebGPU] initialized. format=${i}, sharedWithORT=${!!(t&&e.preferShareWithOrt!==!1)}`),{device:s,context:o,format:i}}let Lt="/src/ort/";function xs(a){typeof a=="string"?Lt=a:Lt=a.join(",")}function st(){return Lt}function Cs(a){if(a&&xs(a),typeof window<"u"&&window.ort){const e=window.ort;e.env.wasm.wasmPaths=st(),console.log(`[VisionaryCore] ONNX Runtime WASM paths configured: ${st()}`)}else if(console.warn("[VisionaryCore] ONNX Runtime not available, configuration will be applied when ort is loaded"),typeof window<"u"){const e=()=>{if(window.ort){const t=window.ort;t.env.wasm.wasmPaths=st(),console.log(`[VisionaryCore] ONNX Runtime WASM paths configured (delayed): ${st()}`)}else setTimeout(e,50)};setTimeout(e,50)}}function Ms(){return"/src/ort/"}function Mn(){return typeof window<"u"&&window.ort&&window.ort.env&&window.ort.env.wasm&&window.ort.env.wasm.wasmPaths}class Rt{models=[];maxModels;constructor(e=1e4){this.maxModels=e}addModel(e){if(this.models.length>=this.maxModels)throw new Error(`Reached model limit (${this.maxModels}). Remove models before adding more.`);const s={id:`${Date.now()}-${Math.random().toString(16).slice(2,8)}`,...e};return this.models.push(s),console.log(`Model added: ${s.name} (${s.pointCount.toLocaleString()} points, ${s.modelType})`),s}removeModel(e){const t=this.models.findIndex(s=>s.id===e);if(t>=0){const s=this.models[t];return this.models.splice(t,1),console.log(`Model removed: ${s.name}`),!0}return!1}getModels(){return this.models.map(e=>({id:e.id,name:e.name,visible:e.visible,pointCount:e.pointCount||0,isDynamic:e.isDynamic,modelType:e.modelType,colorMode:e.colorMode,colorChannels:e.colorChannels}))}getModelWithPointCloud(e,t){return t?this.models.find(s=>s.id===t)||null:this.models.find(s=>s.modelType===e)||null}getFullModels(){return[...this.models]}getModelsByType(e){return this.models.filter(t=>t.modelType===e)}getVisibleModels(){return this.models.filter(e=>e.visible)}getDynamicModels(){return this.models.filter(e=>e.isDynamic)}setModelVisibility(e,t){const s=this.models.find(n=>n.id===e);return s?(s.visible=t,console.log(`Model ${s.name}: ${t?"shown":"hidden"}`),!0):!1}getTotalVisiblePoints(){return this.models.filter(e=>e.visible).reduce((e,t)=>e+t.pointCount,0)}getTotalPoints(){return this.models.reduce((e,t)=>e+t.pointCount,0)}isAtCapacity(){return this.models.length>=this.maxModels}getModelCount(){return this.models.length}getRemainingCapacity(){return Math.max(0,this.maxModels-this.models.length)}clearAllModels(){const e=this.models.length;this.models=[],console.log(`Cleared ${e} models`)}findModelByName(e){return this.models.find(t=>t.name===e)||null}setModelPosition(e,t,s,n){return this.updateModelTransform(e,{translation:c.vec3.fromValues(t,s,n)})}setModelRotation(e,t,s,n){return this.updateModelTransform(e,{rotationEuler:c.vec3.fromValues(t,s,n)})}setModelScale(e,t){const n=Array.isArray(t)?c.vec3.fromValues(Math.max(1e-4,t[0]),Math.max(1e-4,t[1]),Math.max(1e-4,t[2])):c.vec3.fromValues(Math.max(1e-4,t),Math.max(1e-4,t),Math.max(1e-4,t));return this.updateModelTransform(e,{scale:n})}setModelTransform(e,t){const s=this.models.find(n=>n.id===e);return s?(s.pointCloud.setTransform(t),console.log(`Model ${s.name} transform updated`),!0):!1}getModelPosition(e){const t=this.models.find(s=>s.id===e);if(t){const s=t.pointCloud.transform;return[s[12],s[13],s[14]]}return null}getModelRotation(e){const t=this.models.find(m=>m.id===e);if(!t)return null;const s=c.mat4.clone(t.pointCloud.transform),n=c.quat.create();if(!c.mat4.getRotation)return[0,0,0];c.mat4.getRotation(n,s);const o=2*(n[3]*n[0]+n[1]*n[2]),i=1-2*(n[0]*n[0]+n[1]*n[1]),r=Math.atan2(o,i),l=2*(n[3]*n[1]-n[2]*n[0]),u=Math.abs(l)>=1?Math.sign(l)*Math.PI/2:Math.asin(l),d=2*(n[3]*n[2]+n[0]*n[1]),f=1-2*(n[1]*n[1]+n[2]*n[2]),h=Math.atan2(d,f);return[r,u,h]}getModelScale(e){const t=this.models.find(o=>o.id===e);if(!t)return null;const s=c.mat4.clone(t.pointCloud.transform),n=c.vec3.create();return c.mat4.getScaling?(c.mat4.getScaling(n,s),[n[0],n[1],n[2]]):[1,1,1]}getModelTransform(e){const t=this.models.find(s=>s.id===e);return t?t.pointCloud.transform:null}updateModelTransform(e,t){const s=this.models.find(u=>u.id===e);if(!s)return console.log(`Model with ID ${e} not found for transform update`),!1;const n=c.mat4.clone(s.pointCloud.transform),o=c.vec3.create();c.mat4.getTranslation?.(o,n);const i=c.vec3.create();c.mat4.getScaling?c.mat4.getScaling(i,n):c.vec3.set(i,1,1,1);const r=c.quat.create();if(c.mat4.getRotation?c.mat4.getRotation(r,n):c.quat.identity(r),t.translation&&c.vec3.copy(o,t.translation),t.scale&&c.vec3.copy(i,t.scale),t.rotationEuler){const u=c.vec3.fromValues(t.rotationEuler[0]*180/Math.PI,t.rotationEuler[1]*180/Math.PI,t.rotationEuler[2]*180/Math.PI);c.quat.fromEuler(r,u[0],u[1],u[2])}const l=c.mat4.create();return c.mat4.fromRotationTranslationScale(l,r,o,i),s.pointCloud.setTransform(l),console.log(`Model ${s.name} transform updated (pos=${o.join(",")}, scale=${i.join(",")})`),!0}hasModelWithName(e){return this.models.some(t=>t.name===e)}generateUniqueName(e){if(!this.hasModelWithName(e))return e;let t=1,s;do s=`${e} (${t})`,t++;while(this.hasModelWithName(s));return s}}class qe{_gaussianBuffer;_shCoefsBuffer;_numPoints;_shDegree;_bbox;center;up;kernelSize;mipSplatting;backgroundColor;constructor(e){this._gaussianBuffer=e.gaussianBuffer,this._shCoefsBuffer=e.shCoefsBuffer,this._numPoints=e.numPoints,this._shDegree=e.shDegree,this._bbox=e.bbox,this.center=e.center,this.up=e.up,this.kernelSize=e.kernelSize,this.mipSplatting=e.mipSplatting,this.backgroundColor=e.backgroundColor}gaussianBuffer(){return this._gaussianBuffer}shCoefsBuffer(){return this._shCoefsBuffer}numPoints(){return this._numPoints}shDegree(){return this._shDegree}bbox(){return this._bbox}}class Tn{async loadFile(e,t){const s=await e.arrayBuffer();return this.loadBuffer(s,t)}async loadUrl(e,t){const s=await fetch(e,{signal:t?.signal});if(!s.ok)throw new Error(`Failed to fetch PLY file: ${s.status} ${s.statusText}`);const n=await s.arrayBuffer();return this.loadBuffer(n,t)}async loadBuffer(e,t){const s=(r,l,u)=>{t?.onProgress?.({stage:r,progress:l,message:u})};s("Parsing PLY header",.1);const n=this.parseHeader(e);s("Parsing vertex data",.2);const o=this.parseVertices(e,n);s("Processing Gaussian data",.4);const i=this.processGaussianData(n,o,s);return s("Complete",1),i}canHandle(e,t){return e.toLowerCase().endsWith(".ply")||t==="application/octet-stream"}getSupportedExtensions(){return[".ply"]}processGaussianData(e,t,s){const r=(3+t.props.filter(I=>I.startsWith("f_rest_")).length)/3,l=an(r)??0,u=this.getFieldIndices(t.props);this.validateRequiredFields(u);const d=e.vertices,f=10,h=new Uint16Array(d*f),m=24,p=new Uint32Array(d*m),v=[],b=[Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY],y=[Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY],{copySH:_,wordsPerPoint:P}=un({props:t.props,iDC0:u.iDC0,iDC1:u.iDC1,iDC2:u.iDC2,k:3,shU32:p});s?.("Processing Gaussians",.5);for(let I=0;I<d;I++){I%1e4===0&&s?.("Processing Gaussians",.5+.3*(I/d),`${I}/${d} points`);const E=t.rows(I),R=this.processGaussian(E,u,I,f,h);v.push([R.x,R.y,R.z]),_(I*P,E,!1),R.x<b[0]&&(b[0]=R.x),R.y<b[1]&&(b[1]=R.y),R.z<b[2]&&(b[2]=R.z),R.x>y[0]&&(y[0]=R.x),R.y>y[1]&&(y[1]=R.y),R.z>y[2]&&(y[2]=R.z)}s?.("Computing scene geometry",.8);const{centroid:S,normal:M}=this.computeSceneGeometry(v),j=[S[0],S[1],S[2]],F=M?[M[0],M[1],M[2]]:[1,0,0];return new qe({gaussianBuffer:h.buffer,shCoefsBuffer:p.buffer,numPoints:d,shDegree:l,bbox:{min:b,max:y},center:j,up:F,mipSplatting:void 0,kernelSize:void 0,backgroundColor:void 0})}getFieldIndices(e){return{ix:e.indexOf("x"),iy:e.indexOf("y"),iz:e.indexOf("z"),iOpacity:e.indexOf("opacity"),iS0:e.indexOf("scale_0"),iS1:e.indexOf("scale_1"),iS2:e.indexOf("scale_2"),iR0:e.indexOf("rot_0"),iR1:e.indexOf("rot_1"),iR2:e.indexOf("rot_2"),iR3:e.indexOf("rot_3"),iDC0:e.indexOf("f_dc_0"),iDC1:e.indexOf("f_dc_1"),iDC2:e.indexOf("f_dc_2")}}validateRequiredFields(e){const t=["ix","iy","iz","iOpacity","iS0","iS1","iS2","iR0","iR1","iR2","iR3","iDC0","iDC1","iDC2"];for(const s of t)if(e[s]<0)throw new Error(`PLY missing required field: ${s.slice(1)}`)}processGaussian(e,t,s,n,o){const i=e[t.ix],r=e[t.iy],l=e[t.iz],u=cs(e[t.iOpacity]),d=[Math.exp(e[t.iS0]),Math.exp(e[t.iS1]),Math.exp(e[t.iS2])],f=c.quat.fromValues(e[t.iR1],e[t.iR2],e[t.iR3],e[t.iR0]);c.quat.normalize(f,f);const[h,m,p,v,b,y]=Ve(f,new Float32Array(d)),_=s*n;return o[_+0]=w(i),o[_+1]=w(r),o[_+2]=w(l),o[_+3]=w(u),o[_+4]=w(h),o[_+5]=w(m),o[_+6]=w(p),o[_+7]=w(v),o[_+8]=w(b),o[_+9]=w(y),{x:i,y:r,z:l}}computeSceneGeometry(e){return Mt(e)}parseHeader(e){const t=new TextDecoder().decode(e.slice(0,Math.min(1048576,e.byteLength))),s=t.split(/\r?\n/);if(!/^ply\b/.test(s[0]))throw new Error("Not a PLY file");let n=null,o=0;const i=[];let r=0,l=!1;for(let u=1;u<s.length;u++){const d=s[u];if(d==="end_header"){let f=t.indexOf("end_header");if(f<0)throw new Error("Malformed PLY: missing end_header");const h=t.indexOf(`
`,f+10);r=h>=0?h+1:f+10+1;break}if(d.startsWith("format ")){const f=d.split(/\s+/)[1];if(f==="ascii"||f==="binary_little_endian"||f==="binary_big_endian")n=f;else throw new Error(`Unsupported PLY format: ${f}`)}else if(d.startsWith("element "))l=d.startsWith("element vertex "),l&&(o=parseInt(d.split(/\s+/)[2],10));else if(l&&d.startsWith("property ")){const f=d.trim().split(/\s+/);if(f[1]==="list")throw new Error("Unexpected list property in vertex");const h=f[f.length-1];i.push(h)}}if(!n)throw new Error("PLY header missing format");if(o<=0)throw new Error("PLY has no vertices element");return{format:n,vertices:o,props:i,headerByteLength:r}}parseVertices(e,t){const s=t.props.slice();return t.format==="ascii"?this.parseASCIIVertices(e,t,s):this.parseBinaryVertices(e,t,s)}parseASCIIVertices(e,t,s){const o=new TextDecoder().decode(e.slice(t.headerByteLength)).split(/\r?\n/).filter(i=>i.trim().length>0);return{props:s,rows:i=>{const r=o[i].trim().split(/\s+/);if(r.length<s.length)throw new Error("Malformed PLY ASCII row");return r.map(parseFloat)}}}parseBinaryVertices(e,t,s){const n=t.format==="binary_little_endian",o=new DataView(e,t.headerByteLength),i=s.length*4;return{props:s,rows:r=>{const l=r*i,u=new Array(s.length);for(let d=0;d<s.length;d++)u[d]=o.getFloat32(l+d*4,n);return u}}}}class Un{async loadFile(e,t){return this.loadBuffer(await e.arrayBuffer(),t)}async loadUrl(e,t){const s=await fetch(e,{signal:t?.signal});if(!s.ok)throw new Error(`Failed to fetch SPZ: ${s.statusText}`);return this.loadBuffer(await s.arrayBuffer(),t)}async loadBuffer(e,t){const s=(N,U,T)=>{t?.onProgress?.({stage:N,progress:U,message:T})};s("Decompressing SPZ",.1);const n=new Uint8Array(e),i=new Blob([n]).stream().pipeThrough(new DecompressionStream("gzip")),r=await new Response(i).arrayBuffer();s("Parsing Data",.2);const l=new DataView(r),u=new Uint8Array(r);let d=0;const f=l.getUint32(d,!0);if(d+=4,f!==1347635022)throw new Error(`Invalid SPZ magic: 0x${f.toString(16)}`);const h=l.getUint32(d,!0);d+=4;const m=l.getUint32(d,!0);d+=4;const p=l.getUint8(d++),v=l.getUint8(d++);if(l.getUint8(d++),d++,h<1||h>3)throw new Error(`Unsupported SPZ version: ${h}`);const b=d;h===1?d+=m*6:d+=m*9;const y=d;d+=m;const _=d;d+=m*3;const P=d;d+=m*3;const S=d;h===3?d+=m*4:d+=m*3;const M=d,F={1:3,2:8,3:15}[p]||0,I=10,E=new Uint16Array(m*I),R=24,z=new Uint32Array(m*R),Y=[];let ee=1/0,J=1/0,D=1/0,H=-1/0,K=-1/0,ue=-1/0;const Z=1<<v,ie=c.quat.create(),fe=c.vec3.create();s("Processing Points",.3);for(let N=0;N<m;N++){N%1e4===0&&N%5e4===0&&s("Processing Points",.3+.6*(N/m));let U,T,g;if(h===1)U=this.readHalfFloat(l,b+N*6+0),T=this.readHalfFloat(l,b+N*6+2),g=this.readHalfFloat(l,b+N*6+4);else{const W=b+N*9,A=u[W]|u[W+1]<<8|u[W+2]<<16,re=u[W+3]|u[W+4]<<8|u[W+5]<<16,se=u[W+6]|u[W+7]<<8|u[W+8]<<16;U=(A<<8>>8)/Z,T=(re<<8>>8)/Z,g=(se<<8>>8)/Z}const x=u[y+N]/255,B=_+N*3,C=(u[B]/255-.5)/.15,O=(u[B+1]/255-.5)/.15,$=(u[B+2]/255-.5)/.15,k=P+N*3,X=Math.exp(u[k]/16-10),ce=Math.exp(u[k+1]/16-10),de=Math.exp(u[k+2]/16-10);if(h===3){const W=S+N*4,A=u[W]|u[W+1]<<8|u[W+2]<<16|u[W+3]<<24,re=.70710678,se=511,ae=A>>>30;let le=A;const me=[0,0,0,0];let Me=0;for(let q=3;q>=0;q--)if(q!==ae){const Se=le&se,Ae=le>>>9&1;le>>>=10;let ve=re*(Se/511);Ae&&(ve=-ve),me[q]=ve,Me+=ve*ve}me[ae]=Math.sqrt(Math.max(1-Me,0)),c.quat.set(ie,me[0],me[1],me[2],me[3])}else{const W=S+N*3,A=u[W]/127.5-1,re=u[W+1]/127.5-1,se=u[W+2]/127.5-1,ae=Math.sqrt(Math.max(0,1-A*A-re*re-se*se));c.quat.set(ie,A,re,se,ae)}c.quat.normalize(ie,ie),c.vec3.set(fe,X,ce,de);const[oe,L,_e,we,Ue,ze]=Ve(ie,fe),he=N*I;E[he+0]=w(U),E[he+1]=w(T),E[he+2]=w(g),E[he+3]=w(x),E[he+4]=w(oe),E[he+5]=w(L),E[he+6]=w(_e),E[he+7]=w(we),E[he+8]=w(Ue),E[he+9]=w(ze);const ke=N*R;if(z[ke+0]=w(C)|w(O)<<16,z[ke+1]=w($),F>0){const W=M+N*F*3;let A=ke+1,re=!0;for(let se=0;se<F*3;se++){const ae=(u[W+se]-128)/128,le=w(ae);re?(z[A]|=le<<16,A++,re=!1):(z[A]=le,re=!0)}}U<ee&&(ee=U),U>H&&(H=U),T<J&&(J=T),T>K&&(K=T),g<D&&(D=g),g>ue&&(ue=g),Y.push([U,T,g])}s("Finalizing",.95);const{centroid:ne,normal:te}=Mt(Y);return console.log(`[SPZLoader] Loaded ${m} points efficiently.`),new qe({gaussianBuffer:E.buffer,shCoefsBuffer:z.buffer,numPoints:m,shDegree:p,bbox:{min:[ee,J,D],max:[H,K,ue]},center:[ne[0],ne[1],ne[2]],up:te?[te[0],te[1],te[2]]:[0,1,0]})}canHandle(e){return e.toLowerCase().endsWith(".spz")}getSupportedExtensions(){return[".spz"]}readHalfFloat(e,t){const s=e.getUint16(t,!0),n=(s&32768)>>15,o=(s&31744)>>10,i=s&1023;return o===0?(n?-1:1)*Math.pow(2,-14)*(i/1024):o===31?i?NaN:n?-1/0:1/0:(n?-1:1)*Math.pow(2,o-15)*(1+i/1024)}}class Bn{async loadFile(e,t){return this.loadBuffer(await e.arrayBuffer(),t)}async loadUrl(e,t){const s=await fetch(e,{signal:t?.signal});if(!s.ok)throw new Error(`Failed to fetch KSplat: ${s.statusText}`);return this.loadBuffer(await s.arrayBuffer(),t)}async loadBuffer(e,t){const s=(N,U,T)=>{t?.onProgress?.({stage:N,progress:U,message:T})};s("Parsing KSplat Header",.1);const n=4096,o=1024;let i=0;const r=new DataView(e,i,n),l=r.getUint8(0),u=r.getUint8(1);(l!==0||u<1)&&console.warn(`KSplat version ${l}.${u} might not be fully supported.`);const d=r.getUint32(4,!0),f=r.getUint32(16,!0),h=r.getUint16(20,!0),m=r.getFloat32(36,!0)||-1.5,p=r.getFloat32(40,!0)||1.5,v={0:{bytesPerCenter:12,bytesPerScale:12,bytesPerRotation:16,bytesPerColor:4,bytesPerSphericalHarmonicsComponent:4,scaleOffsetBytes:12,rotationOffsetBytes:24,colorOffsetBytes:40,sphericalHarmonicsOffsetBytes:44,scaleRange:1},1:{bytesPerCenter:6,bytesPerScale:6,bytesPerRotation:8,bytesPerColor:4,bytesPerSphericalHarmonicsComponent:2,scaleOffsetBytes:6,rotationOffsetBytes:12,colorOffsetBytes:20,sphericalHarmonicsOffsetBytes:24,scaleRange:32767},2:{bytesPerCenter:6,bytesPerScale:6,bytesPerRotation:8,bytesPerColor:4,bytesPerSphericalHarmonicsComponent:1,scaleOffsetBytes:6,rotationOffsetBytes:12,colorOffsetBytes:20,sphericalHarmonicsOffsetBytes:24,scaleRange:32767}},b=[0,9,24,45];s("Loading Data",.2);const y=10,_=new Uint16Array(f*y),P=24,S=new Uint32Array(f*P);let M=1/0,j=1/0,F=1/0,I=-1/0,E=-1/0,R=-1/0,z=0,Y=0,ee=0,J=n+d*o,D=0,H=0;const K=c.quat.create(),ue=c.vec3.create(),Z=.28209479177387814,ie=[0,3,6,1,4,7,2,5,8,9,14,19,10,15,20,11,16,21,12,17,22,13,18,23,24,31,38,25,32,39,26,33,40,27,34,41,28,35,42,29,36,43,30,37,44];i=n;for(let N=0;N<d;N++){const U=new DataView(e,i,o);i+=o;const T=U.getUint32(0,!0);if(T===0)continue;const g=U.getUint32(4,!0),x=U.getUint32(8,!0),B=U.getUint32(12,!0),C=U.getFloat32(16,!0),O=U.getUint16(20,!0),$=U.getUint32(24,!0)||v[h].scaleRange,k=U.getUint32(32,!0),X=k*x,ce=U.getUint32(36,!0),de=U.getUint16(40,!0);H=Math.max(H,de);const oe=b[de],L=v[h],_e=L.bytesPerCenter+L.bytesPerScale+L.bytesPerRotation+L.bytesPerColor+oe*L.bytesPerSphericalHarmonicsComponent,we=ce*4,Ue=O*B+we,ze=_e*g,he=J+we,ke=J+Ue,W=ze+Ue,A=new DataView(e,ke,ze),re=new Float32Array(e,he,B*3),se=new Uint32Array(e,J,ce),ae=C/2/$;let le=k,me=X;for(let Me=0;Me<T;Me++){D%2e4===0&&s("Processing Splats",.3+.6*(D/f));const q=Me*_e;let Se;if(Me<X)Se=Math.floor(Me/x);else{const Ie=se[le-k];Me>=me+Ie&&(le+=1,me+=Ie),Se=le}let Ae,ve,$e;if(h===0)Ae=A.getFloat32(q+0,!0),ve=A.getFloat32(q+4,!0),$e=A.getFloat32(q+8,!0);else{const Ie=re[3*Se+0],ut=re[3*Se+1],dt=re[3*Se+2];Ae=(A.getUint16(q+0,!0)-$)*ae+Ie,ve=(A.getUint16(q+2,!0)-$)*ae+ut,$e=(A.getUint16(q+4,!0)-$)*ae+dt}let Xe,pe,Ye;h===0?(Xe=A.getFloat32(q+L.scaleOffsetBytes,!0),pe=A.getFloat32(q+L.scaleOffsetBytes+4,!0),Ye=A.getFloat32(q+L.scaleOffsetBytes+8,!0)):(Xe=this.fromHalf(A.getUint16(q+L.scaleOffsetBytes,!0)),pe=this.fromHalf(A.getUint16(q+L.scaleOffsetBytes+2,!0)),Ye=this.fromHalf(A.getUint16(q+L.scaleOffsetBytes+4,!0))),Xe=Math.max(Xe,1e-6),pe=Math.max(pe,1e-6),Ye=Math.max(Ye,1e-6);let es,ts,ss,ns;h===0?(es=A.getFloat32(q+L.rotationOffsetBytes,!0),ts=A.getFloat32(q+L.rotationOffsetBytes+4,!0),ss=A.getFloat32(q+L.rotationOffsetBytes+8,!0),ns=A.getFloat32(q+L.rotationOffsetBytes+12,!0)):(es=this.fromHalf(A.getUint16(q+L.rotationOffsetBytes,!0)),ts=this.fromHalf(A.getUint16(q+L.rotationOffsetBytes+2,!0)),ss=this.fromHalf(A.getUint16(q+L.rotationOffsetBytes+4,!0)),ns=this.fromHalf(A.getUint16(q+L.rotationOffsetBytes+6,!0)));const Fo=A.getUint8(q+L.colorOffsetBytes)/255,Lo=A.getUint8(q+L.colorOffsetBytes+1)/255,Ro=A.getUint8(q+L.colorOffsetBytes+2)/255,Do=A.getUint8(q+L.colorOffsetBytes+3)/255;c.quat.set(K,ts,ss,ns,es),c.quat.normalize(K,K),c.vec3.set(ue,Xe,pe,Ye);const[Oo,zo,$o,Io,No,Vo]=Ve(K,ue),Ee=D*y;_[Ee+0]=w(Ae),_[Ee+1]=w(ve),_[Ee+2]=w($e),_[Ee+3]=w(Do),_[Ee+4]=w(Oo),_[Ee+5]=w(zo),_[Ee+6]=w($o),_[Ee+7]=w(Io),_[Ee+8]=w(No),_[Ee+9]=w(Vo);const os=D*P,Wo=(Fo-.5)/Z,jo=(Lo-.5)/Z,qo=(Ro-.5)/Z;if(S[os+0]=w(Wo)|w(jo)<<16,S[os+1]=w(qo),de>0){let Ie=os+1,ut=!0;for(let dt=0;dt<oe;dt++){const is=ie[dt];let Pt;const rs=q+L.sphericalHarmonicsOffsetBytes;if(h===0)Pt=A.getFloat32(rs+is*4,!0);else if(h===1)Pt=this.fromHalf(A.getUint16(rs+is*2,!0));else{const Ho=A.getUint8(rs+is)/255;Pt=m+Ho*(p-m)}const Ks=w(Pt);ut?(S[Ie]|=Ks<<16,Ie++,ut=!1):(S[Ie]=Ks,ut=!0)}}M=Math.min(M,Ae),I=Math.max(I,Ae),j=Math.min(j,ve),E=Math.max(E,ve),F=Math.min(F,$e),R=Math.max(R,$e),z+=Ae,Y+=ve,ee+=$e,D++}J+=W}s("Finalizing",.95);const fe=D>0?z/D:0,ne=D>0?Y/D:0,te=D>0?ee/D:0;return console.log(`[KSplatLoader] Loaded ${D} splats.`),new qe({gaussianBuffer:_.buffer,shCoefsBuffer:S.buffer,numPoints:f,shDegree:H,bbox:{min:[M,j,F],max:[I,E,R]},center:[fe,ne,te],up:[0,1,0]})}canHandle(e){return e.toLowerCase().endsWith(".ksplat")}getSupportedExtensions(){return[".ksplat"]}fromHalf(e){const t=(e&32768)>>15,s=(e&31744)>>10,n=e&1023;return s===0?(t?-1:1)*Math.pow(2,-14)*(n/1024):s===31?n?NaN:t?-1/0:1/0:(t?-1:1)*Math.pow(2,s-15)*(1+n/1024)}}class Gn{async loadFile(e,t){return this.loadBuffer(await e.arrayBuffer(),t)}async loadUrl(e,t){const s=await fetch(e,{signal:t?.signal});if(!s.ok)throw new Error(`Failed to fetch: ${s.statusText}`);return this.loadBuffer(await s.arrayBuffer(),t)}async loadBuffer(e,t){const s=(y,_,P)=>{t?.onProgress?.({stage:y,progress:_,message:P})};s("Parsing SPLAT",.1);const n=32,o=new DataView(e),i=Math.floor(e.byteLength/n);e.byteLength%n!==0&&console.warn("SPLAT file size not aligned to 32 bytes, truncating"),s("Loading SPLAT data",.3);const r=10,l=new Uint16Array(i*r),u=24,d=new Uint32Array(i*u),f=.28209479177387814,h=[1/0,1/0,1/0],m=[-1/0,-1/0,-1/0],p=[];for(let y=0;y<i;y++){y%5e3===0&&s("Processing SPLAT points",.3+.5*(y/i));let _=y*n;const P=o.getFloat32(_,!0);_+=4;const S=o.getFloat32(_,!0);_+=4;const M=o.getFloat32(_,!0);_+=4,p.push([P,S,M]);const j=o.getFloat32(_,!0);_+=4;const F=o.getFloat32(_,!0);_+=4;const I=o.getFloat32(_,!0);_+=4;const E=o.getUint8(_++)/255,R=o.getUint8(_++)/255,z=o.getUint8(_++)/255,Y=o.getUint8(_++)/255,ee=o.getUint8(_++)/255*2-1,J=o.getUint8(_++)/255*2-1,D=o.getUint8(_++)/255*2-1,H=o.getUint8(_++)/255*2-1,K=c.quat.fromValues(ee,J,D,H);c.quat.normalize(K,K);const ue=new Float32Array([j,F,I]),[Z,ie,fe,ne,te,N]=Ve(K,ue),U=y*r;l[U+0]=w(P),l[U+1]=w(S),l[U+2]=w(M),l[U+3]=w(Y),l[U+4]=w(Z),l[U+5]=w(ie),l[U+6]=w(fe),l[U+7]=w(ne),l[U+8]=w(te),l[U+9]=w(N);const T=y*u,g=(E-.5)/f,x=(R-.5)/f,B=(z-.5)/f,C=w(g),O=w(x),$=w(B);d[T+0]=C|O<<16,d[T+1]=$,h[0]=Math.min(h[0],P),h[1]=Math.min(h[1],S),h[2]=Math.min(h[2],M),m[0]=Math.max(m[0],P),m[1]=Math.max(m[1],S),m[2]=Math.max(m[2],M)}s("Computing geometry",.9);const{centroid:v,normal:b}=Mt(p);return new qe({gaussianBuffer:l.buffer,shCoefsBuffer:d.buffer,numPoints:i,shDegree:0,bbox:{min:h,max:m},center:[v[0],v[1],v[2]],up:b?[b[0],b[1],b[2]]:[1,0,0]})}canHandle(e){return e.toLowerCase().endsWith(".splat")}getSupportedExtensions(){return[".splat"]}}var Ts={},An=(function(a,e,t,s,n){var o=new Worker(Ts[e]||(Ts[e]=URL.createObjectURL(new Blob([a+';addEventListener("error",function(e){e=e.error;postMessage({$e$:[e.message,e.code,e.stack]})})'],{type:"text/javascript"}))));return o.onmessage=function(i){var r=i.data,l=r.$e$;if(l){var u=new Error(l[0]);u.code=l[1],u.stack=l[2],n(u,null)}else n(null,r)},o.postMessage(t,s),o}),ge=Uint8Array,He=Uint16Array,Us=Int32Array,Dt=new ge([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),Ot=new ge([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),Bs=new ge([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),Gs=function(a,e){for(var t=new He(31),s=0;s<31;++s)t[s]=e+=1<<a[s-1];for(var n=new Us(t[30]),s=1;s<30;++s)for(var o=t[s];o<t[s+1];++o)n[o]=o-t[s]<<5|s;return{b:t,r:n}},As=Gs(Dt,2),zt=As.b,En=As.r;zt[28]=258,En[258]=28;for(var kn=Gs(Ot,0),Es=kn.b,yt=new He(32768),Q=0;Q<32768;++Q){var Re=(Q&43690)>>1|(Q&21845)<<1;Re=(Re&52428)>>2|(Re&13107)<<2,Re=(Re&61680)>>4|(Re&3855)<<4,yt[Q]=((Re&65280)>>8|(Re&255)<<8)>>1}for(var Ke=(function(a,e,t){for(var s=a.length,n=0,o=new He(e);n<s;++n)a[n]&&++o[a[n]-1];var i=new He(e);for(n=1;n<e;++n)i[n]=i[n-1]+o[n-1]<<1;var r;if(t){r=new He(1<<e);var l=15-e;for(n=0;n<s;++n)if(a[n])for(var u=n<<4|a[n],d=e-a[n],f=i[a[n]-1]++<<d,h=f|(1<<d)-1;f<=h;++f)r[yt[f]>>l]=u}else for(r=new He(s),n=0;n<s;++n)a[n]&&(r[n]=yt[i[a[n]-1]++]>>15-a[n]);return r}),nt=new ge(288),Q=0;Q<144;++Q)nt[Q]=8;for(var Q=144;Q<256;++Q)nt[Q]=9;for(var Q=256;Q<280;++Q)nt[Q]=7;for(var Q=280;Q<288;++Q)nt[Q]=8;for(var ks=new ge(32),Q=0;Q<32;++Q)ks[Q]=5;var Fs=Ke(nt,9,1),Ls=Ke(ks,5,1),_t=function(a){for(var e=a[0],t=1;t<a.length;++t)a[t]>e&&(e=a[t]);return e},Ce=function(a,e,t){var s=e/8|0;return(a[s]|a[s+1]<<8)>>(e&7)&t},wt=function(a,e){var t=e/8|0;return(a[t]|a[t+1]<<8|a[t+2]<<16)>>(e&7)},Rs=function(a){return(a+7)/8|0},bt=function(a,e,t){return(e==null||e<0)&&(e=0),(t==null||t>a.length)&&(t=a.length),new ge(a.subarray(e,t))},Ds=["unexpected EOF","invalid block type","invalid length/literal","invalid distance","stream finished","no stream handler",,"no callback","invalid UTF-8 data","extra field too long","date not in range 1980-2099","filename too long","stream finishing","invalid zip data"],ye=function(a,e,t){var s=new Error(e||Ds[a]);if(s.code=a,Error.captureStackTrace&&Error.captureStackTrace(s,ye),!t)throw s;return s},Os=function(a,e,t,s){var n=a.length,o=s?s.length:0;if(!n||e.f&&!e.l)return t||new ge(0);var i=!t,r=i||e.i!=2,l=e.i;i&&(t=new ge(n*3));var u=function(O){var $=t.length;if(O>$){var k=new ge(Math.max($*2,O));k.set(t),t=k}},d=e.f||0,f=e.p||0,h=e.b||0,m=e.l,p=e.d,v=e.m,b=e.n,y=n*8;do{if(!m){d=Ce(a,f,1);var _=Ce(a,f+1,3);if(f+=3,_)if(_==1)m=Fs,p=Ls,v=9,b=5;else if(_==2){var j=Ce(a,f,31)+257,F=Ce(a,f+10,15)+4,I=j+Ce(a,f+5,31)+1;f+=14;for(var E=new ge(I),R=new ge(19),z=0;z<F;++z)R[Bs[z]]=Ce(a,f+z*3,7);f+=F*3;for(var Y=_t(R),ee=(1<<Y)-1,J=Ke(R,Y,1),z=0;z<I;){var D=J[Ce(a,f,ee)];f+=D&15;var P=D>>4;if(P<16)E[z++]=P;else{var H=0,K=0;for(P==16?(K=3+Ce(a,f,3),f+=2,H=E[z-1]):P==17?(K=3+Ce(a,f,7),f+=3):P==18&&(K=11+Ce(a,f,127),f+=7);K--;)E[z++]=H}}var ue=E.subarray(0,j),Z=E.subarray(j);v=_t(ue),b=_t(Z),m=Ke(ue,v,1),p=Ke(Z,b,1)}else ye(1);else{var P=Rs(f)+4,S=a[P-4]|a[P-3]<<8,M=P+S;if(M>n){l&&ye(0);break}r&&u(h+S),t.set(a.subarray(P,M),h),e.b=h+=S,e.p=f=M*8,e.f=d;continue}if(f>y){l&&ye(0);break}}r&&u(h+131072);for(var ie=(1<<v)-1,fe=(1<<b)-1,ne=f;;ne=f){var H=m[wt(a,f)&ie],te=H>>4;if(f+=H&15,f>y){l&&ye(0);break}if(H||ye(2),te<256)t[h++]=te;else if(te==256){ne=f,m=null;break}else{var N=te-254;if(te>264){var z=te-257,U=Dt[z];N=Ce(a,f,(1<<U)-1)+zt[z],f+=U}var T=p[wt(a,f)&fe],g=T>>4;T||ye(3),f+=T&15;var Z=Es[g];if(g>3){var U=Ot[g];Z+=wt(a,f)&(1<<U)-1,f+=U}if(f>y){l&&ye(0);break}r&&u(h+131072);var x=h+N;if(h<Z){var B=o-Z,C=Math.min(Z,x);for(B+h<0&&ye(3);h<C;++h)t[h]=s[B+h]}for(;h<x;++h)t[h]=t[h-Z]}}e.l=m,e.p=ne,e.b=h,e.f=d,m&&(d=1,e.m=v,e.d=p,e.n=b)}while(!d);return h!=t.length&&i?bt(t,0,h):t.subarray(0,h)},Fn=new ge(0),Ln=function(a,e){var t={};for(var s in a)t[s]=a[s];for(var s in e)t[s]=e[s];return t},zs=function(a,e,t){for(var s=a(),n=a.toString(),o=n.slice(n.indexOf("[")+1,n.lastIndexOf("]")).replace(/\s+/g,"").split(","),i=0;i<s.length;++i){var r=s[i],l=o[i];if(typeof r=="function"){e+=";"+l+"=";var u=r.toString();if(r.prototype)if(u.indexOf("[native code]")!=-1){var d=u.indexOf(" ",8)+1;e+=u.slice(d,u.indexOf("(",d))}else{e+=u;for(var f in r.prototype)e+=";"+l+".prototype."+f+"="+r.prototype[f].toString()}else e+=u}else t[l]=r}return e},vt=[],Rn=function(a){var e=[];for(var t in a)a[t].buffer&&e.push((a[t]=new a[t].constructor(a[t])).buffer);return e},Dn=function(a,e,t,s){if(!vt[t]){for(var n="",o={},i=a.length-1,r=0;r<i;++r)n=zs(a[r],n,o);vt[t]={c:zs(a[i],n,o),e:o}}var l=Ln({},vt[t].e);return An(vt[t].c+";onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage="+e.toString()+"}",t,l,Rn(l),s)},On=function(){return[ge,He,Us,Dt,Ot,Bs,zt,Es,Fs,Ls,yt,Ds,Ke,_t,Ce,wt,Rs,bt,ye,Os,It,$s,Is]},$s=function(a){return postMessage(a,[a.buffer])},Is=function(a){return a&&{out:a.size&&new ge(a.size),dictionary:a.dictionary}},zn=function(a,e,t,s,n,o){var i=Dn(t,s,n,function(r,l){i.terminate(),o(r,l)});return i.postMessage([a,e],e.consume?[a.buffer]:[]),function(){i.terminate()}},Ge=function(a,e){return a[e]|a[e+1]<<8},Te=function(a,e){return(a[e]|a[e+1]<<8|a[e+2]<<16|a[e+3]<<24)>>>0},$t=function(a,e){return Te(a,e)+Te(a,e+4)*4294967296};function $n(a,e,t){return t||(t=e,e={}),typeof t!="function"&&ye(7),zn(a,e,[On],function(s){return $s(It(s.data[0],Is(s.data[1])))},1,t)}function It(a,e){return Os(a,{i:2},e&&e.out,e&&e.dictionary)}var Nt=typeof TextDecoder<"u"&&new TextDecoder,In=0;try{Nt.decode(Fn,{stream:!0}),In=1}catch{}var Nn=function(a){for(var e="",t=0;;){var s=a[t++],n=(s>127)+(s>223)+(s>239);if(t+n>a.length)return{s:e,r:bt(a,t-1)};n?n==3?(s=((s&15)<<18|(a[t++]&63)<<12|(a[t++]&63)<<6|a[t++]&63)-65536,e+=String.fromCharCode(55296|s>>10,56320|s&1023)):n&1?e+=String.fromCharCode((s&31)<<6|a[t++]&63):e+=String.fromCharCode((s&15)<<12|(a[t++]&63)<<6|a[t++]&63):e+=String.fromCharCode(s)}};function Vn(a,e){if(e){for(var t="",s=0;s<a.length;s+=16384)t+=String.fromCharCode.apply(null,a.subarray(s,s+16384));return t}else{if(Nt)return Nt.decode(a);var n=Nn(a),o=n.s,t=n.r;return t.length&&ye(8),o}}var Wn=function(a,e){return e+30+Ge(a,e+26)+Ge(a,e+28)},jn=function(a,e,t){var s=Ge(a,e+28),n=Vn(a.subarray(e+46,e+46+s),!(Ge(a,e+8)&2048)),o=e+46+s,i=Te(a,e+20),r=t&&i==4294967295?qn(a,o):[i,Te(a,e+24),Te(a,e+42)],l=r[0],u=r[1],d=r[2];return[Ge(a,e+10),l,u,n,o+Ge(a,e+30)+Ge(a,e+32),d]},qn=function(a,e){for(;Ge(a,e)!=1;e+=4+Ge(a,e+2));return[$t(a,e+12),$t(a,e+4),$t(a,e+20)]},Ns=typeof queueMicrotask=="function"?queueMicrotask:typeof setTimeout=="function"?setTimeout:function(a){a()};function Hn(a,e,t){t||(t=e,e={}),typeof t!="function"&&ye(7);var s=[],n=function(){for(var b=0;b<s.length;++b)s[b]()},o={},i=function(b,y){Ns(function(){t(b,y)})};Ns(function(){i=t});for(var r=a.length-22;Te(a,r)!=101010256;--r)if(!r||a.length-r>65558)return i(ye(13,0,1),null),n;var l=Ge(a,r+8);if(l){var u=l,d=Te(a,r+16),f=d==4294967295||u==65535;if(f){var h=Te(a,r-12);f=Te(a,h)==101075792,f&&(u=l=Te(a,h+32),d=Te(a,h+48))}for(var m=e&&e.filter,p=function(b){var y=jn(a,d,f),_=y[0],P=y[1],S=y[2],M=y[3],j=y[4],F=y[5],I=Wn(a,F);d=j;var E=function(z,Y){z?(n(),i(z,null)):(Y&&(o[M]=Y),--l||i(null,o))};if(!m||m({name:M,size:P,originalSize:S,compression:_}))if(!_)E(null,bt(a,I,I+P));else if(_==8){var R=a.subarray(I,I+P);if(S<524288||P>.8*S)try{E(null,It(R,{out:new ge(S)}))}catch(z){E(z,null)}else s.push($n(R,{size:S},E))}else E(ye(14,"unknown compression type "+_,1),null);else E(null,null)},v=0;v<u;++v)p(v)}else i(null,{});return n}class Xn{async loadFile(e,t){return this.loadBuffer(await e.arrayBuffer(),t)}async loadUrl(e,t){const s=await fetch(e,{signal:t?.signal});if(!s.ok)throw new Error(`Failed to fetch SOG: ${s.statusText}`);return this.loadBuffer(await s.arrayBuffer(),t)}async loadBuffer(e,t){return new DataView(e).getUint32(0,!0)===67324752?this.loadCompressedSOG(e,t):this.loadRawSOG(e,t)}async loadRawSOG(e,t){const s=(Y,ee,J)=>{t?.onProgress?.({stage:Y,progress:ee,message:J})};s("Parsing SOG header",.1);const n=new DataView(e);let o=0;const i=n.getUint32(o,!0);if(o+=4,i!==1397704448&&i!==4673363)throw new Error("Invalid SOG file");const r=n.getUint32(o,!0);o+=4;const l=n.getUint32(o,!0);o+=4;const u=n.getUint32(o,!0);o+=4,console.log(`[SOGLoader] Ver:${r}, Points:${l}, SH Degree:${u}`),s("Loading SOG data",.3);const d=10,f=new Uint16Array(l*d),h=24,m=new Uint32Array(l*h);let p=1/0,v=1/0,b=1/0,y=-1/0,_=-1/0,P=-1/0,S=0,M=0,j=0;const F=c.quat.create(),I=c.vec3.create();for(let Y=0;Y<l;Y++){Y%1e4===0&&s("Processing SOG points",.3+.6*(Y/l));const ee=n.getFloat32(o,!0);o+=4;const J=n.getFloat32(o,!0);o+=4;const D=n.getFloat32(o,!0);o+=4;const H=n.getFloat32(o,!0);o+=4;const K=n.getFloat32(o,!0);o+=4;const ue=n.getFloat32(o,!0);o+=4;const Z=Math.exp(H),ie=Math.exp(K),fe=Math.exp(ue),ne=n.getFloat32(o,!0);o+=4;const te=n.getFloat32(o,!0);o+=4;const N=n.getFloat32(o,!0);o+=4;const U=n.getFloat32(o,!0);o+=4;const T=n.getFloat32(o,!0);o+=4;const g=cs(T);c.quat.set(F,te,N,U,ne),c.quat.normalize(F,F),c.vec3.set(I,Z,ie,fe);const[x,B,C,O,$,k]=Ve(F,I),X=Y*d;f[X+0]=w(ee),f[X+1]=w(J),f[X+2]=w(D),f[X+3]=w(g),f[X+4]=w(x),f[X+5]=w(B),f[X+6]=w(C),f[X+7]=w(O),f[X+8]=w($),f[X+9]=w(k);const ce=3*Math.pow(u+1,2),de=Y*h;for(let oe=0;oe<ce&&oe<h*2;oe++){const L=n.getFloat32(o,!0);o+=4;const _e=w(L),we=Math.floor(oe/2);oe%2===1?m[de+we]|=_e<<16:m[de+we]=_e}if(ce>h*2){const oe=ce-h*2;o+=oe*4}p=Math.min(p,ee),y=Math.max(y,ee),v=Math.min(v,J),_=Math.max(_,J),b=Math.min(b,D),P=Math.max(P,D),S+=ee,M+=J,j+=D}s("Finalizing",.9);const E=S/l,R=M/l,z=j/l;return new qe({gaussianBuffer:f.buffer,shCoefsBuffer:m.buffer,numPoints:l,shDegree:u,bbox:{min:[p,v,b],max:[y,_,P]},center:[E,R,z],up:[0,1,0]})}async loadCompressedSOG(e,t){const s=(T,g)=>t?.onProgress?.({stage:"SOG-WebP",progress:T,message:g});s(.1,"Unzipping SOG");const n=await new Promise((T,g)=>{Hn(new Uint8Array(e),(x,B)=>{x?g(x):T(B)})});if(!n["meta.json"])throw new Error("Invalid SOG ZIP: missing meta.json");const o=JSON.parse(new TextDecoder().decode(n["meta.json"])),i=o.count;console.log(`[SOGLoader] Compressed SOG, Points: ${i}`);const r=async T=>{if(!n[T])throw new Error(`Missing texture: ${T}`);const g=new Blob([new Uint8Array(n[T])],{type:"image/webp"}),x=await createImageBitmap(g);let B;const{width:C,height:O}=x;if(typeof OffscreenCanvas<"u"){B=new OffscreenCanvas(C,O).getContext("2d"),B?.drawImage(x,0,0);const k=B?.getImageData(0,0,C,O);return{data:new Uint8Array(k.data.buffer),width:C,height:O}}else{const $=document.createElement("canvas");$.width=C,$.height=O,B=$.getContext("2d"),B?.drawImage(x,0,0);const k=B?.getImageData(0,0,C,O);return{data:new Uint8Array(k.data.buffer),width:C,height:O}}};s(.2,"Decoding Base Textures");const[l,u,d,f,h]=await Promise.all([r(o.means.files[0]),r(o.means.files[1]),r(o.quats.files[0]),r(o.scales.files[0]),r(o.sh0.files[0])]);let m=0,p=null,v=null,b=0,y=[],_=null;if(o.shN){const T=o.shN;m=T.bands,console.log(`[SOGLoader] Found shN (Vector Quantized). Degree: ${m}`),s(.4,"Decoding SH Vector Tables");let g;[v,g]=await Promise.all([r(T.files[1]),r(T.files[0])]);const x=new Float32Array(T.codebook),B=T.count,C=m===3?15:m===2?8:3;b=C*3,p=new Float32Array(B*b);const O=g.data;for(let $=0;$<B;$++)for(let k=0;k<C;k++){const X=($*C+k)*4,ce=O[X+0],de=O[X+1],oe=O[X+2],L=$*b+k*3;p[L+0]=x[ce],p[L+1]=x[de],p[L+2]=x[oe]}}else if(o.sh_rest&&o.sh_rest.files.length>0){console.log("[SOGLoader] Found sh_rest (Scalar Quantized)."),_=new Float32Array(o.sh_rest.codebook),y=await Promise.all(o.sh_rest.files.map(g=>r(g)));const T=3+y.length*3;m=Math.round(Math.sqrt(T/3)-1)}else console.log("[SOGLoader] No high-order SH data. Degree: 0");const P=10,S=new Uint16Array(i*P),M=24,j=new Uint32Array(i*M),F=c.quat.create(),I=c.vec3.create(),E=o.means.mins[0],R=o.means.maxs[0]-E||1,z=o.means.mins[1],Y=o.means.maxs[1]-z||1,ee=o.means.mins[2],J=o.means.maxs[2]-ee||1,D=new Float32Array(o.scales.codebook),H=new Float32Array(o.sh0.codebook);let K=1/0,ue=1/0,Z=1/0,ie=-1/0,fe=-1/0,ne=-1/0,te=0,N=0,U=0;s(.6,"Reconstructing Gaussians");for(let T=0;T<i;T++){T%5e4===0&&s(.6+.3*(T/i),"Reconstructing...");const g=T*4,x=l.data[g+0]|u.data[g+0]<<8,B=l.data[g+1]|u.data[g+1]<<8,C=l.data[g+2]|u.data[g+2]<<8,O=this.invLogTransform(E+R*(x/65535)),$=this.invLogTransform(z+Y*(B/65535)),k=this.invLogTransform(ee+J*(C/65535)),X=d.data[g+3];this.unpackQuatToRef(d.data[g],d.data[g+1],d.data[g+2],X,F);const ce=Math.exp(D[f.data[g+0]]),de=Math.exp(D[f.data[g+1]]),oe=Math.exp(D[f.data[g+2]]);c.vec3.set(I,ce,de,oe);const[L,_e,we,Ue,ze,he]=Ve(F,I),ke=h.data[g+3]/255,W=T*P;S[W+0]=w(O),S[W+1]=w($),S[W+2]=w(k),S[W+3]=w(ke),S[W+4]=w(L),S[W+5]=w(_e),S[W+6]=w(we),S[W+7]=w(Ue),S[W+8]=w(ze),S[W+9]=w(he);let A=T*M,re=0;const se=ae=>{const le=w(ae),me=A+(re>>1);(re&1)===1?j[me]|=le<<16:j[me]=le,re++};if(se(H[h.data[g+0]]),se(H[h.data[g+1]]),se(H[h.data[g+2]]),p&&v){const ae=T*4,le=v.data[ae+0],me=v.data[ae+1],q=(le|me<<8)*b;for(let Se=0;Se<b;Se++)se(p[q+Se])}else if(_&&y.length>0)for(let ae=0;ae<y.length;ae++){const le=y[ae].data;se(_[le[g+0]]),se(_[le[g+1]]),se(_[le[g+2]])}K=Math.min(K,O),ie=Math.max(ie,O),ue=Math.min(ue,$),fe=Math.max(fe,$),Z=Math.min(Z,k),ne=Math.max(ne,k),te+=O,N+=$,U+=k}return new qe({gaussianBuffer:S.buffer,shCoefsBuffer:j.buffer,numPoints:i,shDegree:m,bbox:{min:[K,ue,Z],max:[ie,fe,ne]},center:[te/i,N/i,U/i],up:[0,1,0]})}invLogTransform(e){const t=Math.abs(e),s=Math.exp(t)-1;return e<0?-s:s}unpackQuatToRef(e,t,s,n,o){const i=n-252;if(i<0||i>3){c.quat.set(o,0,0,0,1);return}const r=e/255*2-1,l=t/255*2-1,u=s/255*2-1,d=1.41421356;let f=0,h=0,m=0,p=0;i===0?(h=r/d,m=l/d,p=u/d,f=Math.sqrt(Math.max(0,1-(h*h+m*m+p*p)))):i===1?(f=r/d,m=l/d,p=u/d,h=Math.sqrt(Math.max(0,1-(f*f+m*m+p*p)))):i===2?(f=r/d,h=l/d,p=u/d,m=Math.sqrt(Math.max(0,1-(f*f+h*h+p*p)))):(f=r/d,h=l/d,m=u/d,p=Math.sqrt(Math.max(0,1-(f*f+h*h+m*m)))),c.quat.set(o,h,m,p,f),c.quat.normalize(o,o)}canHandle(e){return e.toLowerCase().endsWith(".sog")}getSupportedExtensions(){return[".sog"]}}class Vt{static CHUNK_SIZE=256;async loadFile(e,t){const s=await e.arrayBuffer();return this.loadBuffer(s,t)}async loadUrl(e,t){const s=await fetch(e,{signal:t?.signal});if(!s.ok)throw new Error(`Failed to fetch compressed PLY: ${s.status}`);const n=await s.arrayBuffer();return this.loadBuffer(n,t)}canHandle(e){return e.toLowerCase().endsWith(".compressed.ply")}getSupportedExtensions(){return[".compressed.ply"]}async loadBuffer(e,t){const s=new TextDecoder().decode(e.slice(0,Math.min(1048576,e.byteLength))),n=s.indexOf("end_header")+10+1,o=s.slice(0,n).split(/\r?\n/);let i="binary_little_endian",r=0,l=0,u=0,d=!1;for(const g of o)g.startsWith("format ")&&(g.includes("binary_little_endian")?i="binary_little_endian":g.includes("binary_big_endian")&&(i="binary_big_endian")),g.startsWith("element vertex")&&(r=parseInt(g.split(/\s+/)[2])),g.startsWith("element chunk")&&(l=parseInt(g.split(/\s+/)[2])),g.startsWith("element sh")?d=!0:d&&g.startsWith("property")?u++:d&&g.startsWith("element")&&(d=!1);const f=i==="binary_little_endian",h=new DataView(e,n),m=72,p=[];for(let g=0;g<l;g++){const x=g*m;p.push({minPos:[h.getFloat32(x+0,f),h.getFloat32(x+4,f),h.getFloat32(x+8,f)],maxPos:[h.getFloat32(x+12,f),h.getFloat32(x+16,f),h.getFloat32(x+20,f)],minScale:[h.getFloat32(x+24,f),h.getFloat32(x+28,f),h.getFloat32(x+32,f)],maxScale:[h.getFloat32(x+36,f),h.getFloat32(x+40,f),h.getFloat32(x+44,f)],minColor:[h.getFloat32(x+48,f),h.getFloat32(x+52,f),h.getFloat32(x+56,f)],maxColor:[h.getFloat32(x+60,f),h.getFloat32(x+64,f),h.getFloat32(x+68,f)]})}const v=l*m,b=16,y=v+r*b,_=u,P=10;let S,M;u===9?(S=1,M=12):u===24?(S=2,M=27):u===45?(S=3,M=48):(S=0,M=3);const j=Math.ceil(M/2),F=new Uint16Array(r*P),I=new Uint32Array(r*j);let E=1/0,R=1/0,z=1/0,Y=-1/0,ee=-1/0,J=-1/0;const D=(g,x,B)=>g*(1-B)+x*B,H=(g,x)=>{const B=(1<<x)-1;return(g&B)/B},K=g=>({x:H(g>>>21,11),y:H(g>>>11,10),z:H(g,11)}),ue=g=>({r:H(g>>>24,8),g:H(g>>>16,8),b:H(g>>>8,8),a:H(g,8)}),Z=g=>{const x=1/(Math.sqrt(2)*.5),B=(H(g>>>20,10)-.5)*x,C=(H(g>>>10,10)-.5)*x,O=(H(g,10)-.5)*x,$=Math.sqrt(Math.max(0,1-(B*B+C*C+O*O)));switch(g>>>30){case 0:return{w:$,x:B,y:C,z:O};case 1:return{w:B,x:$,y:C,z:O};case 2:return{w:B,x:C,y:$,z:O};default:return{w:B,x:C,y:O,z:$}}},ie=.28209479177387814,fe=(g,x,B)=>{const C=new Float32Array(M);C[0]=(x[0]-.5)/ie,C[1]=(x[1]-.5)/ie,C[2]=(x[2]-.5)/ie;const O=B.length/3;for(let k=0;k<O;k++){const X=3+k*3;if(X+2>=C.length)break;const ce=k,de=k+O,oe=k+O*2,L=B[ce],_e=B[de],we=B[oe];C[X+0]=(L/255-.5)*8,C[X+1]=(_e/255-.5)*8,C[X+2]=(we/255-.5)*8}const $=g*j;for(let k=0;k<C.length;k+=2){const X=w(C[k]),ce=k+1<C.length?w(C[k+1]):0;I[$+(k>>1)]=ce<<16|X}},ne=c.quat.create(),te=c.vec3.create();for(let g=0;g<r;g++){const x=v+g*b,B=y+g*_,C=Math.floor(g/Vt.CHUNK_SIZE),O=h.getUint32(x+0,f),$=h.getUint32(x+4,f),k=h.getUint32(x+8,f),X=h.getUint32(x+12,f),ce=K(O),de=Z($),oe=K(k),L=ue(X),_e=D(p[C].minPos[0],p[C].maxPos[0],ce.x),we=D(p[C].minPos[1],p[C].maxPos[1],ce.y),Ue=D(p[C].minPos[2],p[C].maxPos[2],ce.z),ze=D(p[C].minScale[0],p[C].maxScale[0],oe.x),he=D(p[C].minScale[1],p[C].maxScale[1],oe.y),ke=D(p[C].minScale[2],p[C].maxScale[2],oe.z),W=Math.exp(ze),A=Math.exp(he),re=Math.exp(ke),se=D(p[C].minColor[0],p[C].maxColor[0],L.r),ae=D(p[C].minColor[1],p[C].maxColor[1],L.g),le=D(p[C].minColor[2],p[C].maxColor[2],L.b),me=[se,ae,le],Me=L.a;c.quat.set(ne,de.x,de.y,de.z,de.w),c.vec3.set(te,W,A,re),c.quat.normalize(ne,ne);const[q,Se,Ae,ve,$e,Xe]=Ve(ne,te),pe=g*P;F[pe+0]=w(_e),F[pe+1]=w(we),F[pe+2]=w(Ue),F[pe+3]=w(Me),F[pe+4]=w(q),F[pe+5]=w(Se),F[pe+6]=w(Ae),F[pe+7]=w(ve),F[pe+8]=w($e),F[pe+9]=w(Xe);const Ye=new Uint8Array(e,n+B,_);fe(g,me,Ye),E=Math.min(E,_e),R=Math.min(R,we),z=Math.min(z,Ue),Y=Math.max(Y,_e),ee=Math.max(ee,we),J=Math.max(J,Ue)}const N=[E,R,z],U=[Y,ee,J],T=[(E+Y)/2,(R+ee)/2,(z+J)/2];return new qe({gaussianBuffer:F.buffer,shCoefsBuffer:I.buffer,numPoints:r,shDegree:S,bbox:{min:N,max:U},center:T,up:[0,1,0]})}}class Wt{_object3D;_bbox;_modelType;constructor(e,t="unknown"){this._object3D=e,this._modelType=t,this._bbox=this.calculateBoundingBox(e)}object3D(){return this._object3D}modelType(){return this._modelType}bbox(){return this._bbox}calculateBoundingBox(e){const t=new G.Box3().setFromObject(e);return{min:[t.min.x,t.min.y,t.min.z],max:[t.max.x,t.max.y,t.max.z]}}}class ot{loader;constructor(e){this.loader=e}applyShadowsAndMaterial(e,t){e.traverse(s=>{s&&s.isMesh&&(!s.material&&t&&(s.material=t),"castShadow"in s&&(s.castShadow=!0),"receiveShadow"in s&&(s.receiveShadow=!0))})}async loadFile(e,t){const s=URL.createObjectURL(e);try{const n=await this.loadFromUrl(s,t);return new Wt(n,this.getModelType())}finally{URL.revokeObjectURL(s)}}async loadUrl(e,t){const s=await this.loadFromUrl(e,t);return new Wt(s,this.getModelType())}async loadBuffer(e,t){throw new Error("Buffer loading not supported for Three.js models")}canHandle(e,t){return this.getSupportedExtensions().some(s=>e.toLowerCase().endsWith(s))}}class Yn extends ot{constructor(){super(new en.GLTFLoader)}getSupportedExtensions(){return[".gltf",".glb"]}getModelType(){return"gltf"}async loadFromUrl(e,t){return new Promise((s,n)=>{this.loader.load(e,o=>{this.applyShadowsAndMaterial(o.scene),s(o.scene)},o=>{t?.onProgress&&t.onProgress({progress:o.loaded/o.total,stage:"Loading GLTF/GLB..."})},n)})}}class Jn extends ot{constructor(){super(new tn.OBJLoader)}getSupportedExtensions(){return[".obj"]}getModelType(){return"obj"}async loadFromUrl(e,t){return new Promise((s,n)=>{this.loader.load(e,o=>{this.applyShadowsAndMaterial(o),s(o)},o=>{t?.onProgress&&t.onProgress({progress:o.loaded/o.total,stage:"Loading OBJ..."})},n)})}}class Kn extends ot{constructor(){super(new as.FBXLoader)}getSupportedExtensions(){return[".fbx"]}getModelType(){return"fbx"}async loadFromUrl(e,t){return new Promise((s,n)=>{this.loader.load(e,o=>{this.applyShadowsAndMaterial(o),s(o)},o=>{t?.onProgress&&t.onProgress({progress:o.loaded/o.total,stage:"Loading FBX..."})},n)})}}class Zn extends ot{constructor(){super(new sn.STLLoader)}getSupportedExtensions(){return[".stl"]}getModelType(){return"stl"}async loadFromUrl(e,t){return new Promise((s,n)=>{this.loader.load(e,o=>{const i=new G.MeshStandardMaterial({color:8947848}),r=new G.Mesh(o,i);this.applyShadowsAndMaterial(r,i),s(r)},o=>{t?.onProgress&&t.onProgress({progress:o.loaded/o.total,stage:"Loading STL..."})},n)})}}class Qn extends ot{constructor(){super(new nn.PLYLoader)}getSupportedExtensions(){return[".ply"]}getModelType(){return"ply"}async loadFromUrl(e,t){return new Promise((s,n)=>{this.loader.load(e,o=>{const i=new G.MeshStandardMaterial({vertexColors:!0}),r=new G.Mesh(o,i);this.applyShadowsAndMaterial(r,i),s(r)},o=>{t?.onProgress&&t.onProgress({progress:o.loaded/o.total,stage:"Loading PLY..."})},n)})}}function eo(){return[new Yn,new Jn,new Kn,new Zn,new Qn]}class to{gaussianLoaders=new Map;threeLoaders=new Map;constructor(){this.register(new Tn,[".ply"],"gaussian"),this.register(new Un,[".spz"],"gaussian"),this.register(new Bn,[".ksplat"],"gaussian"),this.register(new Gn,[".splat"],"gaussian"),this.register(new Xn,[".sog"],"gaussian"),this.register(new Vt,[".compressed.ply"],"gaussian"),eo().forEach(t=>{const s=t.getSupportedExtensions();this.register(t,s,"three")})}register(e,t,s="three"){const n=s==="gaussian"?this.gaussianLoaders:this.threeLoaders;for(const o of t)n.set(o.toLowerCase(),e)}getLoader(e,t,s){const n=e.toLowerCase(),o=this.getFileExtension(n);if(n.endsWith(".compressed.ply"))return this.gaussianLoaders.get(".compressed.ply")||null;s?.isGaussian;const i=s?.isGaussian===!1;if(i)return this.threeLoaders.get(o)||null;let r=this.gaussianLoaders.get(o);if(r||(r=this.threeLoaders.get(o),r))return r;if(!i){for(const[,l]of this.gaussianLoaders)if(l.canHandle(e,t))return l}for(const[,l]of this.threeLoaders)if(l.canHandle(e,t))return l;return null}async getLoaderForFile(e,t){let s;return e.name.toLowerCase().endsWith(".ply")&&(s=await this.is3dgsPly(e)),this.getLoader(e.name,t,{isGaussian:s})}getAllSupportedExtensions(){const e=new Set;for(const t of this.gaussianLoaders.keys())e.add(t);for(const t of this.threeLoaders.keys())e.add(t);return Array.from(e)}async loadFile(e,t={}){if(t.isGaussian===void 0&&e.name.toLowerCase().endsWith(".ply")){const n=await this.is3dgsPly(e);t.isGaussian=n}const s=this.getLoader(e.name,e.type,t);if(!s)throw new Error(`Unsupported file format: ${e.name}`);return s.loadFile(e,t)}async loadUrl(e,t={}){const s=this.getLoader(e,void 0,t);if(!s)throw new Error(`Unsupported file format for URL: ${e}`);return s.loadUrl(e,t)}async loadBuffer(e,t){const s=this.detectFormatFromBuffer(e);if(!s)throw new Error("Unable to detect file format from buffer");return s.loadBuffer(e,t)}canHandle(e,t,s){return this.getLoader(e,t,s)!==null}getSupportedExtensions(){return this.getAllSupportedExtensions()}getFileExtension(e){const t=e.lastIndexOf(".");return t>=0?e.slice(t).toLowerCase():""}detectFormatFromBuffer(e){const t=new DataView(e),s=new TextDecoder().decode(e.slice(0,100));if(s.startsWith(`ply
`)||s.startsWith(`ply\r
`))return this.is3dgsPlyFromHeader(s)?this.gaussianLoaders.get(".ply")||null:this.threeLoaders.get(".ply")||null;if(e.byteLength>=2){const n=t.getUint8(0),o=t.getUint8(1);if(n===31&&o===139)return this.gaussianLoaders.get(".spz")||null}return e.byteLength>=4&&String.fromCharCode(t.getUint8(0),t.getUint8(1),t.getUint8(2),t.getUint8(3))==="KSPL"?this.gaussianLoaders.get(".ksplat")||null:e.byteLength>=4&&t.getUint32(0,!0)===67324752?this.gaussianLoaders.get(".sog")||null:(e.byteLength>0&&e.byteLength%32,null)}async readFileHeader(e,t=4096){const n=await e.slice(0,t).arrayBuffer();return new TextDecoder("utf-8").decode(n||new ArrayBuffer(0))}async is3dgsPly(e){try{const t=await this.readFileHeader(e),s=this.is3dgsPlyFromHeader(t);return console.log(`PLY æ–‡ä»¶ ${e.name} 3DGS æ£€æµ‹ç»“æœ: ${s}`),s}catch(t){return console.warn("è¯»å– PLY å¤´ä¿¡æ¯å¤±è´¥ï¼ŒæŒ‰é 3DGS å¤„ç†:",e.name,t),!1}}is3dgsPlyFromHeader(e){const t=e.toLowerCase();return t.startsWith("ply")?["property float opacity","property float scale_0","property float scale_1","property float scale_2","property float rot_0","property float rot_1","property float rot_2","property float rot_3"].every(o=>t.includes(o)):!1}}function so(){return new to}const De=so();var it=(a=>(a.PLY="ply",a.SPZ="spz",a.KSPLAT="ksplat",a.SPLAT="splat",a.SOG="sog",a.COMPRESSED_PLY="compressed.ply",a))(it||{});function no(){return[".ply",".spz",".ksplat",".splat",".sog",".compressed.ply"]}function rt(a){const e=a.toLowerCase();return no().some(t=>e.endsWith(t))}function Oe(a){const e=a.toLowerCase();return e.endsWith(".compressed.ply")?"compressed.ply":e.endsWith(".ksplat")?"ksplat":e.endsWith(".splat")?"splat":e.endsWith(".spz")?"spz":e.endsWith(".sog")?"sog":e.endsWith(".ply")?"ply":null}function oo(a){return"gaussianBuffer"in a&&"shCoefsBuffer"in a&&"numPoints"in a&&"shDegree"in a}class jt{object3D;mixer;clips;transform;currentAction=null;isPlaying=!1;isPaused=!1;animationSpeed=1;timeScale=1;timeOffset=0;timeUpdateMode="variable_delta";lastUpdateTime=0;frameTime=0;constructor(e,t,s={}){this.object3D=e,this.clips=t,this.mixer=new G.AnimationMixer(e),this.transform=new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]),this.applyTransform(),t.length>0&&(this.currentAction=this.mixer.clipAction(t[0]),this.currentAction.setLoop(G.LoopRepeat,s.loop?1/0:1),s.autoPlay!==!1&&this.startAnimation(s.defaultSpeed||1))}applyTransform(){const e=new G.Matrix4;e.fromArray(this.transform),this.object3D.matrix.copy(e),this.object3D.matrixAutoUpdate=!1}setTransform(e){this.transform=new Float32Array(e),this.applyTransform()}getVertexCount(){let e=0;return this.object3D.traverse(t=>{if(t instanceof G.Mesh){const s=t.geometry;s.attributes.position&&(e+=s.attributes.position.count)}}),e}setVisible(e){this.object3D.visible=e}getVisible(){return this.object3D.visible}setAnimationTime(e){this.currentAction&&(this.currentAction.time=e,this.mixer.update(0)),this.frameTime=e}setAnimationSpeed(e){this.animationSpeed=e,this.currentAction&&(this.currentAction.timeScale=e*this.timeScale)}getAnimationSpeed(){return this.animationSpeed}startAnimation(e){e!==void 0&&this.setAnimationSpeed(e),this.currentAction&&(this.currentAction.reset(),this.currentAction.play(),this.isPlaying=!0,this.isPaused=!1)}pauseAnimation(){this.currentAction&&(this.currentAction.paused=!0,this.isPaused=!0)}resumeAnimation(){this.currentAction&&(this.currentAction.paused=!1,this.isPaused=!1)}stopAnimation(){this.currentAction&&(this.currentAction.stop(),this.isPlaying=!1,this.isPaused=!1)}setTimeScale(e){this.timeScale=e,this.currentAction&&(this.currentAction.timeScale=this.animationSpeed*e)}getTimeScale(){return this.timeScale}setTimeOffset(e){this.timeOffset=e}getTimeOffset(){return this.timeOffset}setTimeUpdateMode(e){this.timeUpdateMode=e}getTimeUpdateMode(){return this.timeUpdateMode}getCurrentTime(){return this.currentAction?this.currentAction.time:0}supportsAnimation(){return this.clips.length>0}update(e){if(this.isPlaying&&!this.isPaused){const t=e*this.timeScale;this.mixer.update(t),this.frameTime+=t}this.lastUpdateTime=performance.now()}switchToClip(e){return e>=0&&e<this.clips.length?(this.currentAction&&this.currentAction.stop(),this.currentAction=this.mixer.clipAction(this.clips[e]),this.currentAction.setLoop(G.LoopRepeat,1/0),this.currentAction.timeScale=this.animationSpeed*this.timeScale,this.isPlaying&&!this.isPaused&&this.currentAction.play(),!0):!1}getClipInfo(){return this.clips.map(e=>({name:e.name,duration:e.duration}))}dispose(){this.currentAction&&this.currentAction.stop(),this.mixer.stopAllAction(),this.object3D.clear()}}class Vs{loader;modelManager;callbacks;constructor(e,t={}){this.modelManager=e,this.callbacks=t,this.loader=new as.FBXLoader,console.warn("âš ï¸ FBXLoader ä¸ WebGPU æ¸²æŸ“å™¨å¯èƒ½å­˜åœ¨å…¼å®¹æ€§é—®é¢˜ã€‚å¦‚æœåŠ è½½å¤±è´¥ï¼Œå»ºè®®ï¼š"),console.warn("1. å°† FBX æ¨¡å‹è½¬æ¢ä¸º GLTF/GLB æ ¼å¼"),console.warn("2. ä½¿ç”¨ GLTFLoader æ›¿ä»£ FBXLoader"),console.warn("3. æˆ–æš‚æ—¶åˆ‡æ¢åˆ° WebGLRenderer")}async loadFromFile(e,t={}){try{if(this.showProgress(!0,"Loading FBX file...",10),this.modelManager.isAtCapacity())throw this.showProgress(!1),this.showError(`Reached model limit (${this.modelManager.getRemainingCapacity()}). Remove models before adding more.`),new Error("Model limit reached");const s=await this.loadFBXFromFile(e);this.showProgress(!0,"Processing animations...",30);const n=this.extractAnimationClips(s);this.showProgress(!0,"Creating model wrapper...",60);const o=new jt(s,n,t);this.showProgress(!0,"Registering model...",80);const i=e.name.replace(/\.[^/.]+$/,""),r=this.modelManager.generateUniqueName(i),l=this.modelManager.addModel({name:r,visible:!0,pointCloud:o,pointCount:o.getVertexCount(),isDynamic:n.length>0,modelType:"fbx"});return this.showProgress(!1),this.callbacks.onSuccess?.(l),console.log(`FBX model loaded: ${l.name} (${l.pointCount} vertices, ${n.length} animations)`),l}catch(s){this.showProgress(!1);const n=`Failed to load FBX file: ${s.message}`;throw this.showError(n),s}}async loadFromURL(e,t={}){try{if(this.showProgress(!0,"Loading FBX from URL...",10),this.modelManager.isAtCapacity())throw this.showProgress(!1),this.showError(`Reached model limit (${this.modelManager.getRemainingCapacity()}). Remove models before adding more.`),new Error("Model limit reached");const s=await this.loadFBXFromURL(e);this.showProgress(!0,"Processing animations...",30);const n=this.extractAnimationClips(s);this.showProgress(!0,"Creating model wrapper...",60);const o=new jt(s,n,t);this.showProgress(!0,"Registering model...",80);const i=e.split("/").pop()?.replace(/\.[^/.]+$/,"")||"FBX Model",r=this.modelManager.generateUniqueName(i),l=this.modelManager.addModel({name:r,visible:!0,pointCloud:o,pointCount:o.getVertexCount(),isDynamic:n.length>0,modelType:"fbx"});return this.showProgress(!1),this.callbacks.onSuccess?.(l),console.log(`FBX model loaded from URL: ${l.name} (${l.pointCount} vertices, ${n.length} animations)`),l}catch(s){this.showProgress(!1);const n=`Failed to load FBX from URL: ${s.message}`;throw this.showError(n),s}}async loadFBXFromFile(e){return new Promise((t,s)=>{const n=setTimeout(()=>{s(new Error("FBX loading timeout after 30 seconds. This might be due to WebGPU compatibility issues with FBXLoader."))},3e4),o=new FileReader;o.onload=i=>{try{const r=i.target?.result;if(!r)throw new Error("Failed to read file");console.log(`FBX file read successfully, size: ${r.byteLength} bytes`),console.log("Starting FBX parsing...");try{const l=this.loader.parse(r,"");clearTimeout(n),console.log("FBX parsing completed successfully"),t(l)}catch(l){clearTimeout(n),console.error("FBX parsing failed:",l),s(new Error(`FBX parsing error: ${l.message||l}`))}}catch(r){clearTimeout(n),console.error("Error in file read handler:",r),s(r)}},o.onerror=()=>{clearTimeout(n);const i=new Error("Failed to read file");console.error(i),s(i)},console.log(`Reading FBX file: ${e.name}, size: ${e.size} bytes`),o.readAsArrayBuffer(e)})}async loadFBXFromURL(e){return new Promise((t,s)=>{this.loader.load(e,n=>t(n),n=>{const o=n.loaded/n.total*100;this.showProgress(!0,`Loading... ${o.toFixed(1)}%`,o)},n=>s(n))})}extractAnimationClips(e){const t=[];return e.traverse(n=>{n.animations&&n.animations.length>0&&t.push(...n.animations)}),t.filter((n,o,i)=>o===i.findIndex(r=>r.name===n.name))}showProgress(e,t,s){e&&t&&s!==void 0?this.callbacks.onProgress?.(s,t):e||this.callbacks.onProgress?.(0,"")}showError(e){console.error(e),this.callbacks.onError?.(e)}}class qt{modelManager;callbacks;constructor(e,t={}){this.modelManager=e,this.callbacks=t}async loadFile(e,t){try{if(this.showProgress(!0,"Reading file...",10),e.arrayBuffer().then(n=>{console.log("[FileLoader] First 16 bytes:",new Uint8Array(n).slice(0,16))}),this.modelManager.isAtCapacity())return this.showProgress(!1),this.showError(`Reached model limit (${this.modelManager.getRemainingCapacity()}). Remove models before adding more.`),null;const s=e.name.toLowerCase();if(rt(s)){const n=Oe(s);return console.log(`[FileLoader] Loading Gaussian format: ${n}`),await this.loadGaussianFile(e,t)}else return s.endsWith(".onnx")?(this.showError("ONNX files should be loaded through ONNXManager, not FileLoader"),null):s.endsWith(".fbx")?await this.loadFBXFile(e):(this.showProgress(!1),this.showError(`Unsupported file type: ${s}
Supported formats: ${this.getSupportedExtensions().join(", ")}`),null)}catch(s){return this.showProgress(!1),this.showError(s.message),null}}async loadSample(e,t,s){try{if(this.modelManager.isAtCapacity())return this.showError("Reached model limit. Remove models before adding more."),null;console.log("[FileLoader] Loading sample:",e,s?`(expected: ${s})`:"");let n=s;return n||(n=this.detectTypeFromFilename(e)),n&&["ply","gaussian","sog","splat","ksplat","spz","compressed.ply"].includes(n)?await this.loadGaussianUrl(e,t,n):n==="onnx"?(this.showError("ONNX files should be loaded through ONNXManager, not FileLoader"),null):(this.showError(`Unsupported file type: ${e}`),null)}catch(n){return console.error(`[FileLoader] Failed to load sample ${e}:`,n),this.showProgress(!1),this.showError(n.message),null}}detectTypeFromFilename(e){const t=e.toLowerCase();if(rt(t))return"gaussian";if(t.endsWith(".onnx"))return"onnx"}async loadGaussianFile(e,t){const s=Oe(e.name)||"unknown";console.log(`[FileLoader] Loading ${s.toUpperCase()} file:`,e.name);const n=await De.loadFile(e,{onProgress:o=>{this.showProgress(!0,o.stage,o.progress*100)},isGaussian:!0});if(!this.isGaussianDataSource(n))throw new Error(`Loaded data is not a valid Gaussian format: ${e.name}`);return await this.createGaussianModel(n,e.name,t)}async loadGaussianUrl(e,t,s){if(e.startsWith("blob:"))return console.log("[FileLoader] Detected blob URL, using blob-to-file loading path"),await this.loadGaussianFromBlob(e,t,s);const n=Oe(e)||"unknown";console.log(`[FileLoader] Loading ${n.toUpperCase()} from URL:`,e);const o=await De.loadUrl(e,{onProgress:r=>{this.showProgress(!0,r.stage,r.progress*100)}});if(!this.isGaussianDataSource(o))throw new Error(`Loaded data is not a valid Gaussian format: ${e}`);const i=e.split("/").pop()||e;return await this.createGaussianModel(o,i,t)}async loadGaussianFromBlob(e,t,s){console.log(`[FileLoader] Converting blob URL to File object. Hint: ${s}`);try{const n=await fetch(e);if(!n.ok)throw new Error(`Failed to fetch blob: ${n.status} ${n.statusText}`);const o=await n.blob();let i="ply";s&&s!=="gaussian"&&(i=s,console.log("type:",i));const r=`scene-model.${i}`,l=new File([o],r,{type:"application/octet-stream"});return console.log(`[FileLoader] Created File object '${r}' from blob, delegating to loadGaussianFile`),await this.loadGaussianFile(l,t)}catch(n){throw console.error("[FileLoader] Failed to load from blob URL:",n),n}}async createGaussianModel(e,t,s){this.showProgress(!0,"Creating GPU buffers...",60);const{PointCloud:n}=await Promise.resolve().then(()=>ms),o=new n(s,e),i=this.modelManager.generateUniqueName(t),r=Oe(t)||"ply",l=this.modelManager.addModel({name:i,visible:!0,pointCloud:o,pointCount:o.numPoints,isDynamic:!1,modelType:r});return this.showProgress(!0,"Initializing renderer...",90),this.showProgress(!1),console.log(`[FileLoader] Successfully created ${r.toUpperCase()} model:`,i),l}async loadFBXFile(e){try{return await new Vs(this.modelManager,{onProgress:(s,n)=>this.showProgress(!0,n,s),onError:s=>this.showError(s),onSuccess:s=>console.log("[FileLoader] FBX loaded successfully:",s.name)}).loadFromFile(e)}catch(t){return this.showError(`Failed to load FBX file: ${t.message}`),null}}isFileTypeSupported(e){const t=e.toLowerCase();return rt(t)||t.endsWith(".onnx")||t.endsWith(".fbx")}getSupportedExtensions(){return[".ply",".spz",".ksplat",".splat",".sog",".compressed.ply",".onnx",".fbx"]}getFileType(e){const t=e.toLowerCase();return rt(t)?"gaussian":t.endsWith(".onnx")?"onnx":t.endsWith(".fbx")?"fbx":"unknown"}getGaussianFormat(e){return Oe(e)}setCallbacks(e){this.callbacks={...this.callbacks,...e}}showProgress(e,t,s){this.callbacks.onProgress&&this.callbacks.onProgress(e,t,s)}showError(e){this.callbacks.onError?this.callbacks.onError(e):console.error("[FileLoader] Error:",e)}validateFile(e){return e.size>1073741824?{valid:!1,error:"File too large (max 1GB)"}:this.isFileTypeSupported(e.name)?this.modelManager.isAtCapacity()?{valid:!1,error:"Model limit reached. Remove models before adding more."}:{valid:!0}:{valid:!1,error:`Unsupported file type. Supported: ${this.getSupportedExtensions().join(", ")}`}}isGaussianDataSource(e){return oo(e)}}function io(a){return Math.ceil(a/16)*16}function Ht(a,e){const t=a.reduce((s,n)=>s*Math.max(1,n),1);return io(t*e.bytesPerElement)}function Xt(a){return a.dataType}class Yt{static detectOutputPrecisionFromName(e){const t=(e||"").toLowerCase();return t.includes("_f32")||t.includes("_float32")?{dataType:"float32",bytesPerElement:4}:t.includes("_f16")||t.includes("_float16")?{dataType:"float16",bytesPerElement:2}:t.includes("_i8")||t.includes("_int8")?{dataType:"int8",bytesPerElement:1}:t.includes("_u8")||t.includes("_uint8")?{dataType:"uint8",bytesPerElement:1}:{dataType:"float16",bytesPerElement:2}}static detectFromMetadataPreferringNameSuffix(e,t){try{const s=e.outputMetadata;if(s&&typeof s=="object"){const n=r=>s instanceof Map?s.get(r)??s.get(String(r)):Array.isArray(s)&&typeof r=="number"?s[r]:s[r]??s[String(r)],o=s instanceof Map?Array.from(s.values()):Object.keys(s).map(r=>s[r]);let i=t?n(t):void 0;if(!i&&o.length&&(i=o.find(r=>r?.name===t)),!i&&t){const r=e.outputNames,l=Array.isArray(r)?r.findIndex(u=>u===t):-1;l>=0&&(i=n(l))}if(i){const r=i?.type??i?.dataType;if(r){const l=this.mapOrtTypeToPrecision(r);if(l)return l}}}}catch{}return this.detectOutputPrecisionFromName(t)}static mapOrtTypeToPrecision(e){const t=String(e).toLowerCase();if(t.includes("float16")||t==="float16"||t==="tensor(float16)")return{dataType:"float16",bytesPerElement:2};if(t.includes("float32")||t==="float32"||t==="float"||t==="tensor(float)")return{dataType:"float32",bytesPerElement:4};if(t.includes("int8")||t==="int8"||t==="tensor(int8)")return{dataType:"int8",bytesPerElement:1};if(t.includes("uint8")||t==="uint8"||t==="tensor(uint8)")return{dataType:"uint8",bytesPerElement:1}}static extractQuantizationParams(e,t){try{const n=e.model?.graph?.initializer??[];let o,i;for(const r of n){const l=r?.name;if(!l)continue;const u=l.toLowerCase();if(u.includes("scale")&&u.includes(t.toLowerCase())){const d=r?.floatData?.[0]??r?.doubleData?.[0];typeof d=="number"&&(o=d)}if((u.includes("zero")||u.includes("zeropoint"))&&u.includes(t.toLowerCase())){const d=r?.int32Data?.[0]??r?.int64Data?.[0];typeof d=="number"&&(i=d)}}return{scale:o,zeroPoint:i}}catch{return{}}}static calculateBufferSize(e,t){return Ht(e,t)}}let Jt=!1;class at{device;session;verbose=!1;static _runChain=Promise.resolve();static async runExclusive(e){const t=at._runChain;let s;at._runChain=new Promise(n=>s=n);try{await t}catch{}try{const n=await e();return s(),n}catch(n){throw s(),n}}colorMode="sh";colorDim=48;colorOutputName=null;capacity;gaussOutputName=null;gaussFields=10;gaussBuf;shBuf;countBuf;cameraMatrixBuf;projMatrixBuf;timeBuf;maxPoints;get detectedCapacity(){return this.capacity}get detectedGaussOutputName(){return this.gaussOutputName}get detectedGaussFields(){return this.gaussFields}actualPoints;inputNames;gaussianPrecision;colorPrecision;get detectedColorMode(){return this.colorMode}get detectedColorDim(){return this.colorDim}get detectedColorOutputName(){return this.colorOutputName}log(...e){this.verbose&&console.log(...e)}warn(...e){this.verbose&&console.warn(...e)}table(e){this.verbose&&console.table(e)}async init(e){this.device=e.device,this.verbose=e.verbose??!1,this.log("Initializing ONNX Runtime environment...");try{be.env.wasm.numThreads=1,be.env.logLevel="verbose",this.log("isGPUDevice?",e.device&&typeof e.device.createBuffer=="function"&&!!e.device.queue),this.log("ONNX Runtime environment configured with provided WebGPU device")}catch(h){this.warn("ONNX Runtime environment configuration failed:",h)}this.log(`Attempting to create ONNX session with model: ${e.modelUrl}`),this.log(`Model URL type: ${typeof e.modelUrl}`),e.modelUrl&&e.modelUrl.constructor&&this.log(`Model URL constructor: ${e.modelUrl.constructor.name}`),e.modelUrl&&typeof e.modelUrl.toString=="function"&&this.log(`Model URL toString: ${e.modelUrl.toString()}`);let t;if(e.modelUrl)if(typeof e.modelUrl=="string")t=e.modelUrl;else if(typeof e.modelUrl=="object"&&e.modelUrl&&"toString"in e.modelUrl&&typeof e.modelUrl.toString=="function")t=e.modelUrl.toString();else throw new Error(`Invalid modelUrl type: ${typeof e.modelUrl}. Expected string path.`);else throw new Error(`modelUrl is required but was ${e.modelUrl}`);if(!t||t.trim()==="")throw new Error(`modelUrl cannot be empty. Got: "${t}"`);const s=h=>({executionProviders:[{name:"webgpu",deviceId:0,powerPreference:"high-performance"}],graphOptimizationLevel:"extended",preferredOutputLocation:"gpu-buffer",enableGraphCapture:h&&!Jt,enableProfiling:Jt});let n=null;const o=async()=>{if(n)return n;this.log(` Fetching model as ArrayBuffer from: ${t}`);const h=await fetch(t);if(!h.ok)throw new Error(`Failed to fetch model: ${h.status} ${h.statusText}`);const m=await h.arrayBuffer();return this.log(` Model buffer size: ${m.byteLength} bytes`),n=new Uint8Array(m),n},i=async h=>{const m=s(h);this.log(`Creating WebGPU-only ONNX session (graphCapture=${h})...`),this.log(`Using model path: "${t}"`),this.log("Session options:",m);try{this.session=await be.InferenceSession.create(t,m),this.log(" ONNX session created successfully with WebGPU provider");return}catch(p){this.warn(" WebGPU session creation failed, trying ArrayBuffer approach:",p);try{const v=await o();this.session=await be.InferenceSession.create(v,m),this.log(" ONNX session created successfully with WebGPU provider (ArrayBuffer)");return}catch(v){console.error(" WebGPU session creation failed with both path and buffer approaches"),console.error("Path error:",p),console.error("Buffer error:",v);const b=new Error(`WebGPU execution provider required but failed to initialize (graphCapture=${h}). Ensure WebGPU is supported and enabled.`);throw b.pathError=p,b.bufferError=v,b}}};try{await i(!0)}catch(h){const p=`Onnx can not enable WebGPU Graph Capture, system will automatically close this feature and re-initialize.
Error details: ${h instanceof Error?h.message:String(h)}`,v=globalThis?.alert;typeof v=="function"?v(p):console.error(p),this.warn(" Graph Capture initialization failed, retrying without it",h),await i(!1)}this.log(" Using provided WebGPU device to avoid device mismatch"),this.log("ğŸ“‹ Model Input Names:",this.session.inputNames),this.log("ğŸ“‹ Model Output Names:",this.session.outputNames),this.inputNames=this.session.inputNames,await this.detectFromMetadata(),this.maxPoints=this.capacity||e.maxPoints||2e6,this.log(`ğŸ“ Using maxPoints: ${this.maxPoints} (detected: ${this.capacity}, config: ${e.maxPoints})`),await this.detectPrecisions(e.precisionConfig),console.log("gaussianPrecision",this.gaussianPrecision),console.log("gaussianPrecision",this.colorPrecision);const r=Ht([this.maxPoints,10],this.gaussianPrecision),l=Ht([this.maxPoints,this.colorDim],this.colorPrecision);this.log(` Allocating buffers (gauss ${this.gaussianPrecision.dataType}): ${r}B, (color ${this.colorPrecision.dataType}): ${l}B, channels=${this.colorDim}`),this.log(` Color mode: ${this.colorMode}, output name: '${this.colorOutputName}'`);const u=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST|GPUBufferUsage.VERTEX;this.gaussBuf=this.device.createBuffer({size:r,usage:u,label:`gaussian_${this.gaussianPrecision.dataType}`}),this.shBuf=this.device.createBuffer({size:l,usage:u,label:`color_${this.colorPrecision.dataType}`}),this.countBuf=this.device.createBuffer({size:Math.ceil(4/16)*16,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST,label:"num_points"});const d=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,f=h=>Math.ceil(h/16)*16;this.cameraMatrixBuf=this.device.createBuffer({size:f(64),usage:d,label:"camera_matrix"}),this.projMatrixBuf=this.device.createBuffer({size:f(64),usage:d,label:"projection_matrix"}),this.timeBuf=this.device.createBuffer({size:f(4),usage:d,label:"time_input"})}async detectFromMetadata(){this.log(" Detecting capacity and color output from model metadata...");try{await this.pickCapacityFromMetadataOrProbe()?this.log(` Capacity detected from metadata: ${this.capacity}`):this.log(" Could not detect capacity from metadata"),this.pickColorOutputFromMetadata()?this.log(` Color mode detected from metadata: ${this.colorMode} (${this.colorDim} channels)`):(this.log(" Could not detect color type from metadata, using defaults"),this.colorMode="sh",this.colorDim=48,this.colorOutputName="sh_f16")}catch(e){console.error(" Metadata detection failed:",e),this.warn(" Falling back to defaults"),this.colorMode="sh",this.colorDim=48,this.colorOutputName="sh_f16",this.log(` Detection completed with defaults: capacity=${this.capacity||"none"}, color=${this.colorMode} (${this.colorDim} channels)`)}}async detectPrecisions(e){try{const n=this.session.outputNames||[],o=this.session.outputMetadata;if(this.verbose&&(console.log("[ONNX][Debug] outputNames =",n),o))for(const i in o){const r=o[i],l=r?.shape?`[${r.shape.join(", ")}]`:"unknown";console.log(`[ONNX][Meta] idx=${i} name='${r?.name}' type='${r?.type??r?.dataType}' shape=${l}`)}}catch{}const t=this.gaussOutputName||(this.session.outputNames?.find(n=>/gauss|gaussian/i.test(n))??"gaussian_f16"),s=Yt.detectFromMetadataPreferringNameSuffix(this.session,t);if(this.gaussianPrecision=s,this.colorPrecision={...s},s.dataType==="int8"||s.dataType==="uint8"){const n=Yt.extractQuantizationParams(this.session,t);this.gaussianPrecision.scale=n.scale??1,this.gaussianPrecision.zeroPoint=n.zeroPoint??0;const o=this.colorOutputName||"sh_f16",i=Yt.extractQuantizationParams(this.session,o);this.colorPrecision.scale=i.scale??1,this.colorPrecision.zeroPoint=i.zeroPoint??0}this.log(`Precision detected: gaussian=${this.gaussianPrecision.dataType} (${this.gaussianPrecision.bytesPerElement}B), color=${this.colorPrecision.dataType}`),this.detectedPrecisionLabel=this.gaussianPrecision?.dataType||"float16"}async pickCapacityFromMetadataOrProbe(){this.log("ğŸ§­ Detecting capacity from gaussian output metadata...");try{const e=this.session;this.log(" DEBUG: session object keys:",Object.keys(e));const t=e.outputMetadata;this.log(" DEBUG: outputMetadata:",t);for(const s of Object.keys(t))if(console.log(` Found gaussian candidate in outputMetadata: '${s}' dims=${t[s]?.shape?`[${t[s]?.shape.join(", ")}]`:"undefined"}`),t[s].name.startsWith("gauss")||t[s].name.startsWith("gaussian")){const n=t[s]?.shape;return console.log(` Found gaussian candidate in outputMetadata: '${s}' dims=${n?`[${n.join(", ")}]`:"undefined"}`),this.gaussOutputName=t[s].name,this.gaussFields=n[-1],this.capacity=n[0],this.log(`ğŸ¦­ Capacity from metadata: ${t[s].name} -> N=${this.capacity}, fields=${this.gaussFields}`),!0}return console.log("ğŸ”¬ Fallback: Running minimal CPU inference to detect shapes..."),await this.detectCapacityFromCPUInference()}catch(e){return console.warn(" Error accessing output metadata:",e),await this.detectCapacityFromCPUInference()}}async detectCapacityFromCPUInference(){this.log("ğŸ”¬ Running minimal CPU inference to detect model dimensions...");try{const e={};for(const n of this.inputNames)n.toLowerCase().includes("camera")||n.toLowerCase().includes("view")||n.toLowerCase().includes("matrix")?e[n]=new be.Tensor("float32",new Float32Array(16).fill(0),[4,4]):n.toLowerCase().includes("time")||n==="t"?e[n]=new be.Tensor("float32",new Float32Array([0]),[1]):(n.toLowerCase().includes("projection")||n.toLowerCase().includes("proj"))&&(e[n]=new be.Tensor("float32",new Float32Array(16).fill(0),[4,4]));this.log(` Running CPU inference with inputs: ${Object.keys(e).join(", ")}`);const t=await this.session.run(e),s=this.session.outputNames.filter(n=>/gauss|gaussian|means|cov|gaussian_f16/i.test(n));for(const n of s){const o=t[n];if(o&&o.dims.length>=2){const i=o.dims,r=i[i.length-1],l=i[0];if(this.log(` Found gaussian output '${n}': shape [${i.join(", ")}]`),(r===10||r===9)&&Number.isFinite(l)&&l>0)return this.gaussOutputName=n,this.gaussFields=r,this.capacity=l,this.log(` Capacity detected from CPU inference: ${n} -> N=${this.capacity}, fields=${this.gaussFields}`),this.detectColorFromCPUResult(t),!0}}return this.log(" No gaussian output found with expected dimensions"),!1}catch(e){return this.warn(" CPU inference detection failed:",e),!1}}detectColorFromCPUResult(e){for(const[t,s]of Object.entries(e)){const n=s.dims,o=t.toLowerCase();if((o.includes("color")||o.includes("sh")||o.includes("rgb"))&&n.length>=2){const i=n[n.length-1];if(i===48){this.colorMode="sh",this.colorDim=48,this.colorOutputName=t,this.log(` Color mode detected from CPU inference: SH (${i} channels) - ${t}`);return}else if(i===3||i===4){this.colorMode="rgb",this.colorDim=i===3?4:i,this.colorOutputName=t,this.log(` Color mode detected from CPU inference: RGB (${i} channels) - ${t}`);return}else if(i===12||i===27){this.colorMode="sh",this.colorDim=i,this.colorOutputName=t,this.log(` Color mode detected from CPU inference: SH (${i} channels) - ${t}`);return}}}}pickColorOutputFromMetadata(){this.log(" Detecting color output type from metadata dimensions...");try{const t=this.session.outputMetadata??{};for(const s of this.session.outputNames){const n=s.toLowerCase();if(n.includes("color")||n.includes("sh")||n.includes("rgb")){let o=-1;for(const l in t)if(t[l]?.name===s){o=Number(l);break}if(o===-1)continue;const r=t[o]?.shape;if(this.log(` Found potential color output: '${s}' dims=${r?`[${r.join(", ")}]`:"undefined"}`),r&&r.length>=2){const l=r[r.length-1];if(l===48)return this.colorMode="sh",this.colorDim=48,this.colorOutputName=s,this.log(` Detected SH from dimensions: '${s}' â†’ ${l} channels`),!0;if(l===3||l===4)return this.colorMode="rgb",this.colorDim=l,this.colorOutputName=s,this.log(` Detected RGB from dimensions: '${s}' â†’ ${l} channels`),!0;if(l===12||l===27)return this.colorMode="sh",this.colorDim=l,this.colorOutputName=s,this.log(` Detected SH from dimensions: '${s}' â†’ ${l} channels`),!0;this.warn(` Found color output '${s}' with unexpected ${l} channels`)}}}}catch(t){this.warn(" Error accessing color output metadata:",t)}const e=["sh_f16","spherical_harmonics","color_sh"];for(const t of e)if(this.session.outputNames.includes(t))return this.colorMode="sh",this.colorDim=48,this.colorOutputName=t,this.log(`ğŸ“ Found standard SH output: '${t}' â†’ 48 channels (name-based fallback)`),!0;return this.log(" No color output detected from metadata"),!1}updateInputBuffers(e,t,s){if(e&&(this.log(" DEBUG: Camera Matrix passed to ONNX:"),this.log(e),this.table([e.slice(0,4),e.slice(4,8),e.slice(8,12),e.slice(12,16)]),this.device.queue.writeBuffer(this.cameraMatrixBuf,0,e.buffer)),t&&(this.log(" DEBUG: Projection Matrix passed to ONNX:"),this.log(t),this.table([t.slice(0,4),t.slice(4,8),t.slice(8,12),t.slice(12,16)]),this.device.queue.writeBuffer(this.projMatrixBuf,0,t.buffer)),s!==void 0){this.log(` DEBUG: Time passed to ONNX: ${s}`);const n=new Float32Array([s]);this.device.queue.writeBuffer(this.timeBuf,0,n.buffer)}}async runInference(e={}){return at.runExclusive(async()=>{this.log(" GPU DIRECT: Running WebGPU inference with IOBinding..."),this.log(`ğŸ“ Using pre-allocated buffers for ${this.maxPoints} points`),this.updateInputBuffers(e.cameraMatrix,e.projectionMatrix,e.time);const t=this.maxPoints,s={};for(const r of this.inputNames)r.toLowerCase().includes("camera")||r.toLowerCase().includes("view")||r.toLowerCase().includes("matrix")?(s[r]=be.Tensor.fromGpuBuffer(this.cameraMatrixBuf,{dataType:"float32",dims:[4,4]}),this.log(`  ğŸ“· Created GPU camera matrix for '${r}'`)):r.toLowerCase().includes("time")||r==="t"?(s[r]=be.Tensor.fromGpuBuffer(this.timeBuf,{dataType:"float32",dims:[1]}),this.log(`  â° Created GPU time input for '${r}'`)):(r.toLowerCase().includes("projection")||r.toLowerCase().includes("proj"))&&(s[r]=be.Tensor.fromGpuBuffer(this.projMatrixBuf,{dataType:"float32",dims:[4,4]}),this.log(`  ğŸ“ Created GPU projection matrix for '${r}'`));const n=this.gaussOutputName||"gaussian_f16",o={};o[n]=be.Tensor.fromGpuBuffer(this.gaussBuf,{dataType:Xt(this.gaussianPrecision),dims:[t,10]}),o.num_points=be.Tensor.fromGpuBuffer(this.countBuf,{dataType:"int32",dims:[1]});const i=this.colorOutputName||"sh_f16";if(this.log("----- real needed color channels "+this.colorDim),this.session.outputNames.includes(i))o[i]=be.Tensor.fromGpuBuffer(this.shBuf,{dataType:Xt(this.colorPrecision),dims:[t,this.colorDim]});else{this.warn(` Color output '${i}' not found in model outputs`),this.warn(`Available outputs: ${this.session.outputNames.join(", ")}`);const r=this.session.outputNames.find(l=>l.toLowerCase().includes("color")||l.toLowerCase().includes("sh")||l.toLowerCase().includes("rgb"));if(r)this.warn(` Using possible color output: '${r}'`),o[r]=be.Tensor.fromGpuBuffer(this.shBuf,{dataType:Xt(this.colorPrecision),dims:[t,this.colorDim]});else throw new Error(`No suitable color output found in model. Available outputs: ${this.session.outputNames.join(", ")}`)}this.log(` IOBinding configured: gaussian[${t}x10], ${this.colorMode}[${t}x${this.colorDim}]`),this.log(` Input feeds: ${Object.keys(s).join(", ")}`),this.log(` Output fetches: ${Object.keys(o).join(", ")}`);try{await this.session.run(s,o),this.log(" GPU DIRECT SUCCESS: Inference completed with full GPU pipeline");try{const r=await ws(this.device,this.countBuf);this.log(` DEBUG: ONNX wrote count=${r} to GPU buffer`),this.actualPoints=r}catch(r){this.warn(" Could not read count buffer for debugging:",r)}}catch(r){console.error(" WebGPU IOBinding failed:",r);const l=r instanceof Error?r.message:String(r);throw console.error("name:",r?.name,"message:",r?.message,"stack:",r?.stack),new Error(`WebGPU inference required but failed: ${l}`)}})}destroy(){this.gaussBuf?.destroy?.(),this.shBuf?.destroy?.(),this.countBuf?.destroy?.(),this.cameraMatrixBuf?.destroy?.(),this.projMatrixBuf?.destroy?.(),this.timeBuf?.destroy?.()}}class ro{constructor(e){this.cfg=e}io;inited=!1;async initialize(e){const t=e||this.cfg.device;if(!t)throw new Error("WebGPU device is required. Pass device to initialize() or provide it in config.");this.io=new at,await this.io.init({modelUrl:this.cfg.modelUrl,maxPoints:this.cfg.maxPoints,device:t,verbose:!1,precisionConfig:this.cfg.precisionConfig}),this.inited=!0}async generate(e={}){if(!this.inited)throw new Error("ONNXGenerator not initialized");await this.io.runInference(e)}getGaussianBuffer(){return this.io.gaussBuf}getSHBuffer(){return this.io.shBuf}getCountBuffer(){return this.io.countBuf}getDevice(){return this.io.device}getInputNames(){return this.io.inputNames||[]}getDetectedCapacity(){return this.io.detectedCapacity}getDetectedColorMode(){return this.io.detectedColorMode}getDetectedColorDim(){return this.io.detectedColorDim}getActualMaxPoints(){return this.io.maxPoints}getGaussianPrecision(){return this.io.gaussianPrecisionInfo??this.io.gaussianPrecision}getColorPrecision(){return this.io.colorPrecisionInfo??this.io.colorPrecision}dispose(){this.io?.destroy()}}class Kt{constructor(e){this.modelManager=e}generators=new Map;pointClouds=new Map;async loadONNXModel(e,t,s,n,o,i={}){console.log(i),console.log(`Loading ONNX model from: ${t}`);const{staticInference:r=!0,maxPoints:l,debugLogging:u=!1}=i,d=new ro({modelUrl:t,maxPoints:l,debugLogging:u,precisionConfig:i.precisionConfig});await d.initialize(e);const f=d.getInputNames();if(!r&&f.length>0){const M={cameraMatrix:s,projectionMatrix:n,time:0};console.log(`Initial data for dynamic model - inputs: ${f.join(", ")}`),await d.generate(M)}else await d.generate({}),console.log(r,f.length,f),console.log("Static model - ran single inference with no inputs");const h=d.io?.actualPoints||l||0,m=d.io?.detectedColorMode||"sh",p=d.io?.detectedColorDim||48,v=d.io?.detectedColorOutputName||null,b=new Be(e,d.getGaussianBuffer(),d.getSHBuffer(),l||d.getActualMaxPoints(),d.getCountBuffer(),p,{gaussian:d.getGaussianPrecision?.(),color:d.getColorPrecision?.()}),y=d.io?.detectedPrecisionLabel||"float16",_=o||`ONNX Model (${y})`,P=this.modelManager.generateUniqueName(_);u&&(console.log("ONNX Color Detection Results:"),console.log(`  Color Mode: ${m}`),console.log(`  Color Channels: ${p}`),console.log(`  Color Output Name: ${v||"default"}`),console.log(`  Actual Points: ${h}`),console.log(`  Max Points: ${l}`)),r||(b.setOnnxGenerator(d),u&&console.log("ğŸ¬ Dynamic mode enabled - will update per frame"));const S=this.modelManager.addModel({name:P,visible:!0,pointCloud:b,pointCount:h,isDynamic:!r,modelType:"onnx",colorMode:m,colorChannels:p});return this.generators.set(S.id,d),this.pointClouds.set(S.id,b),u&&console.log(`ONNX Model '${P}' (ID: ${S.id}) registered with isolated resources - color mode: ${m} (${p} channels)`),S}async loadONNXFromFile(e,t,s,n){const o=URL.createObjectURL(t);try{const i=new Float32Array(16),r=new Float32Array(16),l=[0,0,5],u=[0,0,0],d=[0,1,0];return c.mat4.lookAt(i,l,u,d),c.mat4.perspective(r,Math.PI/4,16/9,.01,1e3),await this.loadONNXModel(e,o,s||i,n||r,t.name.replace(".onnx",""),{staticInference:!0,maxPoints:4e6,debugLogging:!0})}finally{URL.revokeObjectURL(o)}}async updateCameraMatrices(e,t,s){console.log(`Updating camera matrices for model: ${e}`)}disposeModel(e){const t=this.generators.get(e),s=this.pointClouds.get(e);t?.dispose(),s?.dispose?.(),this.generators.delete(e),this.pointClouds.delete(e),console.log(`ONNXManager: Disposed model ${e}`)}dispose(){for(const[e,t]of this.generators.entries())t?.dispose(),console.log(`ONNXManager: Disposed generator ${e}`);for(const[e,t]of this.pointClouds.entries())t?.dispose?.(),console.log(`ONNXManager: Disposed point cloud ${e}`);this.generators.clear(),this.pointClouds.clear(),console.log("ONNXManager: All resources disposed")}getGenerator(e){return this.generators.get(e)}getPointCloud(e){return this.pointClouds.get(e)}hasONNXModels(){return this.generators.size>0}getONNXModels(){return Array.from(this.generators.keys())}getONNXPerformanceStats(){return{modelCount:this.generators.size,totalGenerators:this.generators.size,totalPointClouds:this.pointClouds.size}}}class St extends G.Object3D{mEntry;autoSyncEnabled=!0;_overrideLocalAabb=null;_cachedWorldAabb=null;_worldAabbDirty=!0;_gaussianScale=1;constructor(e){super(),this.mEntry=e,this.name=e.name,this.setupAutoSync()}setupAutoSync(){let e=!1,t=Date.now();const s=()=>{this.autoSyncEnabled&&!e&&(e=!0,requestAnimationFrame(()=>{this.syncTransformToGPU(),this._worldAabbDirty=!0,e=!1}))},n=this.updateMatrix.bind(this);this.updateMatrix=()=>{n();const o=Date.now();o-t>8&&(t=o,s())},this.matrixAutoUpdate=!0,this.interceptTransformMethods(s),console.log(`âœ… Auto-sync setup for model: ${this.name}`)}interceptTransformMethods(e){const t=this.position.set.bind(this.position),s=this.scale.set.bind(this.scale),n=this.rotation.set.bind(this.rotation);this.position.set=(o,i,r)=>{const l=t(o,i,r);return e(),l},this.scale.set=(o,i,r)=>{const l=s(o,i,r);return e(),l},this.rotation.set=(o,i,r,l)=>{const u=n(o,i,r,l);return e(),u}}getModelId(){return this.mEntry.id}get modelName(){return this.mEntry.name}get pointCount(){return this.mEntry.pointCount}get isDynamic(){return this.mEntry.isDynamic}get modelType(){return this.mEntry.modelType}getEntry(){return this.mEntry}getPointCloud(){if(!this.mEntry?.pointCloud)throw new Error("PointCloud is not initialized");return this.mEntry.pointCloud}isGaussianModel(){const e=this.mEntry.pointCloud;return e instanceof We||e instanceof Be}getTransformMatrix(){const e=new G.Matrix4;e.compose(this.position,this.quaternion,this.scale);const t=new G.Matrix4().makeScale(1,-1,-1);return t.premultiply(e),new Float32Array(t.elements)}syncTransformToGPU(e=0){if(!this.mEntry?.pointCloud)return;const t=this.getTransformMatrix();this.mEntry.pointCloud.setTransform(t),this.isGaussianModel()&&this.mEntry.pointCloud.updateModelParamsBuffer(t,e),globalThis.GS_DEBUG_FLAG&&console.log(`[GaussianModel] Synced transform for ${this.name}:`,{position:[this.position.x.toFixed(3),this.position.y.toFixed(3),this.position.z.toFixed(3)],rotation:[this.rotation.x.toFixed(3),this.rotation.y.toFixed(3),this.rotation.z.toFixed(3)],scale:[this.scale.x.toFixed(3),this.scale.y.toFixed(3),this.scale.z.toFixed(3)]})}setOverrideAABB(e){if(e===null)this._overrideLocalAabb=null;else if(e instanceof et)this._overrideLocalAabb=e;else{const t=c.vec3.fromValues(e.min[0],e.min[1],e.min[2]),s=c.vec3.fromValues(e.max[0],e.max[1],e.max[2]);this._overrideLocalAabb=new et(t,s)}this._worldAabbDirty=!0}getLocalAABB(){if(this._overrideLocalAabb)return this._overrideLocalAabb;const e=this.mEntry?.pointCloud;return e&&e.bbox instanceof et?e.bbox:null}getWorldAABB(){const e=this.getLocalAABB();if(!e)return null;if(this._cachedWorldAabb&&!this._worldAabbDirty)return this._cachedWorldAabb;const t=e.min,s=e.max,n=[[t[0],t[1],t[2]],[t[0],t[1],s[2]],[t[0],s[1],t[2]],[t[0],s[1],s[2]],[s[0],t[1],t[2]],[s[0],t[1],s[2]],[s[0],s[1],t[2]],[s[0],s[1],s[2]]],o=new G.Matrix4;o.compose(this.position,this.quaternion,this.scale);const i=new G.Vector3,r=c.vec3.fromValues(1/0,1/0,1/0),l=c.vec3.fromValues(-1/0,-1/0,-1/0);for(const u of n)i.set(u[0],u[1],u[2]).applyMatrix4(o),i.x<r[0]&&(r[0]=i.x),i.y<r[1]&&(r[1]=i.y),i.z<r[2]&&(r[2]=i.z),i.x>l[0]&&(l[0]=i.x),i.y>l[1]&&(l[1]=i.y),i.z>l[2]&&(l[2]=i.z);return this._cachedWorldAabb=new et(r,l),this._worldAabbDirty=!1,this._cachedWorldAabb}async update(e,t,s){if(!(this.mEntry?.pointCloud instanceof Be))return;const n=this.getTransformMatrix();await this.mEntry.pointCloud.update(e,n,t||0,s)}setModelVisible(e){this.visible=e,this.mEntry.visible=e}getModelVisible(){return this.mEntry.visible&&this.visible}isVisible(e){return this.getModelVisible()}setAutoSync(e){this.autoSyncEnabled=e,console.log(`Auto-sync ${e?"enabled":"disabled"} for model: ${this.modelName}`)}getAutoSync(){return this.autoSyncEnabled}forceSyncToGPU(){this.syncTransformToGPU()}dispose(){this.autoSyncEnabled=!1,console.log(`ğŸ§¹ GaussianModel disposed: ${this.modelName}`)}setTransform(e,t=0){console.warn("GaussianModel.setTransform() is deprecated. Modify position/rotation/scale instead."),this.mEntry.pointCloud.setTransform(e),this.isGaussianModel()&&this.mEntry.pointCloud.updateModelParamsBuffer(e,t)}setGaussianScale(e){this._gaussianScale=e,this.isGaussianModel()&&(this.mEntry.pointCloud.setGaussianScaling(e),console.log(`[GaussianModel] ${this.name} Gaussian scale set to: ${e}`))}getGaussianScale(){return this.isGaussianModel()?this.mEntry.pointCloud.getGaussianScaling():this._gaussianScale}setMaxShDeg(e){this.isGaussianModel()&&(this.mEntry.pointCloud.setMaxShDeg(e),console.log(`[GaussianModel] ${this.name} Max SH degree set to: ${e}`))}getMaxShDeg(){return this.isGaussianModel()?this.mEntry.pointCloud.getMaxShDeg():0}setKernelSize(e){this.isGaussianModel()&&(this.mEntry.pointCloud.setKernelSize(e),console.log(`[GaussianModel] ${this.name} Kernel size set to: ${e}`))}getKernelSize(){return this.isGaussianModel()?this.mEntry.pointCloud.getKernelSize():0}setOpacityScale(e){this.isGaussianModel()&&(this.mEntry.pointCloud.setOpacityScale(e),console.log(`[GaussianModel] ${this.name} Opacity scale set to: ${e}`))}getOpacityScale(){return this.isGaussianModel()?this.mEntry.pointCloud.getOpacityScale():1}setCutoffScale(e){this.isGaussianModel()&&(this.mEntry.pointCloud.setCutoffScale(e),console.log(`[GaussianModel] ${this.name} Cutoff scale set to: ${e}`))}getCutoffScale(){return this.isGaussianModel()?this.mEntry.pointCloud.getCutoffScale():1}setTimeScale(e){this.mEntry.pointCloud&&"setTimeScale"in this.mEntry.pointCloud?(this.mEntry.pointCloud.setTimeScale(e),console.log(`[GaussianModel] ${this.name} Time scale set to: ${e}`)):console.warn(`[GaussianModel] ${this.name} does not support time scale (not a dynamic model)`)}getTimeScale(){return this.mEntry.pointCloud&&"getTimeScale"in this.mEntry.pointCloud?this.mEntry.pointCloud.getTimeScale():1}setTimeOffset(e){this.mEntry.pointCloud&&"setTimeOffset"in this.mEntry.pointCloud?(this.mEntry.pointCloud.setTimeOffset(e),console.log(`[GaussianModel] ${this.name} Time offset set to: ${e}`)):console.warn(`[GaussianModel] ${this.name} does not support time offset (not a dynamic model)`)}setAnimationIsLoop(e){this.mEntry.pointCloud&&"setAnimationIsLoop"in this.mEntry.pointCloud?(this.mEntry.pointCloud.setAnimationIsLoop(e),console.log(`[GaussianModel] ${this.name} Is Loop set to: ${e}`)):console.warn(`[GaussianModel] ${this.name} does not support animation is loop (not a dynamic model)`)}getTimeOffset(){return this.mEntry.pointCloud&&"getTimeOffset"in this.mEntry.pointCloud?this.mEntry.pointCloud.getTimeOffset():0}setTimeUpdateMode(e){this.mEntry.pointCloud&&"setTimeUpdateMode"in this.mEntry.pointCloud?(this.mEntry.pointCloud.setTimeUpdateMode(e),console.log(`[GaussianModel] ${this.name} Time update mode set to: ${e}`)):console.warn(`[GaussianModel] ${this.name} does not support time update mode (not a dynamic model)`)}setRenderMode(e){this.isGaussianModel()&&(this.mEntry.pointCloud.setRenderMode(e),console.log(`[GaussianModel] ${this.name} Render mode set to: ${e}`))}getRenderMode(){if(this.isGaussianModel()){const e=this.mEntry.pointCloud;if(typeof e.getRenderMode=="function")return e.getRenderMode()}return 0}getTimeUpdateMode(){return this.mEntry.pointCloud&&"getTimeUpdateMode"in this.mEntry.pointCloud?this.mEntry.pointCloud.getTimeUpdateMode():"fixed_delta"}startAnimation(e=1){this.mEntry.pointCloud&&"startAnimation"in this.mEntry.pointCloud?(this.mEntry.pointCloud.startAnimation(e),console.log(`[GaussianModel] ${this.name} Animation started at ${e}x speed`)):console.warn(`[GaussianModel] ${this.name} does not support animation (not a dynamic model)`)}pauseAnimation(){this.mEntry.pointCloud&&"pauseAnimation"in this.mEntry.pointCloud?(this.mEntry.pointCloud.pauseAnimation(),console.log(`[GaussianModel] ${this.name} Animation paused`)):console.warn(`[GaussianModel] ${this.name} does not support animation (not a dynamic model)`)}resumeAnimation(){this.mEntry.pointCloud&&"resumeAnimation"in this.mEntry.pointCloud?(this.mEntry.pointCloud.resumeAnimation(),console.log(`[GaussianModel] ${this.name} Animation resumed`)):console.warn(`[GaussianModel] ${this.name} does not support animation (not a dynamic model)`)}stopAnimation(){this.mEntry.pointCloud&&"stopAnimation"in this.mEntry.pointCloud?(this.mEntry.pointCloud.stopAnimation(),console.log(`[GaussianModel] ${this.name} Animation stopped`)):console.warn(`[GaussianModel] ${this.name} does not support animation (not a dynamic model)`)}setAnimationTime(e){this.mEntry.pointCloud&&"setAnimationTime"in this.mEntry.pointCloud?(this.mEntry.pointCloud.setAnimationTime(e),console.log(`[GaussianModel] ${this.name} Animation time set to ${e.toFixed(3)}s`)):console.warn(`[GaussianModel] ${this.name} does not support animation (not a dynamic model)`)}setAnimationSpeed(e){this.mEntry.pointCloud&&"setAnimationSpeed"in this.mEntry.pointCloud?(this.mEntry.pointCloud.setAnimationSpeed(e),console.log(`[GaussianModel] ${this.name} Animation speed set to ${e}x`)):console.warn(`[GaussianModel] ${this.name} does not support animation (not a dynamic model)`)}getAnimationSpeed(){return this.mEntry.pointCloud&&"getAnimationSpeed"in this.mEntry.pointCloud?this.mEntry.pointCloud.getAnimationSpeed():1}isAnimationRunning(){return this.mEntry.pointCloud&&"isAnimationRunning"in this.mEntry.pointCloud?this.mEntry.pointCloud.isAnimationRunning:!1}isAnimationPaused(){return this.mEntry.pointCloud&&"isAnimationPaused"in this.mEntry.pointCloud?this.mEntry.pointCloud.isAnimationPaused:!1}}class ao{constructor(e,t){this.fileLoader=e,this.onnxManager=t}async createFromGaussian(e,t,s,n){const o=e.backend.device,i=Oe(t);console.log(`[GaussianLoader] Loading ${i?.toUpperCase()||"GAUSSIAN"} file:`,t);const r=await this.fileLoader.loadSample(t,o,n||"gaussian");if(!r)throw new Error(`Failed to load Gaussian file: ${t}`);return s?.name&&(r.name=s.name),new St(r)}async createFromPLY(e,t,s){const n=e.backend.device,o=await this.fileLoader.loadSample(t,n,"ply");if(!o)throw new Error(`Failed to load PLY file: ${t}`);return s?.name&&(o.name=s.name),new St(o)}async createFromSPZ(e,t,s){return this.createFromGaussian(e,t,s)}async createFromKSplat(e,t,s){return this.createFromGaussian(e,t,s)}async createFromSplat(e,t,s){return this.createFromGaussian(e,t,s)}async createFromSOG(e,t,s){return this.createFromGaussian(e,t,s)}async createFromONNX(e,t,s,n,o){const i=e.backend.device,r={staticInference:!1,debugLogging:!0,...o?.onnxOptions},l=await this.onnxManager.loadONNXModel(i,t,s,n,o?.name,r);return new St(l)}async createFromFile(e,t,s,n,o){const i=o||this.fileLoader.getFileType(t);if(i==="ply")return this.createFromPLY(e,t,n);if(i==="onnx"){if(!s)throw new Error(`ONNX file ${t} requires camera matrices`);return this.createFromONNX(e,t,s.camMat,s.projMat,n)}if(["gaussian","sog","splat","ksplat","spz","compressed.ply"].includes(i))return this.createFromGaussian(e,t,n,i);throw new Error(`Unsupported file type: ${i}`)}createFromEntry(e){return new St(e)}isFormatSupported(e){return this.fileLoader.isFileTypeSupported(e)}getSupportedFormats(){return this.fileLoader.getSupportedExtensions()}detectFormat(e){return this.fileLoader.getGaussianFormat(e)}}class lt{fovx;fovy;znear;zfar;fov2viewRatio;constructor(e,t,s,n){const o=(typeof e[0]=="number",e[0]),i=(typeof e[1]=="number",e[1]),r=(typeof t[0]=="number",t[0]),l=(typeof t[1]=="number",t[1]),u=o/i,d=r/l;this.fovx=r,this.fovy=l,this.znear=s,this.zfar=n,this.fov2viewRatio=u/d}clone(){const e=new lt([1,1],[this.fovx,this.fovy],this.znear,this.zfar);return e.fov2viewRatio=this.fov2viewRatio,e}resize(e){const t=(typeof e[0]=="number",e[0]),s=(typeof e[1]=="number",e[1]),o=t/s/this.fov2viewRatio,i=2*Math.atan(Math.tan(this.fovy*.5)*(o/(this.fovx/this.fovy)));Math.abs(this.fovx/this.fovy-o)<1e-6||(this.fovy=i,this.fovx=this.fovy*o)}projectionMatrix(){return co(this.znear,this.zfar,this.fovx,this.fovy)}focal(e){const t=(typeof e[0]=="number",e[0]),s=(typeof e[1]=="number",e[1]);return[ls(this.fovx,t),ls(this.fovy,s)]}lerp(e,t){const s=this.clone();return s.fovx=this.fovx*(1-t)+e.fovx*t,s.fovy=this.fovy*(1-t)+e.fovy*t,s.znear=this.znear*(1-t)+e.znear*t,s.zfar=this.zfar*(1-t)+e.zfar*t,s.fov2viewRatio=this.fov2viewRatio*(1-t)+e.fov2viewRatio*t,s}}class Ze{positionV;rotationQ;projection;constructor(e,t,s){this.positionV=c.vec3.clone(e),this.rotationQ=c.quat.clone(t),this.projection=s}static default(){return new Ze(c.vec3.fromValues(0,0,-1),c.quat.fromValues(0,0,0,1),new lt([1,1],[Ne(45),Ne(45)],.1,100))}fitNearFar(e){const t=e.center(),s=e.radius(),n=c.vec3.distance(this.positionV,t),o=n+s,i=Math.max(n-s,o/1e3);this.projection.zfar=o*1.5,this.projection.znear=i}viewMatrix(){const e=c.mat3.create();return c.mat3.fromQuat(e,this.rotationQ),lo(e,this.positionV)}projMatrix(){return this.projection.projectionMatrix()}position(){return c.vec3.clone(this.positionV)}frustumPlanes(){const e=this.projMatrix(),t=this.viewMatrix(),s=c.mat4.create();c.mat4.multiply(s,e,t);const n=[s[0],s[4],s[8],s[12]],o=[s[1],s[5],s[9],s[13]],i=[s[2],s[6],s[10],s[14]],r=[s[3],s[7],s[11],s[15]],l=(f,h)=>new Float32Array([f[0]+h[0],f[1]+h[1],f[2]+h[2],f[3]+h[3]]),u=(f,h)=>new Float32Array([f[0]-h[0],f[1]-h[1],f[2]-h[2],f[3]-h[3]]),d=f=>{const h=Math.hypot(f[0],f[1],f[2]);return h>0?new Float32Array([f[0]/h,f[1]/h,f[2]/h,f[3]/h]):f};return{left:d(l(r,n)),right:d(u(r,n)),bottom:d(l(r,o)),top:d(u(r,o)),near:d(l(r,i)),far:d(u(r,i))}}}function lo(a,e){const t=c.mat4.create();t[0]=a[0],t[1]=a[1],t[2]=a[2],t[3]=0,t[4]=a[3],t[5]=a[4],t[6]=a[5],t[7]=0,t[8]=a[6],t[9]=a[7],t[10]=a[8],t[11]=0;const s=c.vec3.create();return c.vec3.transformMat3(s,e,a),t[12]=-s[0],t[13]=-s[1],t[14]=-s[2],t[15]=1,t}function co(a,e,t,s){const n=Math.tan(s*.5),o=Math.tan(t*.5),i=n*a,r=-i,l=o*a,u=-l,d=c.mat4.create();return d[0]=2*a/(l-u),d[5]=2*a/(i-r),d[8]=(l+u)/(l-u),d[9]=(i+r)/(i-r),d[11]=1,d[10]=e/(e-a),d[14]=-(e*a)/(e-a),d[15]=0,d}const uo=1,fo=.002,ho=.5,mo=.85,po=.85;function Ws(a,e,t){return Math.min(t,Math.max(e,a))}class js{moveSpeed;rotateSpeed;scrollSpeed;moveInertia;rotateInertia;capsMultiplier=10;shiftMultiplier=50;ctrlMultiplier=.2;keycode={};keydown={};leftMousePressed=!1;rightMousePressed=!1;mouseDelta=c.vec3.fromValues(0,0,0);scrollDelta=0;moveVelocity=c.vec3.fromValues(0,0,0);rotateVelocity=c.vec3.fromValues(0,0,0);yaw=0;pitch=0;userInput=!1;enable=!0;flyMode=!0;constructor(e=uo,t=fo,s=ho,n=po,o=mo){this.moveSpeed=e,this.rotateSpeed=t,this.scrollSpeed=s,this.moveInertia=n,this.rotateInertia=o,document.addEventListener("keydown",i=>{this.keydown[i.key]=!0,this.keycode[i.code]=!0,this.userInput=!0}),document.addEventListener("keyup",i=>{this.keydown[i.key]=!1,this.keycode[i.code]=!1}),window.addEventListener("blur",()=>{this.keydown={},this.keycode={},this.leftMousePressed=!1,this.rightMousePressed=!1})}processKeyboard(e,t){return this.keycode[e]=t,this.userInput=!0,!0}processMouse(e,t){this.leftMousePressed&&(this.mouseDelta[0]+=e,this.mouseDelta[1]+=t,this.userInput=!0),this.rightMousePressed}processScroll(e){this.scrollDelta+=e,this.userInput=!0}update(e,t){if(!this.enable)return;let s=0,n=0;if(this.leftMousePressed&&(Math.abs(this.mouseDelta[0])>0||Math.abs(this.mouseDelta[1])>0))s=this.mouseDelta[0]*this.rotateSpeed,n=-this.mouseDelta[1]*this.rotateSpeed,this.rotateVelocity[0]=s/t,this.rotateVelocity[1]=n/t;else{s=this.rotateVelocity[0]*t,n=this.rotateVelocity[1]*t;const u=Math.exp(-t/(1-this.rotateInertia+1e-6));this.rotateVelocity[0]*=u,this.rotateVelocity[1]*=u,Math.abs(this.rotateVelocity[0])<.001&&(this.rotateVelocity[0]=0),Math.abs(this.rotateVelocity[1])<.001&&(this.rotateVelocity[1]=0)}this.yaw+=s,this.pitch+=n,this.pitch=Ws(this.pitch,-Math.PI/2+.01,Math.PI/2-.01);const o=c.quat.identity(c.quat.create());c.quat.rotateY(o,o,this.yaw),c.quat.rotateX(o,o,this.pitch);const i=c.quat.invert(c.quat.create(),o);c.quat.copy(e.rotationQ,i);const r=c.vec3.fromValues(0,0,0);(this.keycode.KeyW||this.keycode.ArrowUp)&&(r[2]-=1),(this.keycode.KeyS||this.keycode.ArrowDown)&&(r[2]+=1),(this.keycode.KeyA||this.keycode.ArrowLeft)&&(r[0]-=1),(this.keycode.KeyD||this.keycode.ArrowRight)&&(r[0]+=1),(this.keycode.KeyR||this.keycode.PageUp)&&(r[1]+=1),(this.keycode.KeyF||this.keycode.PageDown)&&(r[1]-=1),this.keycode.KeyQ&&(r[0]-=1),this.keycode.KeyE&&(r[0]+=1),Math.abs(this.scrollDelta)>0&&(r[2]-=this.scrollDelta*this.scrollSpeed);let l=1;if(this.keydown.CapsLock&&(l*=this.capsMultiplier),(this.keycode.ShiftLeft||this.keycode.ShiftRight)&&(l*=this.shiftMultiplier),(this.keycode.ControlLeft||this.keycode.ControlRight)&&(l*=this.ctrlMultiplier),c.vec3.length(r)>0){c.vec3.normalize(r,r),c.vec3.scale(r,r,this.moveSpeed*l);const u=c.quat.invert(c.quat.create(),e.rotationQ),d=c.vec3.transformQuat(c.vec3.create(),c.vec3.fromValues(0,0,-1),u),f=c.vec3.transformQuat(c.vec3.create(),c.vec3.fromValues(1,0,0),u),h=c.vec3.transformQuat(c.vec3.create(),c.vec3.fromValues(0,1,0),u),m=c.vec3.fromValues(d[0],0,d[2]),p=c.vec3.fromValues(f[0],0,f[2]),v=c.vec3.length(m),b=c.vec3.length(p);v>1e-6&&c.vec3.scale(m,m,1/v),b>1e-6&&c.vec3.scale(p,p,1/b);const y=c.vec3.create();c.vec3.scaleAndAdd(y,y,this.flyMode?f:p,r[0]),c.vec3.scaleAndAdd(y,y,this.flyMode?h:c.vec3.fromValues(0,1,0),r[1]),c.vec3.scaleAndAdd(y,y,this.flyMode?d:v>1e-6?m:d,r[2]),c.vec3.copy(this.moveVelocity,y)}else{const u=Math.exp(-t/(1-this.moveInertia+1e-6));c.vec3.scale(this.moveVelocity,this.moveVelocity,u),c.vec3.length(this.moveVelocity)<.001&&c.vec3.set(this.moveVelocity,0,0,0)}if(c.vec3.length(this.moveVelocity)>.001){const u=c.vec3.clone(this.moveVelocity);c.vec3.scale(u,u,t),c.vec3.add(e.positionV,e.positionV,u)}c.vec3.set(this.mouseDelta,0,0,0),this.scrollDelta=0,this.userInput=!1}resetOrientation(){this.yaw=0,this.pitch=0,this.rotateVelocity=c.vec3.fromValues(0,0,0),this.moveVelocity=c.vec3.fromValues(0,0,0)}getOrientation(){return{yaw:this.yaw*180/Math.PI,pitch:this.pitch*180/Math.PI}}setOrientation(e,t){this.yaw=e,this.pitch=Ws(t,-Math.PI/2+.01,Math.PI/2-.01)}setFlyMode(e){this.flyMode=e,console.log(`FPS Controller: Fly mode ${e?"enabled":"disabled (ground movement only)"}`)}getControllerType(){return"fps"}}function go(a,e,t,s,n){const o=e?1:-1;let i=!0;switch(a){case"KeyW":t[2]+=+o;break;case"KeyS":t[2]+=-o;break;case"KeyA":t[0]+=-o;break;case"KeyD":t[0]+=+o;break;case"KeyQ":s[2]+=o/n;break;case"KeyE":s[2]+=-o/n;break;case"Space":t[1]+=o;break;case"ShiftLeft":t[1]+=-o;break;default:i=!1}return i}function yo(a,e,t,s,n,o){let i=!1;return t&&(n[0]+=a,n[1]+=-e,i=!0),s&&(o[0]+=e,o[1]+=a,i=!0),i}function _o(a){return a*3}const Zt=1e-6,Qe=c.vec3.fromValues(0,1,0),wo=5*Math.PI/180,bo=.1,vo=1e3;function So(a,e){const t=c.vec3.normalize(c.vec3.create(),a);let s=c.vec3.sub(c.vec3.create(),e,c.vec3.scale(c.vec3.create(),t,c.vec3.dot(e,t)));if(c.vec3.sqrLen(s)<Zt){const m=Math.abs(t[1])<.99?Qe:c.vec3.fromValues(1,0,0);s=c.vec3.sub(c.vec3.create(),m,c.vec3.scale(c.vec3.create(),t,c.vec3.dot(m,t)))}c.vec3.normalize(s,s);const n=c.quat.rotationTo(c.quat.create(),c.vec3.fromValues(0,0,1),t),o=c.vec3.transformQuat(c.vec3.create(),c.vec3.fromValues(0,1,0),n),i=c.vec3.sub(c.vec3.create(),o,c.vec3.scale(c.vec3.create(),t,c.vec3.dot(o,t)));c.vec3.normalize(i,i);const r=Math.max(-1,Math.min(1,c.vec3.dot(i,s)));let l=Math.acos(r);const u=c.vec3.cross(c.vec3.create(),i,s),d=c.vec3.dot(u,t)>=0?1:-1;l*=d;const f=c.quat.setAxisAngle(c.quat.create(),t,l),h=c.quat.multiply(c.quat.create(),f,n);return c.quat.invert(c.quat.create(),h)}function qs(a,e,t){const s=c.vec3.sub(c.vec3.create(),a,c.vec3.scale(c.vec3.create(),e,c.vec3.dot(a,e)));let n=c.vec3.sqrLen(s);return n<Zt?c.vec3.normalize(c.vec3.create(),t):c.vec3.scale(s,s,1/Math.sqrt(n))}function Po(a,e,t){const s=c.vec3.normalize(c.vec3.create(),c.vec3.subtract(c.vec3.create(),e,a)),n=qs(t,s,Math.abs(s[1])<.99?Qe:c.vec3.fromValues(1,0,0)),o=c.vec3.normalize(c.vec3.create(),c.vec3.cross(c.vec3.create(),s,n)),i=c.vec3.normalize(c.vec3.create(),c.vec3.cross(c.vec3.create(),o,s));return{forward:s,right:o,yawAxis:i}}function xo(a,e,t,s,n){const o=Math.max(c.vec3.distance(a,e),Zt),i=Math.exp(Math.log(o)+t*s*10*n);return Math.max(bo,Math.min(i,vo))}function Co(a,e,t,s,n,o,i){const r=n*o*.1*i,l=c.vec3.create();c.vec3.scaleAndAdd(l,l,t,e[1]*r),c.vec3.scaleAndAdd(l,l,s,-e[0]*r),c.vec3.add(a,a,l)}function Mo(a,e,t,s,n,o){let i=c.vec3.clone(a),r=c.vec3.clone(e),l=c.vec3.clone(t);if(Math.abs(s)>0){const u=c.quat.setAxisAngle(c.quat.create(),l,s);i=c.vec3.transformQuat(c.vec3.create(),i,u),r=c.vec3.transformQuat(c.vec3.create(),r,u),l=c.vec3.normalize(c.vec3.create(),c.vec3.cross(c.vec3.create(),r,i))}if(Math.abs(n)>0){const u=Math.cos(wo),d=Math.max(-1,Math.min(1,c.vec3.dot(i,l))),f=c.quat.setAxisAngle(c.quat.create(),r,n),h=c.vec3.transformQuat(c.vec3.create(),i,f),m=Math.max(-1,Math.min(1,c.vec3.dot(h,l)));if(Math.abs(m)>u){const b=(m>0?1:-1)*u,y=Math.min(1,Math.abs((b-d)/(m-d+1e-9)));n*=y}const p=c.quat.setAxisAngle(c.quat.create(),r,n);i=c.vec3.transformQuat(c.vec3.create(),i,p),l=qs(l,i,l),r=c.vec3.normalize(c.vec3.create(),c.vec3.cross(c.vec3.create(),i,l))}if(Math.abs(o)>0){const u=c.quat.setAxisAngle(c.quat.create(),i,o);l=c.vec3.transformQuat(c.vec3.create(),l,u),r=c.vec3.normalize(c.vec3.create(),c.vec3.cross(c.vec3.create(),i,l))}return{forward:i,right:r,yawAxis:l}}function To(a,e,t,s){let n=Math.pow(.8,s*60);n<1e-4&&(n=0);const o=c.vec3.scale(c.vec3.create(),a,n);c.vec3.len(o)<1e-4&&c.vec3.set(o,0,0,0);const i=c.vec2.scale(c.vec2.create(),e,n);c.vec2.len(i)<1e-4&&c.vec2.set(i,0,0);const r=t*n,l=Math.abs(r)<1e-4?0:r;return{rotation:o,shift:i,scroll:l}}class ct{center=c.vec3.fromValues(0,0,0);up=null;amount=c.vec3.fromValues(0,0,0);shift=c.vec2.fromValues(0,0);rotation=c.vec3.fromValues(0,0,0);scroll=0;speed;sensitivity;leftMousePressed=!1;rightMousePressed=!1;altPressed=!1;userInput=!1;orbitUp=c.vec3.clone(Qe);debug=!1;debugEvery=1/30;_acc=0;constructor(e=.2,t=.1){this.speed=e,this.sensitivity=t}resetUp(e){this.orbitUp=c.vec3.normalize(c.vec3.create(),e??Qe)}processKeyboard(e,t){const s=go(e,t,this.amount,this.rotation,this.sensitivity);return this.userInput=s,s}processMouse(e,t){const s=yo(e,t,this.leftMousePressed,this.rightMousePressed,this.rotation,this.shift);this.userInput=s}processScroll(e){this.scroll+=_o(e),this.userInput=!0}update(e,t){const s=t,n=this.up?c.vec3.normalize(c.vec3.create(),this.up):Qe;let{forward:o,right:i,yawAxis:r}=Po(e.positionV,this.center,n);const l=xo(e.positionV,this.center,this.scroll,s,this.speed),u=Math.max(c.vec3.distance(e.positionV,this.center),1e-6);Co(this.center,this.shift,i,r,s,this.speed,u);const d=c.vec3.scale(c.vec3.create(),o,-l);c.vec3.add(e.positionV,this.center,d);let f=this.rotation[0]*s*this.sensitivity,h=-this.rotation[1]*s*this.sensitivity,m=0;this.altPressed&&(m=-this.rotation[1]*s*this.sensitivity,f=0,h=0);const p=Mo(o,i,r,f,h,m);o=p.forward,i=p.right,r=p.yawAxis,c.vec3.add(e.positionV,this.center,c.vec3.scale(c.vec3.create(),o,-l)),e.rotationQ=So(o,n),c.vec3.copy(this.orbitUp,r);const v=To(this.rotation,this.shift,this.scroll,s);if(c.vec3.copy(this.rotation,v.rotation),c.vec2.copy(this.shift,v.shift),this.scroll=v.scroll,this.userInput=!1,this._acc+=s,this.debug&&this._acc>=this.debugEvery){this._acc=0;const b=c.quat.invert(c.quat.create(),e.rotationQ),y=c.vec3.transformQuat(c.vec3.create(),c.vec3.fromValues(0,0,1),b);console.log("[CameraDebug]",{pos:[e.positionV[0],e.positionV[1],e.positionV[2]],center:[this.center[0],this.center[1],this.center[2]],dist:c.vec3.distance(e.positionV,this.center),forward_to_center:[o[0],o[1],o[2]],forward_from_rot:[y[0],y[1],y[2]],dot:c.vec3.dot(y,o)})}}getControllerType(){return"orbit"}resetOrientation(){this.center=c.vec3.fromValues(0,0,0),this.rotation=c.vec3.fromValues(0,0,0),this.shift=c.vec2.fromValues(0,0),this.scroll=0,this.orbitUp=c.vec3.clone(Qe)}}class Hs{camera=null;controller;controllerType="fps";canvasElement=null;constructor(e="orbit"){this.controllerType=e,this.controller=this.createController(e)}createController(e){return e==="orbit"?new ct:new js}initCamera(e){this.canvasElement=e;const t=45,s=Ne(t),n=e.width||1,o=e.height||1,i=n/o,r=Ne(t/i);this.camera=new Ze(c.vec3.fromValues(0,0,3),c.quat.fromValues(0,0,0,1),new lt([n,o],[s,r],.01,2e3)),console.log(`ğŸ“· Camera initialized: ${n}x${o}, aspect: ${i.toFixed(2)}, FOV: [${(s*180/Math.PI).toFixed(1)}Â°, ${(r*180/Math.PI).toFixed(1)}Â°]`)}resetCamera(){if(!this.camera||!this.canvasElement){console.warn("âš ï¸ Camera or canvas not available for reset");return}this.camera=new Ze(c.vec3.fromValues(0,0,3),c.quat.fromValues(0,0,0,1),this.camera.projection.clone()),this.controller=this.createController(this.controllerType),this.controller.resetOrientation&&this.controller.resetOrientation(),console.log("ğŸ“· Camera reset to default position")}setupCameraForPointCloud(e){if(!this.camera||!this.canvasElement){console.warn("âš ï¸ Camera or canvas not available for point cloud setup");return}const t=e.bbox,s=t.center(),n=t.radius(),o=c.vec3.fromValues(s[0]-n*.5,s[1]-n*.5,s[2]-n*.5),i=c.quat.fromValues(0,0,0,1),r=this.canvasElement.width/this.canvasElement.height,l=new lt([this.canvasElement.width,this.canvasElement.height],[Ne(45),Ne(45/r)],.01,1e3);this.camera=new Ze(o,i,l),this.controllerType==="orbit"&&this.controller instanceof ct&&(c.vec3.copy(this.controller.center,s),c.vec3.set(this.controller.rotation,0,0,0),c.vec2.set(this.controller.shift,0,0),this.controller.scroll=0),console.log(`ğŸ“· Camera positioned for point cloud: radius=${n.toFixed(2)}, center=[${s[0].toFixed(2)}, ${s[1].toFixed(2)}, ${s[2].toFixed(2)}]`)}resize(e){const t=window.devicePixelRatio||1,s=e.getBoundingClientRect(),n=Math.max(1,Math.floor(s.width*t)),o=Math.max(1,Math.floor(s.height*t));let i=!1;(e.width!==n||e.height!==o)&&(e.width=n,e.height=o,i=!0),this.camera&&i&&(this.camera.projection.resize([n,o]),console.log(`ğŸ“· Camera resized: ${n}x${o} (dpr: ${t.toFixed(2)})`)),this.canvasElement=e}update(e){this.camera&&this.controller.update(this.camera,e)}getCameraMatrix(){return this.camera?this.camera.viewMatrix():(console.warn("âš ï¸ Camera not available, returning identity matrix"),c.mat4.create())}getProjectionMatrix(){if(!this.camera){console.warn("âš ï¸ Camera not available, returning default projection matrix");const e=c.mat4.create();return c.mat4.perspective(e,Math.PI/4,16/9,.1,1e3),e}return this.camera.projMatrix()}getCamera(){return this.camera}getController(){return this.controller}switchController(e){if(e===this.controllerType)return;console.log(`ğŸ® Switching from ${this.controllerType} to ${e} controller`);const t=this.camera?c.vec3.clone(this.camera.positionV):c.vec3.fromValues(0,0,3),s=this.camera?c.quat.clone(this.camera.rotationQ):c.quat.fromValues(0,0,0,1),n=this.controllerType;if(this.controllerType=e,this.controller=this.createController(e),this.camera)if(n==="fps"&&e==="orbit"){const o=c.quat.invert(c.quat.create(),s),i=c.vec3.transformQuat(c.vec3.create(),c.vec3.fromValues(0,0,-1),o);let r=5;const l=c.vec3.length(t);l>10&&(r=l*.5);const u=c.vec3.create();c.vec3.scaleAndAdd(u,t,i,r),this.controller instanceof ct&&(c.vec3.copy(this.controller.center,u),c.vec3.set(this.controller.rotation,0,0,0),c.vec2.set(this.controller.shift,0,0),this.controller.scroll=0),c.vec3.copy(this.camera.positionV,t),c.quat.copy(this.camera.rotationQ,s)}else if(n==="orbit"&&e==="fps"){const o=c.quat.invert(c.quat.create(),s),i=c.vec3.transformQuat(c.vec3.create(),c.vec3.fromValues(0,0,-1),o),r=Math.atan2(i[0],i[2]),l=Math.sqrt(i[0]*i[0]+i[2]*i[2]),u=Math.atan2(-i[1],l);this.controller instanceof js&&(this.controller.setOrientation(r,u),this.controller.leftMousePressed=!1,this.controller.rightMousePressed=!1),c.vec3.copy(this.camera.positionV,t),c.quat.copy(this.camera.rotationQ,s)}else c.vec3.copy(this.camera.positionV,t),c.quat.copy(this.camera.rotationQ,s);console.log(`âœ… Controller switched to ${e}`)}getControllerType(){return this.controllerType}isInitialized(){return this.camera!==null}getCameraPosition(){return this.camera?c.vec3.clone(this.camera.positionV):null}getCameraRotation(){return this.camera?c.quat.clone(this.camera.rotationQ):null}setCameraPosition(e){this.camera&&(c.vec3.copy(this.camera.positionV,e),console.log(`ğŸ“· Camera position set: [${e[0].toFixed(2)}, ${e[1].toFixed(2)}, ${e[2].toFixed(2)}]`))}setCameraRotation(e){this.camera&&(c.quat.copy(this.camera.rotationQ,e),console.log("ğŸ“· Camera rotation set"))}getViewportInfo(){if(!this.canvasElement)return null;const e=this.canvasElement.width,t=this.canvasElement.height,s=e/t;return{width:e,height:t,aspect:s}}getFrustumInfo(){return this.camera?{fov:this.camera.projection.fovy||Ne(45),near:.01,far:2e3}:null}setOrbitCenter(e){this.controllerType==="orbit"&&this.controller instanceof ct&&(c.vec3.copy(this.controller.center,e),console.log(`ğŸ“· Orbit center set to: [${e[0].toFixed(2)}, ${e[1].toFixed(2)}, ${e[2].toFixed(2)}]`))}getOrbitCenter(){return this.controllerType==="orbit"&&this.controller instanceof ct?c.vec3.clone(this.controller.center):null}getDebugInfo(){if(!this.camera)return null;const e=this.getCameraPosition(),t=this.getCameraRotation(),s=this.getViewportInfo(),n=this.getFrustumInfo();return{position:e?[e[0],e[1],e[2]]:null,rotation:t?[t[0],t[1],t[2],t[3]]:null,viewport:s,frustum:n,initialized:this.isInitialized(),controllerType:this.controllerType,orbitCenter:this.getOrbitCenter()}}}class Xs{modelManager;lastUpdateTime=0;minUpdateInterval=16;forceNextUpdate=!1;updateCount=0;totalUpdateTime=0;debugLogging=!1;constructor(e){this.modelManager=e}_frameUpdating=!1;updateDynamicPointClouds(e,t,s){this._frameUpdating=!0;const n=this.modelManager.getDynamicModels().filter(l=>l.visible);if(n.length===0)return this._frameUpdating=!1,Promise.resolve();const o=performance.now(),i=l=>{if(!(l.pointCloud instanceof Be))return Promise.resolve();const u=l.pointCloud,d=u.transform||new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]);return u.update(e,d,s,t).catch(f=>{console.warn(`âš ï¸ Failed to update dynamic model '${l.name}':`,f)})};return n.reduce((l,u)=>l.then(()=>i(u)),Promise.resolve()).then(()=>{this.lastUpdateTime=performance.now(),this.updateCount++;const l=this.lastUpdateTime-o;if(this.totalUpdateTime+=l,this.debugLogging&&this.updateCount%60===0){const u=this.totalUpdateTime/this.updateCount;console.log(`ğŸ“Š Animation update #${this.updateCount}: ${n.length} models, avg: ${u.toFixed(2)}ms`)}}).finally(()=>{this._frameUpdating=!1})}controlDynamicAnimation(e,t){const s=this.modelManager.getDynamicModels();let n=0;s.forEach(i=>{if(!(i.pointCloud instanceof Be))return;const r=i.pointCloud;switch(e){case"start":r.startAnimation(t||1),n++;break;case"pause":r.pauseAnimation(),n++;break;case"resume":r.resumeAnimation(),n++;break;case"stop":r.stopAnimation(),n++;break}});const o=t?` at ${t}x speed`:"";console.log(`ğŸ¬ Animation ${e}${o} for ${n} dynamic models`)}setDynamicAnimationTime(e){const t=this.modelManager.getDynamicModels();let s=0;t.forEach(n=>{if(!(n.pointCloud instanceof Be))return;n.pointCloud.setAnimationTime(e),s++}),console.log(`â° Set animation time to ${e.toFixed(3)} for ${s} dynamic models`)}getDynamicPerformanceStats(){return this.modelManager.getDynamicModels().filter(e=>e.pointCloud instanceof Be).map(e=>({modelName:e.name,stats:e.pointCloud.getPerformanceStats()}))}getAnimationStats(){const e=this.modelManager.getDynamicModels(),t=e.filter(s=>s.visible);return{updateCount:this.updateCount,averageUpdateTime:this.updateCount>0?this.totalUpdateTime/this.updateCount:0,lastUpdateTime:this.lastUpdateTime,totalDynamicModels:e.length,activeDynamicModels:t.length}}resetPerformanceStats(){this.updateCount=0,this.totalUpdateTime=0,this.lastUpdateTime=0,console.log("ğŸ“Š Animation performance stats reset")}forceUpdate(){this.forceNextUpdate=!0}setUpdateInterval(e){this.minUpdateInterval=Math.max(1,e),console.log(`â±ï¸ Animation update interval set to ${this.minUpdateInterval}ms`)}getUpdateInterval(){return this.minUpdateInterval}setDebugLogging(e){this.debugLogging=e,console.log(`ğŸ› Animation debug logging ${e?"enabled":"disabled"}`)}shouldUpdate(){return this.forceNextUpdate?!0:performance.now()-this.lastUpdateTime>=this.minUpdateInterval}getDynamicModels(){return this.modelManager.getDynamicModels()}hasDynamicModels(){return this.getDynamicModels().length>0}getActiveDynamicModelCount(){return this.modelManager.getDynamicModels().filter(e=>e.visible).length}pauseAll(){this.controlDynamicAnimation("pause")}resumeAll(){this.controlDynamicAnimation("resume")}stopAll(){this.controlDynamicAnimation("stop")}startAll(e=1){this.controlDynamicAnimation("start",e)}getDebugInfo(){const e=this.getAnimationStats(),t=this.getDynamicPerformanceStats();return{stats:e,performanceStats:t,settings:{minUpdateInterval:this.minUpdateInterval,debugLogging:this.debugLogging,forceNextUpdate:this.forceNextUpdate},dynamicModels:this.getDynamicModels().map(s=>({name:s.name,visible:s.visible,pointCount:s.pointCount,isAnimating:s.pointCloud instanceof Be?s.pointCloud.isAnimationRunning:!1}))}}}class Ys{modelManager;animationManager;cameraManager;renderer=null;gpu=null;canvas=null;startTime=performance.now();state={background:[0,0,0,1],gaussianScale:1,animationId:0,lastTime:performance.now(),frames:0,fpsAccumStart:performance.now()};callbacks={};isRunning=!1;constructor(e,t,s){this.modelManager=e,this.animationManager=t,this.cameraManager=s}init(e,t,s){this.gpu=e,this.renderer=t,this.canvas=s,console.log("ğŸ¬ RenderLoop initialized")}start(){if(this.isRunning){console.warn("RenderLoop already running");return}this.isRunning=!0,this.state.lastTime=performance.now(),this.state.fpsAccumStart=performance.now(),this.state.frames=0,this.state.animationId=requestAnimationFrame(()=>this.frame()),console.log("RenderLoop started")}stop(){if(!this.isRunning){console.warn("RenderLoop not running");return}this.isRunning=!1,this.state.animationId&&(cancelAnimationFrame(this.state.animationId),this.state.animationId=0),console.log("RenderLoop stopped")}async frame(){if(!this.isRunning)return;if(!this.gpu||!this.renderer||!this.cameraManager.isInitialized()){this.state.animationId=requestAnimationFrame(()=>this.frame());return}const e=performance.now(),t=Math.min(.05,(e-this.state.lastTime)/1e3);this.state.lastTime=e;const s=e-this.startTime;this.cameraManager.update(t),await this.animationManager.updateDynamicPointClouds(this.cameraManager.getCameraMatrix(),this.cameraManager.getProjectionMatrix(),s/500),this.updateFPS(e),this.renderFrame(),this.isRunning&&(this.state.animationId=requestAnimationFrame(()=>this.frame()))}renderFrame(){if(!this.gpu||!this.renderer||!this.canvas)return;const e=this.cameraManager.getCamera();if(!e)return;const t=this.modelManager.getVisibleModels();if(t.length===0)return;const s=this.gpu.device.createCommandEncoder({label:"frame"}),n=this.gpu.context.getCurrentTexture().createView(),o=t.map(r=>r.pointCloud);this.renderer.prepareMulti(s,this.gpu.device.queue,o,{camera:e,viewport:[this.canvas.width,this.canvas.height],gaussianScaling:this.state.gaussianScale});const i=s.beginRenderPass({colorAttachments:[{view:n,clearValue:{r:this.state.background[0],g:this.state.background[1],b:this.state.background[2],a:this.state.background[3]},loadOp:"clear",storeOp:"store"}]});this.renderer.renderMulti(i,o),i.end(),this.gpu.device.queue.submit([s.finish()])}updateFPS(e){if(this.state.frames++,e-this.state.fpsAccumStart>=1e3){const t=Math.round(this.state.frames*1e3/(e-this.state.fpsAccumStart));this.callbacks.onFPSUpdate&&this.callbacks.onFPSUpdate(t),this.updatePointStats(),this.state.frames=0,this.state.fpsAccumStart=e}}updatePointStats(){const e=this.modelManager.getTotalVisiblePoints();this.callbacks.onPointCountUpdate&&this.callbacks.onPointCountUpdate(e)}setBackgroundColor(e){this.state.background=[...e]}setGaussianScale(e){this.state.gaussianScale=e}getState(){return{...this.state}}setCallbacks(e){this.callbacks={...this.callbacks,...e}}renderOnce(){if(this.isRunning){console.warn("Cannot render once while render loop is running");return}console.warn("âš ï¸ Cannot render once while render loop is running"),this.renderFrame()}isActive(){return this.isRunning}getCurrentFPS(){const t=performance.now()-this.state.fpsAccumStart;return t===0?0:Math.round(this.state.frames*1e3/t)}getFrameCount(){return this.state.frames}resetFPSCounter(){this.state.frames=0,this.state.fpsAccumStart=performance.now()}getPerformanceInfo(){const t=performance.now()-this.state.fpsAccumStart,s=this.getCurrentFPS(),n=this.state.frames>0?t/this.state.frames:0;return{fps:s,frameCount:this.state.frames,elapsedTime:t,averageFrameTime:n,isRunning:this.isRunning}}getDebugInfo(){const e=this.getPerformanceInfo(),t=this.modelManager.getVisibleModels();return{performance:e,state:this.getState(),models:{total:this.modelManager.getModelCount(),visible:t.length,dynamic:this.animationManager.getActiveDynamicModelCount(),totalPoints:this.modelManager.getTotalVisiblePoints()},renderer:{initialized:!!this.renderer,globalSorting:!1},gpu:{initialized:!!this.gpu,device:!!this.gpu?.device}}}}const Uo=1e4;class Bo{dom;gpu=null;renderer=null;uiController;modelManager;fileLoader;onnxManager;cameraManager;animationManager;renderLoop;constructor(){this.dom=new vn,this.modelManager=new Rt(Uo),this.cameraManager=new Hs("orbit"),this.animationManager=new Xs(this.modelManager),this.renderLoop=new Ys(this.modelManager,this.animationManager,this.cameraManager);const e={onProgress:(s,n,o)=>this.showLoading(s,n,o),onError:s=>this.showError(s)};this.fileLoader=new qt(this.modelManager,e),this.onnxManager=new Kt(this.modelManager);const t={onFileLoad:s=>this.loadFile(s)};this.uiController=new Sn(this.dom,this.cameraManager.getController(),t)}async init(){const e=Ms();if(Cs(e),console.log(`[App] Initialized ORT environment with paths: ${e}`),!this.dom.canvas)throw new Error("Canvas element not found");try{const t=Ps;this.gpu=await Ft(this.dom.canvas,{dummyModelUrl:t,adapterPowerPreference:"high-performance",allowOwnDeviceWhenOrtPresent:!1}),console.log("[App] WebGPU initialized with ORT integration")}catch(t){console.warn("[App] ORT integration failed, falling back to standalone WebGPU:",t),this.gpu=await Ft(this.dom.canvas,{preferShareWithOrt:!1,adapterPowerPreference:"high-performance"}),console.log("[App] WebGPU initialized in standalone mode")}if(!this.gpu){pt(this.dom.noWebGPU,!1);return}this.renderer=new kt(this.gpu.device,this.gpu.format,3),await this.renderer.ensureSorter(),this.cameraManager.initCamera(this.dom.canvas),this.switchController("orbit"),this.uiController.bindEvents(this.dom.canvas),window.addEventListener("resize",()=>this.resize()),this.resize(),this.renderLoop.init(this.gpu,this.renderer,this.dom.canvas),this.renderLoop.setCallbacks({onFPSUpdate:t=>{this.dom.fpsEl&&(this.dom.fpsEl.textContent=String(t))},onPointCountUpdate:t=>{this.dom.pointCountEl&&(this.dom.pointCountEl.textContent=String(t))}}),this.renderLoop.start(),console.log("[App] Initialized with multi-format support:",De.getAllSupportedExtensions())}async loadModel(e,t={}){if(!this.gpu){this.showError("WebGPU not initialized");return}try{const s=(e instanceof File?e.name:e).toLowerCase(),n=t.expectedType??this.detectFileType(s);console.log(`[App] Loading ${n} file:`,s),n==="gaussian"?await this.loadGaussianModel(e,t):n==="onnx"?await this.loadONNXModelInternal(e,t):n==="model"?await this.load3DModel(e,t):this.showError(`Unsupported file type: ${s}
Supported formats: ${De.getAllSupportedExtensions().join(", ")}`)}catch(s){const n=s;console.error("[App] Load error:",n),this.showError(`Failed to load file: ${n.message}`)}}async loadGaussianModel(e,t={}){if(!this.gpu)throw new Error("WebGPU not initialized");const s=e instanceof File?e.name:e;console.log(`[App] Loading Gaussian model: ${s}`),this.showLoading(!0,`Loading ${s}...`,0);try{let n=null;if(e instanceof File?n=await this.fileLoader.loadFile(e,this.gpu.device):n=await this.fileLoader.loadSample(e,this.gpu.device,"ply"),n)this.setupCameraForFirstModel(n),this.resize(),this.showLoading(!1),console.log(`[App] Successfully loaded Gaussian model: ${s}`);else throw new Error("Failed to create model entry")}catch(n){this.showLoading(!1);const o=n.message;if(o.includes("Unsupported")||o.includes("unknown")){const i=Oe(s);if(i&&i!=="ply"){console.warn(`[App] ${i.toUpperCase()} format detected but FileLoader may not support it yet`),this.showError(`The file appears to be a ${i.toUpperCase()} format.
Your FileLoader may need to be updated to support this format.
Currently only PLY format is fully supported in FileLoader.`);return}}throw n}}async loadONNXModelInternal(e,t={}){if(!this.gpu)throw new Error("WebGPU not initialized");const{staticInference:s=!1,debugLogging:n=!1}=t,o={staticInference:s,debugLogging:n},i=e instanceof File?URL.createObjectURL(e):e,r=e instanceof File?e.name:"onnx model";console.log(`[App] Loading ONNX model: ${r}`);const l=await this.onnxManager.loadONNXModel(this.gpu.device,i,this.cameraManager.getCameraMatrix(),this.cameraManager.getProjectionMatrix(),r,o);l&&(this.setupCameraForFirstModel(l),this.resize(),console.log(`[App] Successfully loaded ONNX model: ${r}`))}async load3DModel(e,t={}){throw new Error("3D model loading not yet implemented in this architecture")}detectFileType(e){const t=e.toLowerCase();if(rt(t))return"gaussian";if(t.endsWith(".onnx"))return"onnx";if([".gltf",".glb",".obj",".fbx",".stl"].some(n=>t.endsWith(n)))return"model";if(t.endsWith(".ply"))return"gaussian";throw new Error(`Unable to detect file type for: ${e}`)}getFormatInfo(e){const t=this.detectFileType(e),s=t==="gaussian"?Oe(e):void 0;return{type:t,format:s??void 0}}async loadFile(e){const{type:t,format:s}=this.getFormatInfo(e.name);console.log(`[App] Detected file type: ${t}${s?` (${s})`:""}`),await this.loadModel(e,{expectedType:t,gaussianFormat:s})}async loadSample(e){const{type:t,format:s}=this.getFormatInfo(e);console.log(`[App] Loading sample: ${e} (${t}${s?`, ${s}`:""})`),await this.loadModel(e,{expectedType:t,gaussianFormat:s})}async loadGaussian(e,t={}){await this.loadModel(e,{...t,expectedType:"gaussian"})}async loadPLY(e,t={}){console.warn("[App] loadPLY is deprecated, use loadGaussian instead"),await this.loadGaussian(e,t)}async loadSPZ(e,t={}){await this.loadModel(e,{...t,expectedType:"gaussian",gaussianFormat:it.SPZ})}async loadKSplat(e,t={}){await this.loadModel(e,{...t,expectedType:"gaussian",gaussianFormat:it.KSPLAT})}async loadSplat(e,t={}){await this.loadModel(e,{...t,expectedType:"gaussian",gaussianFormat:it.SPLAT})}async loadSOG(e,t={}){await this.loadModel(e,{...t,expectedType:"gaussian",gaussianFormat:it.SOG})}setupCameraForFirstModel(e){this.modelManager.getModelCount()===1&&Promise.resolve().then(()=>ms).then(({PointCloud:t})=>{e.pointCloud instanceof t&&this.cameraManager.setupCameraForPointCloud(e.pointCloud)})}resize(){this.dom.canvas&&this.cameraManager.resize(this.dom.canvas)}async loadONNXModel(e="./models/gaussians3d.onnx",t,s=!0){if(!this.gpu)throw new Error("App not initialized. Call init() first.");const n={staticInference:s,debugLogging:!1},o=await this.onnxManager.loadONNXModel(this.gpu.device,e,this.cameraManager.getCameraMatrix(),this.cameraManager.getProjectionMatrix(),t,n);o&&(this.setupCameraForFirstModel(o),this.resize())}showLoading(e,t,s){this.dom.loadingOverlay&&(pt(this.dom.loadingOverlay,!e),t&&this.dom.progressText&&(this.dom.progressText.textContent=t),typeof s=="number"&&this.dom.progressFill&&(this.dom.progressFill.style.width=`${Ss(s,0,100)}%`))}showError(e){console.error("[App] Error:",e),this.dom.errorMessage&&(this.dom.errorMessage.textContent=e),this.dom.errorModal&&pt(this.dom.errorModal,!1)}getSupportedFormats(){const e=De.getAllSupportedExtensions();return{gaussian:e.filter(t=>[".ply",".spz",".ksplat",".splat",".sog",".compressed.ply"].includes(t)),onnx:[".onnx"],models:e.filter(t=>[".gltf",".glb",".obj",".fbx",".stl"].includes(t)),all:e}}isFileSupported(e){try{return this.detectFileType(e),!0}catch{return!1}}getModels(){return this.modelManager.getModels()}getModelWithPointCloud(e,t){return this.modelManager.getModelWithPointCloud(e,t)}getFullModels(){return this.modelManager.getFullModels()}async loadONNXModelPublic(e,t){return this.loadONNXModel(e,t)}getCameraMatrix(){return this.cameraManager.getCameraMatrix()}getProjectionMatrix(){return this.cameraManager.getProjectionMatrix()}controlDynamicAnimation(e,t){this.animationManager.controlDynamicAnimation(e,t)}setDynamicAnimationTime(e){this.animationManager.setDynamicAnimationTime(e)}getDynamicPerformanceStats(){return this.animationManager.getDynamicPerformanceStats()}resetCamera(){this.cameraManager.resetCamera()}switchController(e){if(e==="orbit"&&this.modelManager.getModelCount()>0){const t=this.modelManager.getModels();let s=c.vec3.create(),n=0;for(const o of t)if(o.visible){const i=this.modelManager.getModelPosition(o.id);i&&(c.vec3.add(s,s,i),n++)}if(n>0){const o=c.vec3.scale(c.vec3.create(),s,1/n);this.cameraManager.switchController(e),this.cameraManager.setOrbitCenter(o)}else this.cameraManager.switchController(e)}else this.cameraManager.switchController(e);this.uiController.controller=this.cameraManager.getController()}setGaussianScale(e){this.renderLoop.setGaussianScale(e)}setBackgroundColor(e){this.renderLoop.setBackgroundColor(e)}getGaussianScale(){return this.renderLoop.getState().gaussianScale}getBackgroundColor(){return[...this.renderLoop.getState().background]}getModelManager(){return this.modelManager}getONNXManager(){return this.onnxManager}getCameraManager(){return this.cameraManager}getAnimationManager(){return this.animationManager}getRenderLoop(){return this.renderLoop}getDebugInfo(){return{app:{initialized:!!this.gpu&&!!this.renderer,canvas:{width:this.dom.canvas?.width||0,height:this.dom.canvas?.height||0},supportedFormats:this.getSupportedFormats()},models:{count:this.modelManager.getModelCount(),capacity:this.modelManager.getRemainingCapacity(),totalPoints:this.modelManager.getTotalPoints(),visiblePoints:this.modelManager.getTotalVisiblePoints()},camera:this.cameraManager.getDebugInfo(),animation:this.animationManager.getDebugInfo(),renderLoop:this.renderLoop.getDebugInfo(),onnx:{hasModels:this.onnxManager.hasONNXModels(),modelCount:this.onnxManager.getONNXModels().length,performanceStats:this.onnxManager.getONNXPerformanceStats()}}}}async function Go(a){const e=await Ft(a,{dummyModelUrl:Ps,adapterPowerPreference:"high-performance",allowOwnDeviceWhenOrtPresent:!1});if(!e)return Promise.reject("initWebGPU_onnx failed!");const t=new G.WebGPURenderer({canvas:a,antialias:!0,forceWebGL:!1,context:e.context,device:e.device});return await t.init(),t.setClearColor(new G.Color("#808080"),1),t.setPixelRatio(Math.min(window.devicePixelRatio,2)),t.setSize(a.clientWidth,a.clientHeight,!1),console.log("Init ThreeJS Successfully!","Width:",a.clientWidth,"Height",a.clientHeight),t}class Qt{viewMat=c.mat4.create();projMat=c.mat4.create();_position=new Float32Array(3);_focal=[0,0];_viewport=[1,1];transposeRotation=!0;flipProjY=!1;flipProjX=!1;compensatePreprocessYFlip=!0;projection={focal:e=>this._focal};update(e,t){e.updateMatrixWorld(),e.updateProjectionMatrix();const s=e.matrixWorldInverse.elements;for(let d=0;d<16;d++)this.viewMat[d]=s[d];this.viewMat[0]=-this.viewMat[0],this.viewMat[4]=-this.viewMat[4],this.viewMat[8]=-this.viewMat[8],this.viewMat[12]=-this.viewMat[12],this.viewMat[2]=-this.viewMat[2],this.viewMat[6]=-this.viewMat[6],this.viewMat[10]=-this.viewMat[10],this.viewMat[14]=-this.viewMat[14];const n=e.projectionMatrix.elements,o=new Float32Array(16);o[0]=-1,o[5]=1,o[10]=-1,o[15]=1;const i=new Float32Array(16);for(let d=0;d<4;d++)for(let f=0;f<4;f++){let h=0;for(let m=0;m<4;m++){const p=n[m*4+f],v=o[d*4+m];h+=p*v}i[d*4+f]=h}this.compensatePreprocessYFlip&&(i[1]=-i[1],i[5]=-i[5],i[9]=-i[9],i[13]=-i[13]);for(let d=0;d<16;d++)this.projMat[d]=i[d];e.getWorldPosition(new G.Vector3).toArray(this._position);const r=(e.fov??60)*Math.PI/180,l=e.aspect&&isFinite(e.aspect)&&e.aspect>0?e.aspect:t[0]/Math.max(1,t[1]),u=2*Math.atan(Math.tan(r*.5)*l);this._viewport=t,this._focal[0]=t[0]/(2*Math.tan(u*.5)),this._focal[1]=t[1]/(2*Math.tan(r*.5))}viewMatrix(){return this.viewMat}projMatrix(){return this.projMat}position(){return this._position}frustumPlanes(){const e=new Float32Array(24);for(let t=0;t<24;t++)e[t]=t<12?1e3:-1e3;return e}}class Ao extends G.Mesh{renderer;gaussianModels;pcs=null;threeRenderer;threeScene;device;canvasFormat;sceneDepthRT=null;sceneDepthTexture=null;autoDepthMode=!0;occluderMeshes=[];occluderScene=new G.Scene;gizmoOverlayRT=null;overlaySampler=null;overlayBindGroupLayout=null;overlayPipeline=null;overlayRenderedThisFrame=!1;constructor(e,t,s){super(),this.frustumCulled=!1,this.threeRenderer=e,this.threeScene=t,this.device=e.backend.device;const n=navigator.gpu.getPreferredCanvasFormat();this.renderer=new kt(this.device,n,3),this.gaussianModels=s,this.canvasFormat=n}onResize(e,t,s){}renderThreeScene(e){if(!this.autoDepthMode)return;const t=new G.Vector2;this.threeRenderer.getDrawingBufferSize?.(t);const s=t.x||this.threeRenderer.domElement.width||1,n=t.y||this.threeRenderer.domElement.height||1;(!this.sceneDepthRT||this.sceneDepthRT.width!==s||this.sceneDepthRT.height!==n)&&(this.sceneDepthRT&&this.sceneDepthRT.dispose(),this.sceneDepthRT=new G.RenderTarget(s,n,{format:G.RGBAFormat,type:G.HalfFloatType,samples:1,depthBuffer:!0}),this.sceneDepthRT.texture.colorSpace=G.LinearSRGBColorSpace,this.sceneDepthTexture=new G.DepthTexture(s,n,G.FloatType),this.sceneDepthRT.depthTexture=this.sceneDepthTexture),this.threeRenderer.setRenderTarget(this.sceneDepthRT),this.threeRenderer.clear(!0,!0,!1),this.threeRenderer.render(this.threeScene,e),this.threeRenderer.setRenderTarget(null),this.blitRenderTargetToCanvas(e)}blitRenderTargetToCanvas(e){if(this.sceneDepthRT)try{const t=this.threeRenderer.backend?.device;if(!t){console.warn("[Depth] No GPU device available for blit"),this.threeRenderer.render(this.threeScene,e);return}const n=this.threeRenderer.domElement.getContext("webgpu");if(!n){console.warn("[Depth] No WebGPU context available for blit"),this.threeRenderer.render(this.threeScene,e);return}const o=n.getCurrentTexture(),i=o.createView(),l=this.threeRenderer.backend?.get?.(this.sceneDepthRT.texture),u=l?.texture;if(!u){console.warn("[Depth] Could not access RT color texture for blit"),this.threeRenderer.render(this.threeScene,e);return}const d=l?.format,f=o.format;globalThis.GS_DEPTH_DEBUG,this.blitWithRenderPass(t,u,i,this.sceneDepthRT.width,this.sceneDepthRT.height),globalThis.GS_DEPTH_DEBUG}catch(t){console.warn("[Depth] Blit with render pass failed, falling back to re-render:",t),this.threeRenderer.render(this.threeScene,e)}}blitWithRenderPass(e,t,s,n,o){const i=e.createSampler({magFilter:"linear",minFilter:"linear",mipmapFilter:"linear"}),r=e.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.FRAGMENT,texture:{viewDimension:"2d"}},{binding:1,visibility:GPUShaderStage.FRAGMENT,sampler:{}}]}),l=e.createBindGroup({layout:r,entries:[{binding:0,resource:t.createView()},{binding:1,resource:i}]}),u=e.createRenderPipeline({layout:e.createPipelineLayout({bindGroupLayouts:[r]}),vertex:{module:e.createShaderModule({code:`
                        @vertex
                        fn vs_main(@builtin(vertex_index) vertexIndex: u32) -> @builtin(position) vec4f {
                            var pos = array<vec2f, 6>(
                                vec2f(-1.0, -1.0), vec2f(1.0, -1.0), vec2f(-1.0, 1.0),
                                vec2f(-1.0, 1.0),  vec2f(1.0, -1.0), vec2f(1.0, 1.0)
                            );
                            return vec4f(pos[vertexIndex], 0.0, 1.0);
                        }
                    `}),entryPoint:"vs_main"},fragment:{module:e.createShaderModule({code:`
                        @group(0) @binding(0) var sourceTexture: texture_2d<f32>;
                        @group(0) @binding(1) var sourceSampler: sampler;

                        // çº¿æ€§ç©ºé—´åˆ°sRGBç©ºé—´çš„è½¬æ¢å‡½æ•°ï¼ˆæ ‡å‡†sRGB gammaæ ¡æ­£ï¼‰
                        fn linearToSRGB(linear: vec3<f32>) -> vec3<f32> {
                            return select(
                                linear * 12.92,
                                pow(max(linear, vec3<f32>(0.0)), vec3<f32>(1.0 / 2.4)) * 1.055 - 0.055,
                                linear > vec3<f32>(0.0031308)
                            );
                        }

                        @fragment
                        fn fs_main(@builtin(position) fragCoord: vec4f) -> @location(0) vec4f {
                            let texCoord = fragCoord.xy / vec2f(${n}.0, ${o}.0);
                            // RTä½¿ç”¨HalfFloatTypeï¼ˆ16ä½æµ®ç‚¹ï¼‰ï¼Œå­˜å‚¨çš„æ˜¯çº¿æ€§ç©ºé—´çš„å€¼
                            // HalfFloatTypeæ”¯æŒå¯è¿‡æ»¤é‡‡æ ·ï¼Œç²¾åº¦é€šå¸¸è¶³å¤Ÿä¿æŒé«˜åŠ¨æ€èŒƒå›´å†…å®¹
                            let linearColor = textureSample(sourceTexture, sourceSampler, texCoord);
                            
                            // å…³é”®ä¿®å¤ï¼šå°†çº¿æ€§ç©ºé—´çš„å€¼è½¬æ¢ä¸ºsRGBç©ºé—´è¾“å‡ºåˆ°canvas
                            // ä½¿ç”¨HalfFloatTypeï¼ˆ16ä½æµ®ç‚¹ï¼‰æ”¯æŒWebGPUçš„è¿‡æ»¤é‡‡æ ·ï¼Œé¿å…éªŒè¯é”™è¯¯
                            // åœ¨è¾“å‡ºæ—¶è¿›è¡Œçº¿æ€§åˆ°sRGBçš„è½¬æ¢ï¼Œç¡®ä¿é¢œè‰²æ­£ç¡®æ˜¾ç¤º
                            let srgbColor = linearToSRGB(linearColor.rgb);
                            
                            return vec4<f32>(srgbColor, linearColor.a);
                        }
                    `}),entryPoint:"fs_main",targets:[{format:"bgra8unorm"}]},primitive:{topology:"triangle-list"}}),d=e.createCommandEncoder({label:"RT-to-Canvas render pass"}),f=d.beginRenderPass({colorAttachments:[{view:s,loadOp:"clear",storeOp:"store",clearValue:{r:0,g:0,b:0,a:1}}]});f.setPipeline(u),f.setBindGroup(0,l),f.draw(6,1,0,0),f.end(),e.queue.submit([d.finish()])}onBeforeRender(e,t,s,n,o,i){if(!(s instanceof G.PerspectiveCamera)&&s.type!=="PerspectiveCamera"){console.log("Only THREE.PerspectiveCamera is supported!",s);return}const r=this.convertCamera(s,e),l=this.gaussianModels.filter(p=>p.isVisible(s));if(this.pcs=l.map(p=>p.getPointCloud()).filter(p=>p&&typeof p=="object"&&("numPoints"in p||"countBuffer"in p)&&!("skeletalAnimation"in p||"fbxMesh"in p)),!this.pcs||this.pcs.length===0){globalThis.GS_VIDEO_EXPORT_DEBUG&&(console.warn("[GaussianThreeJSRenderer] onBeforeRender: æ²¡æœ‰å¯è§çš„é«˜æ–¯ç‚¹äº‘"),console.log("[GaussianThreeJSRenderer] - gaussianModelsæ•°é‡:",this.gaussianModels.length),console.log("[GaussianThreeJSRenderer] - visibleModelsæ•°é‡:",l.length),l.forEach((p,v)=>{const b=p.getPointCloud();console.log(`[GaussianThreeJSRenderer] - æ¨¡å‹${v} getPointCloudè¿”å›ç±»å‹:`,b.constructor.name,"is PointCloud:",b instanceof We,"is DynamicPointCloud:",b instanceof Be,"is FBXModelWrapper:",b instanceof jt)}));return}l.forEach((p,v)=>{p.syncTransformToGPU()});const u=e.backend.device,d=u.createCommandEncoder({label:"frame"}),f=new G.Vector2;e.getDrawingBufferSize?.(f);const h=f.x||e.getSize(new G.Vector2).x,m=f.y||e.getSize(new G.Vector2).y;this.renderer.prepareMulti(d,u.queue,this.pcs,{camera:r,viewport:[h,m]}),u.queue.submit([d.finish()]),this.autoDepthMode&&globalThis.GS_DEPTH_DEBUG}drawSplats(e,t,s,n,o,i){if(this.pcs==null||this.pcs.length===0)return globalThis.GS_VIDEO_EXPORT_DEBUG&&console.warn("[GaussianThreeJSRenderer] drawSplats: pcsä¸ºç©ºæˆ–é•¿åº¦ä¸º0"),!1;if(!(s instanceof G.PerspectiveCamera)&&s.type!=="PerspectiveCamera")return console.warn("drawSplats: Only THREE.PerspectiveCamera is supported!",s),!1;const r=e.backend.device,u=e.backend.context.getCurrentTexture().createView(),d=r.createCommandEncoder({label:"GS-render"});let f;if(this.sceneDepthTexture){const p=new G.Vector2;e.getDrawingBufferSize?.(p),p.x||e.getSize(new G.Vector2).x,p.y||e.getSize(new G.Vector2).y;try{const b=this.threeRenderer.backend?.get?.(this.sceneDepthTexture);globalThis.GS_DEPTH_DEBUG;const y=b?.texture,_=b?.format;y&&_?(this.renderer.setDepthFormat(_),f=y.createView(),globalThis.GS_DEPTH_DEBUG):globalThis.GS_DEPTH_DEBUG&&console.warn("[Depth] âš ï¸ Could not access depth GPU texture from Three.js backend"),f&&(this.renderer.setDepthEnabled(!0),globalThis.GS_DEPTH_DEBUG)}catch(v){globalThis.GS_DEPTH_DEBUG&&console.error("[Depth] âŒ Error accessing depth texture:",v)}}else this.renderer.setDepthEnabled(!1);const h={colorAttachments:[{view:u,clearValue:{r:0,g:0,b:0,a:1},loadOp:"load",storeOp:"store"}]};f?h.depthStencilAttachment={view:f,depthLoadOp:"load",depthStoreOp:"store",depthClearValue:1}:globalThis.GS_DEPTH_DEBUG&&console.warn("[Depth] âš ï¸ No depth view available - render pass has no depth attachment");const m=d.beginRenderPass(h);return this.renderer.renderMulti(m,this.pcs),m.end(),this.compositeOverlayToCanvas(r,d,u),r.queue.submit([d.finish()]),!0}renderOverlayScene(e,t){const[s,n]=this.getViewport();if(this.ensureGizmoOverlayRenderTarget(s,n),!this.gizmoOverlayRT)return;const o=this.threeRenderer.getRenderTarget(),i=new G.Color;this.threeRenderer.getClearColor?.(i);const r=this.threeRenderer.getClearAlpha?.()??1;this.threeRenderer.setRenderTarget(this.gizmoOverlayRT),this.threeRenderer.setClearColor?.(new G.Color(0),0),this.threeRenderer.clear(!0,!1,!1),this.threeRenderer.render(e,t),this.threeRenderer.setClearColor?.(i,r),this.threeRenderer.setRenderTarget(o),this.overlayRenderedThisFrame=!0}ensureGizmoOverlayRenderTarget(e,t){const s=Math.max(1,Math.floor(e)),n=Math.max(1,Math.floor(t));if(this.gizmoOverlayRT&&this.gizmoOverlayRT.width===s&&this.gizmoOverlayRT.height===n)return;this.gizmoOverlayRT&&this.gizmoOverlayRT.dispose();const o=G.WebGPURenderTarget??G.WebGLRenderTarget??G.RenderTarget;this.gizmoOverlayRT=new o(s,n),this.gizmoOverlayRT&&this.gizmoOverlayRT.texture&&(this.gizmoOverlayRT.texture.colorSpace=G.SRGBColorSpace)}compositeOverlayToCanvas(e,t,s){if(!this.overlayRenderedThisFrame||!this.gizmoOverlayRT)return;const i=this.threeRenderer.backend?.get?.(this.gizmoOverlayRT.texture)?.texture;if(!i){this.overlayRenderedThisFrame=!1;return}this.overlaySampler||(this.overlaySampler=e.createSampler({magFilter:"linear",minFilter:"linear"})),this.overlayBindGroupLayout||(this.overlayBindGroupLayout=e.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.FRAGMENT,texture:{viewDimension:"2d"}},{binding:1,visibility:GPUShaderStage.FRAGMENT,sampler:{}}]}));const r=e.createBindGroup({layout:this.overlayBindGroupLayout,entries:[{binding:0,resource:i.createView()},{binding:1,resource:this.overlaySampler}]});if(!this.overlayPipeline){const u=e.createShaderModule({code:`
                    struct VertexOutput {
                        @builtin(position) position : vec4f,
                        @location(0) uv : vec2f,
                    };

                    @vertex
                    fn vs_main(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
                        var positions = array<vec2f, 6>(
                            vec2f(-1.0, -1.0), vec2f(1.0, -1.0), vec2f(-1.0, 1.0),
                            vec2f(-1.0, 1.0),  vec2f(1.0, -1.0), vec2f(1.0, 1.0)
                        );
                        var uvs = array<vec2f, 6>(
                            vec2f(0.0, 1.0), vec2f(1.0, 1.0), vec2f(0.0, 0.0),
                            vec2f(0.0, 0.0), vec2f(1.0, 1.0), vec2f(1.0, 0.0)
                        );

                        var output : VertexOutput;
                        output.position = vec4f(positions[vertexIndex], 0.0, 1.0);
                        output.uv = uvs[vertexIndex];
                        return output;
                    }

                    @group(0) @binding(0) var overlayTexture : texture_2d<f32>;
                    @group(0) @binding(1) var overlaySampler : sampler;

                    @fragment
                    fn fs_main(@location(0) uv : vec2f) -> @location(0) vec4f {
                        return textureSample(overlayTexture, overlaySampler, uv);
                    }
                `}),d=e.createPipelineLayout({bindGroupLayouts:[this.overlayBindGroupLayout]});this.overlayPipeline=e.createRenderPipeline({layout:d,vertex:{module:u,entryPoint:"vs_main"},fragment:{module:u,entryPoint:"fs_main",targets:[{format:this.canvasFormat,blend:{color:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"},alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"}}}]},primitive:{topology:"triangle-list"}})}const l=t.beginRenderPass({colorAttachments:[{view:s,loadOp:"load",storeOp:"store"}]});l.setPipeline(this.overlayPipeline),l.setBindGroup(0,r),l.draw(6,1,0,0),l.end(),this.overlayRenderedThisFrame=!1}async init(){await this.renderer.ensureSorter(),console.log("GaussianThreeJSRenderer.init() Done!")}setOccluderMeshes(e){console.warn("[GaussianThreeJSRenderer] setOccluderMeshes is deprecated. Auto depth mode captures the full scene automatically."),console.warn("[GaussianThreeJSRenderer] To use manual occluders, set autoDepthMode = false"),this.autoDepthMode=!1,this.occluderMeshes=e,this.occluderScene.clear(),e.forEach(t=>this.occluderScene.add(t))}setAutoDepthMode(e){this.autoDepthMode=e}diagnoseDepth(){console.group("[Depth Diagnostic]"),console.log("Auto depth mode:",this.autoDepthMode),console.log("Scene depth RT exists:",!!this.sceneDepthRT),console.log("Scene depth texture exists:",!!this.sceneDepthTexture),this.sceneDepthRT&&(console.log("Scene depth RT size:",this.sceneDepthRT.width,"x",this.sceneDepthRT.height),console.log("Scene depth RT format:",this.sceneDepthRT.texture.format)),this.renderer&&(console.log("GaussianRenderer depth enabled:",this.renderer.useDepth),console.log("GaussianRenderer depth format:",this.renderer.depthFormat)),console.groupEnd()}disposeDepthResources(){this.sceneDepthRT&&(this.sceneDepthRT.dispose(),this.sceneDepthRT=null),this.sceneDepthTexture=null,globalThis.GS_DEPTH_DEBUG&&console.log("[Depth] Cleaned up depth resources"),this.gizmoOverlayRT&&(this.gizmoOverlayRT.dispose(),this.gizmoOverlayRT=null),this.overlayPipeline=null,this.overlayBindGroupLayout=null,this.overlaySampler=null,this.overlayRenderedThisFrame=!1}getViewport(){const e=new G.Vector2;this.threeRenderer.getDrawingBufferSize?.(e);const t=e.x||(this.threeRenderer.domElement?.width??0)||this.threeRenderer.getSize(new G.Vector2).x,s=e.y||(this.threeRenderer.domElement?.height??0)||this.threeRenderer.getSize(new G.Vector2).y;return[t,s]}convertCamera(e,t){const s=this.getViewport(),n=new Qt;return n.update(e,s),n}async updateDynamicModels(e,t){const s=new Qt,n=this.getViewport();s.update(e,n);const o=s.viewMatrix(),i=s.projMatrix();for(const r of this.gaussianModels)try{await r.update(o,t,i)}catch(l){console.warn("Failed to update model:",l)}}setModelGaussianScale(e,t){const s=parseInt(e.replace("model_",""));s>=0&&s<this.gaussianModels.length?(this.gaussianModels[s].setGaussianScale(t),console.log(`[GaussianThreeJSRenderer] Model ${e} Gaussian scale set to: ${t}`)):console.warn(`[GaussianThreeJSRenderer] Model ${e} not found`)}getModelGaussianScale(e){const t=parseInt(e.replace("model_",""));return t>=0&&t<this.gaussianModels.length?this.gaussianModels[t].getGaussianScale():1}getModelVisible(e){const t=parseInt(e.replace("model_",""));return t>=0&&t<this.gaussianModels.length?this.gaussianModels[t].getModelVisible():!1}setModelMaxShDeg(e,t){const s=parseInt(e.replace("model_",""));s>=0&&s<this.gaussianModels.length?(this.gaussianModels[s].setMaxShDeg(t),console.log(`[GaussianThreeJSRenderer] Model ${e} Max SH degree set to: ${t}`)):console.warn(`[GaussianThreeJSRenderer] Model ${e} not found`)}getModelMaxShDeg(e){const t=parseInt(e.replace("model_",""));return t>=0&&t<this.gaussianModels.length?this.gaussianModels[t].getMaxShDeg():0}setModelKernelSize(e,t){const s=parseInt(e.replace("model_",""));s>=0&&s<this.gaussianModels.length?(this.gaussianModels[s].setKernelSize(t),console.log(`[GaussianThreeJSRenderer] Model ${e} Kernel size set to: ${t}`)):console.warn(`[GaussianThreeJSRenderer] Model ${e} not found`)}getModelKernelSize(e){const t=parseInt(e.replace("model_",""));return t>=0&&t<this.gaussianModels.length?this.gaussianModels[t].getKernelSize():0}setModelOpacityScale(e,t){const s=parseInt(e.replace("model_",""));s>=0&&s<this.gaussianModels.length?(this.gaussianModels[s].setOpacityScale(t),console.log(`[GaussianThreeJSRenderer] Model ${e} Opacity scale set to: ${t}`)):console.warn(`[GaussianThreeJSRenderer] Model ${e} not found`)}getModelOpacityScale(e){const t=parseInt(e.replace("model_",""));return t>=0&&t<this.gaussianModels.length?this.gaussianModels[t].getOpacityScale():1}setModelCutoffScale(e,t){const s=parseInt(e.replace("model_",""));s>=0&&s<this.gaussianModels.length?(this.gaussianModels[s].setCutoffScale(t),console.log(`[GaussianThreeJSRenderer] Model ${e} Cutoff scale set to: ${t}`)):console.warn(`[GaussianThreeJSRenderer] Model ${e} not found`)}getModelCutoffScale(e){const t=parseInt(e.replace("model_",""));return t>=0&&t<this.gaussianModels.length?this.gaussianModels[t].getCutoffScale():1}setModelTimeScale(e,t){const s=parseInt(e.replace("model_",""));s>=0&&s<this.gaussianModels.length?(this.gaussianModels[s].setTimeScale(t),console.log(`[GaussianThreeJSRenderer] Model ${e} Time scale set to: ${t}`)):console.warn(`[GaussianThreeJSRenderer] Model ${e} not found`)}setModelTimeOffset(e,t){const s=parseInt(e.replace("model_",""));s>=0&&s<this.gaussianModels.length?(this.gaussianModels[s].setTimeOffset(t),console.log(`[GaussianThreeJSRenderer] Model ${e} Time offset set to: ${t}`)):console.warn(`[GaussianThreeJSRenderer] Model ${e} not found`)}setModelAnimationIsLoop(e,t){const s=parseInt(e.replace("model_",""));s>=0&&s<this.gaussianModels.length?(this.gaussianModels[s].setAnimationIsLoop(t),console.log(`[GaussianThreeJSRenderer] Model ${e} Animation is loop set to: ${t}`)):console.warn(`[GaussianThreeJSRenderer] Model ${e} not found`)}setModelTimeUpdateMode(e,t){const s=parseInt(e.replace("model_",""));s>=0&&s<this.gaussianModels.length?(this.gaussianModels[s].setTimeUpdateMode(t),console.log(`[GaussianThreeJSRenderer] Model ${e} Time update mode set to: ${t}`)):console.warn(`[GaussianThreeJSRenderer] Model ${e} not found`)}setModelRenderMode(e,t){const s=parseInt(e.replace("model_",""));s>=0&&s<this.gaussianModels.length?(this.gaussianModels[s].setRenderMode(t),console.log(`[GaussianThreeJSRenderer] Model ${e} Render mode set to: ${t}`)):console.warn(`[GaussianThreeJSRenderer] Model ${e} not found`)}getModelRenderMode(e){const t=parseInt(e.replace("model_",""));return t>=0&&t<this.gaussianModels.length?this.gaussianModels[t].getRenderMode():0}startModelAnimation(e,t=1){const s=parseInt(e.replace("model_",""));s>=0&&s<this.gaussianModels.length?(this.gaussianModels[s].startAnimation(t),console.log(`[GaussianThreeJSRenderer] Model ${e} Animation started at ${t}x speed`)):console.warn(`[GaussianThreeJSRenderer] Model ${e} not found`)}pauseModelAnimation(e){const t=parseInt(e.replace("model_",""));t>=0&&t<this.gaussianModels.length?(this.gaussianModels[t].pauseAnimation(),console.log(`[GaussianThreeJSRenderer] Model ${e} Animation paused`)):console.warn(`[GaussianThreeJSRenderer] Model ${e} not found`)}resumeModelAnimation(e){const t=parseInt(e.replace("model_",""));t>=0&&t<this.gaussianModels.length?(this.gaussianModels[t].resumeAnimation(),console.log(`[GaussianThreeJSRenderer] Model ${e} Animation resumed`)):console.warn(`[GaussianThreeJSRenderer] Model ${e} not found`)}stopModelAnimation(e){const t=parseInt(e.replace("model_",""));t>=0&&t<this.gaussianModels.length?(this.gaussianModels[t].stopAnimation(),console.log(`[GaussianThreeJSRenderer] Model ${e} Animation stopped`)):console.warn(`[GaussianThreeJSRenderer] Model ${e} not found`)}setModelAnimationTime(e,t){const s=parseInt(e.replace("model_",""));s>=0&&s<this.gaussianModels.length?(this.gaussianModels[s].setAnimationTime(t),console.log(`[GaussianThreeJSRenderer] Model ${e} Animation time set to: ${t.toFixed(3)}s`)):console.warn(`[GaussianThreeJSRenderer] Model ${e} not found`)}setModelAnimationSpeed(e,t){const s=parseInt(e.replace("model_",""));s>=0&&s<this.gaussianModels.length?(this.gaussianModels[s].setAnimationSpeed(t),console.log(`[GaussianThreeJSRenderer] Model ${e} Animation speed set to: ${t}x`)):console.warn(`[GaussianThreeJSRenderer] Model ${e} not found`)}getModelParams(){const e={models:{}};return this.gaussianModels.forEach((t,s)=>{const n=`model_${s}`;e.models[n]={id:n,name:t.name,visible:t.getModelVisible(),gaussianScale:t.getGaussianScale(),maxShDeg:t.getMaxShDeg(),kernelSize:t.getKernelSize(),opacityScale:t.getOpacityScale(),cutoffScale:t.getCutoffScale(),timeScale:t.getTimeScale(),timeOffset:t.getTimeOffset(),timeUpdateMode:t.getTimeUpdateMode(),animationSpeed:t.getAnimationSpeed(),isAnimationRunning:t.isAnimationRunning(),isAnimationPaused:t.isAnimationPaused()}}),e}getGaussianModels(){return[...this.gaussianModels]}appendGaussianModel(e){this.gaussianModels.push(e)}removeModelById(e){const t=parseInt(e.replace("model_",""));if(isNaN(t)||t<0||t>=this.gaussianModels.length)return console.warn(`[GaussianThreeJSRenderer] removeModelById: invalid id ${e}`),!1;const s=this.gaussianModels[t];try{this.threeScene.remove(s),s.dispose?.()}catch(n){console.warn("[GaussianThreeJSRenderer] Error removing model from scene:",n)}return this.gaussianModels.splice(t,1),console.log(`[GaussianThreeJSRenderer] Removed ${e} (${s.name})`),!0}setModelVisible(e,t){const s=parseInt(e.replace("model_",""));s>=0&&s<this.gaussianModels.length?(this.gaussianModels[s].setModelVisible(t),console.log(`[GaussianThreeJSRenderer] Model ${e} visible: ${t}`)):console.warn(`[GaussianThreeJSRenderer] Model ${e} not found`)}resetParameters(){this.gaussianModels.forEach(e=>{e.setGaussianScale(1),e.setMaxShDeg(3),e.setKernelSize(.1),e.setOpacityScale(1),e.setCutoffScale(1),e.setTimeScale(1),e.setTimeOffset(0),e.setTimeUpdateMode("fixed_delta")}),console.log("[GaussianThreeJSRenderer] All parameters reset to defaults")}setGlobalTimeScale(e){this.gaussianModels.forEach(t=>t.setTimeScale(e)),console.log(`[GaussianThreeJSRenderer] Global time scale set: ${e}`)}setGlobalTimeOffset(e){this.gaussianModels.forEach(t=>t.setTimeOffset(e)),console.log(`[GaussianThreeJSRenderer] Global time offset set: ${e}`)}setGlobalTimeUpdateMode(e){this.gaussianModels.forEach(t=>t.setTimeUpdateMode(e)),console.log(`[GaussianThreeJSRenderer] Global time update mode: ${e}`)}startAllAnimations(e=1){this.gaussianModels.forEach(t=>t.startAnimation(e)),console.log(`[GaussianThreeJSRenderer] All animations started at ${e}x`)}pauseAllAnimations(){this.gaussianModels.forEach(e=>e.pauseAnimation()),console.log("[GaussianThreeJSRenderer] All animations paused")}resumeAllAnimations(){this.gaussianModels.forEach(e=>e.resumeAnimation()),console.log("[GaussianThreeJSRenderer] All animations resumed")}stopAllAnimations(){this.gaussianModels.forEach(e=>e.stopAnimation()),console.log("[GaussianThreeJSRenderer] All animations stopped")}setAllAnimationTime(e){this.gaussianModels.forEach(t=>t.setAnimationTime(e)),console.log(`[GaussianThreeJSRenderer] Global animation time set: ${e.toFixed(3)}s`)}setAllAnimationSpeed(e){this.gaussianModels.forEach(t=>t.setAnimationSpeed(e)),console.log(`[GaussianThreeJSRenderer] Global animation speed set: ${e}x`)}}class Js{renderer;scene;gaussianLoader;fbxLoader;modelManager;constructor(e,t){this.renderer=e,this.scene=t,this.modelManager=new Rt;const s=new qt(this.modelManager),n=new Kt(this.modelManager);this.gaussianLoader=new ao(s,n),this.fbxLoader=new Vs(this.modelManager)}detectFileType(e){const t=e.toLowerCase();if(t.endsWith(".compressed.ply"))return"gaussian";const s=t.split(".").pop();return["onnx","sog","ksplat","splat","spz"].includes(s||"")?"gaussian":s==="ply"?"ply":s==="fbx"?"fbx":s||"unknown"}async loadModel(e,t={}){try{const s=e instanceof File?e.name:e,n=t.type||this.detectFileType(s);console.log(`å¼€å§‹åŠ è½½æ¨¡å‹: ${s}, ç±»å‹: ${n}`);let o=s.toLowerCase().split(".").pop(),i=o==="onnx";o==="ply"&&(e instanceof File?i=await this.is3dgsPly(e):i=await this.isGaussianPlyUrl(e)),t.isGaussian=i;const r=await this.loadModelByType(e,n,t);return console.log(`æ¨¡å‹åŠ è½½å®Œæˆ: ${r.info.name}, æ•°é‡: ${r.info.count}`),r}catch(s){const n=s;throw console.error(`æ¨¡å‹åŠ è½½å¤±è´¥: ${n.message}`),t.onError&&t.onError(n),n}}async loadModelByType(e,t,s){if(console.log("fileType:",t,"is Gaussian?",s.isGaussian),t==="gaussian"||t==="onnx")return await this.loadGaussianModel(e,s);if(t==="ply"){if(s.isGaussian)return await this.loadGaussianModel(e,s);console.log("UnifiedModelLoader: æ£€æµ‹åˆ°æ™®é€š Mesh PLY")}else if(s.isGaussian)return await this.loadGaussianModel(e,s);if(t==="fbx")return await this.loadFBXModel(e,s);const n=await this.loadWithUniversalLoader(e,s);return await this.processLoadedData(n,t,s)}async loadWithUniversalLoader(e,t){const s={onProgress:n=>{t.onProgress&&t.onProgress(n.progress)},isGaussian:t.isGaussian};return e instanceof File?await De.loadFile(e,s):await De.loadUrl(e,s)}async processLoadedData(e,t,s){const n=s.sourceFile?.name||"model",o=s.name||n.split("/").pop()?.split(".")[0]||"model";return e instanceof Wt?(console.log("å¤„ç† Three.js æ¨¡å‹"),this.processThreeJSModel(e,t,o,s)):(console.log("å¤„ç† é«˜æ–¯æ¨¡å‹"),this.processGaussianModel(e,t,o,s))}processThreeJSModel(e,t,s,n){const o=e.object3D(),i=[];return o instanceof G.Group?i.push(...o.children):i.push(o),i.forEach(r=>{this.scene.add(r)}),console.log("=== Three.js æ¨¡å‹åŠ è½½å®Œæˆ ==="),console.log("æ¨¡å‹åç§°:",s),console.log("æ¨¡å‹æ•°é‡:",i.length),i.forEach((r,l)=>{console.log(`æ¨¡å‹ ${l+1}:`),console.log("  Object3D UUID:",r.uuid),console.log("  Object3D ç±»å‹:",r.constructor.name),console.log("  Object3D åç§°:",r.name||"æœªå‘½å")}),n.sourceFile?(console.log("åŸå§‹æ–‡ä»¶è·¯å¾„:",n.sourceFile.name),console.log("æ–‡ä»¶å¤§å°:",n.sourceFile.size,"bytes"),console.log("æ–‡ä»¶ç±»å‹:",n.sourceFile.type)):console.log("åŸå§‹æ–‡ä»¶: URL åŠ è½½ï¼Œæ—  File å¯¹è±¡"),{models:i,sourceFile:n.sourceFile,info:{type:t,name:s,count:i.length,isGaussian:!1}}}async processGaussianModel(e,t,s,n){throw new Error("é«˜æ–¯æ¨¡å‹å¤„ç†éœ€è¦ç‰¹æ®Šå®ç°ï¼Œè¯·ä½¿ç”¨ loadGaussianModel æ–¹æ³•")}async loadGaussianModel(e,t){const s=e instanceof File?e.name:e,n=t.name||s.split("/").pop()?.split(".")[0]||"gaussian_model";console.log("=== è¿›å…¥ loadGaussianModel ==="),console.log("æ–‡ä»¶å:",s);let o="ply";const i=s.toLowerCase();i.endsWith(".compressed.ply")?o="compressed.ply":i.endsWith(".sog")?o="sog":i.endsWith(".ksplat")?o="ksplat":i.endsWith(".splat")?o="splat":i.endsWith(".spz")?o="spz":i.endsWith(".onnx")&&(o="onnx"),console.log("ä¼ é€’ç»™åŠ è½½å™¨çš„å…·ä½“æ ¼å¼:",o);const r=t.sourceFile||(e instanceof File?e:void 0),l=await this.gaussianLoader.createFromFile(this.renderer,e instanceof File?URL.createObjectURL(e):e,{camMat:t.cameraMatrix||new Float32Array(16),projMat:t.projectionMatrix||new Float32Array(16),...t.gaussianOptions},t.gaussianOptions,o);e instanceof File&&URL.revokeObjectURL(URL.createObjectURL(e)),this.scene.add(l);const u=new Ao(this.renderer,this.scene,[l]);return await u.init(),this.scene.add(u),console.log("=== é«˜æ–¯æ¨¡å‹åŠ è½½å®Œæˆ ==="),console.log("æ¨¡å‹åç§°:",n),console.log("Object3D UUID:",l.uuid),console.log("Object3D ç±»å‹:",l.constructor.name),r?(console.log("åŸå§‹æ–‡ä»¶è·¯å¾„:",r.name),console.log("æ–‡ä»¶å¤§å°:",r.size,"bytes"),console.log("æ–‡ä»¶ç±»å‹:",r.type)):console.log("åŸå§‹æ–‡ä»¶: URL åŠ è½½ï¼Œæ—  File å¯¹è±¡"),console.log("é«˜æ–¯æ¸²æŸ“å™¨ UUID:",u.uuid),{models:[l],gaussianRenderer:u,sourceFile:r,info:{type:"gaussian",name:n,count:1,isGaussian:!0}}}async readFileHeader(e,t=4096){const n=await e.slice(0,t).arrayBuffer();return new TextDecoder("utf-8").decode(n||new ArrayBuffer(0))}async is3dgsPly(e){try{const t=(await this.readFileHeader(e)).toLowerCase();if(!t.startsWith("ply"))return console.log("ä¸æ˜¯ PLY æ–‡ä»¶:",e.name),!1;const n=["property float opacity","property float scale_0","property float scale_1","property float scale_2","property float rot_0","property float rot_1","property float rot_2","property float rot_3"].every(i=>t.includes(i)),o=/property\s+float\s+sh_\d+/.test(t);return console.log(`PLY æ–‡ä»¶ ${e.name} 3DGS æ£€æµ‹ç»“æœ: åŸºç¡€å±æ€§=${n}, SH ç³»æ•°=${o}`),n}catch(t){return console.warn("è¯»å– PLY å¤´ä¿¡æ¯å¤±è´¥ï¼ŒæŒ‰é 3DGS å¤„ç†:",e.name,t),!1}}async isGaussianPlyUrl(e){try{const t=e.includes("?")?"&":"?",s=`${e}${t}temp=${new Date().getTime()}`,n=await fetch(s,{method:"GET",mode:"cors",headers:{Range:"bytes=0-4095"}});!n.ok&&n.status!==206&&console.warn(`[UnifiedModelLoader] Range è¯·æ±‚æœªæŒ‰é¢„æœŸè¿”å› 206ï¼ŒçŠ¶æ€ç : ${n.status}ã€‚å°è¯•ç»§ç»­è§£æ...`);const i=(await n.text()).slice(0,4096).toLowerCase();if(!i.startsWith("ply"))return console.log(`[UnifiedModelLoader] URL èµ„æºä¸æ˜¯ PLY æ ¼å¼: ${s}`),!1;const l=["property float opacity","property float scale_0","property float scale_1","property float scale_2","property float rot_0","property float rot_1","property float rot_2","property float rot_3"].every(d=>i.includes(d)),u=/property\s+float\s+sh_\d+/.test(i)||/property\s+float\s+f_dc_0/.test(i);return console.log(`[UnifiedModelLoader] çº¿ä¸Š PLY æ£€æµ‹ç»“æœ: åŸºç¡€å±æ€§=${l}, SHç³»æ•°=${u}, URL=${s}`),l}catch(t){return console.warn("[UnifiedModelLoader] æ— æ³•æ£€æµ‹çº¿ä¸Š PLY ç±»å‹ (å¯èƒ½æ˜¯è·¨åŸŸæˆ–ç½‘ç»œé—®é¢˜)ï¼Œé»˜è®¤æŒ‰ False å¤„ç†:",t),!1}}async loadModels(e,t={}){const s=[];for(let n=0;n<e.length;n++){const o=e[n],i={...t,onProgress:r=>{if(t.onProgress){const l=(n+r)/e.length;t.onProgress(l)}}};try{const r=await this.loadModel(o,i);s.push(r)}catch(r){console.error(`åŠ è½½æ¨¡å‹å¤±è´¥: ${o}`,r),t.onError&&t.onError(r)}}return s}async loadFBXModel(e,t){const s=e instanceof File?e.name:e,n=t.name||s.split("/").pop()?.split(".")[0]||"fbx_model";console.log("=== è¿›å…¥ loadFBXModel ==="),console.log("æ–‡ä»¶å:",s);try{let o;e instanceof File?o=await this.fbxLoader.loadFromFile(e,t.fbxOptions):o=await this.fbxLoader.loadFromURL(e,t.fbxOptions);const i=o.pointCloud,r=i.object3D;return this.scene.add(r),console.log("=== FBX æ¨¡å‹åŠ è½½å®Œæˆ ==="),console.log("æ¨¡å‹åç§°:",n),console.log("Object3D UUID:",r.uuid),console.log("Object3D ç±»å‹:",r.constructor.name),console.log("åŠ¨ç”»æ•°é‡:",i.clips.length),console.log("é¡¶ç‚¹æ•°é‡:",o.pointCount),{models:[r],sourceFile:e instanceof File?e:void 0,info:{type:"fbx",name:n,count:1,isGaussian:!1}}}catch(o){throw console.error("FBX æ¨¡å‹åŠ è½½å¤±è´¥:",o),o}}dispose(){}}async function Eo(a,e,t,s={}){const n=new Js(a,e);try{return Array.isArray(t)?await n.loadModels(t,s):await n.loadModel(t,s)}finally{n.dispose()}}class ko{session=null;static async initialize(){Fe.env.logLevel="verbose",console.log("ONNX Runtime initialized with WASM paths")}async loadModel(e="./models/gaussians3d.onnx"){try{console.log(`Loading ONNX model from: ${e}`),this.session=await Fe.InferenceSession.create(e,{executionProviders:["wasm"]}),console.log("âœ… ONNX model loaded successfully"),this.logModelInfo()}catch(t){throw console.error("âŒ Failed to load ONNX model:",t),t}}logModelInfo(){if(!this.session)return;console.log(`
ğŸ“Š Model Information:`),console.log(`
ğŸ”µ Inputs:`);const e=this.session.inputNames;for(const s of e)try{const n=this.session.inputMetadata[s];console.log(`  - ${s}:`,{type:n?.type||"unknown",dims:n?.dims||[]})}catch{console.log(`  - ${s}: metadata unavailable`)}console.log(`
ğŸŸ¢ Outputs:`);const t=this.session.outputNames;for(const s of t)try{const n=this.session.outputMetadata[s];console.log(`  - ${s}:`,{type:n?.type||"unknown",dims:n?.dims||[]})}catch{console.log(`  - ${s}: metadata unavailable`)}}async testInference(){if(!this.session)throw new Error("Model not loaded. Call loadModel() first.");console.log(`
ğŸ§ª Testing inference with sample data...`);try{const e=this.createTestInputs();console.log("Input tensors prepared:");for(const[o,i]of Object.entries(e))console.log(`  - ${o}: shape=${i.dims}, type=${i.type}`);const t=performance.now(),s=await this.session.run(e),n=performance.now()-t;console.log(`âœ… Inference completed in ${n.toFixed(2)}ms`),console.log(`
ğŸ“¤ Output tensors:`);for(const[o,i]of Object.entries(s))if(console.log(`  - ${o}: shape=${i.dims}, type=${i.type}, size=${i.size}`),i.data.length>0){const r=i.data instanceof Float32Array?i.data:new Float32Array(i.data),l=Array.from(r.slice(0,10));console.log(`    First 10 values: [${l.join(", ")}${i.data.length>10?", ...":""}]`)}return s}catch(e){throw console.error("âŒ Inference failed:",e),e}}createTestInputs(){const e={};if(!this.session)throw new Error("Session not initialized");for(const t of this.session.inputNames){const s=this.session.inputMetadata[t];if(t.toLowerCase().includes("camera")||t.toLowerCase().includes("view")||t.toLowerCase().includes("matrix")){const n=c.mat4.create();c.mat4.identity(n),e[t]=new Fe.Tensor("float32",n,[4,4]),console.log(`  ğŸ“· Created camera matrix for '${t}'`)}else if(t.toLowerCase().includes("time")||t.toLowerCase().includes("t")){const n=new Float32Array([.5]);e[t]=new Fe.Tensor("float32",n,[1]),console.log(`  â° Created time input for '${t}': ${n[0]}`)}else if(t.toLowerCase().includes("projection")||t.toLowerCase().includes("proj")){const n=c.mat4.create();c.mat4.perspective(n,Math.PI/4,16/9,.1,1e3),e[t]=new Fe.Tensor("float32",n,[4,4]),console.log(`  ğŸ“ Created projection matrix for '${t}'`)}else{const n=s.dims,o=n.reduce((r,l)=>r*l,1),i=new Float32Array(o).fill(.5);e[t]=new Fe.Tensor("float32",i,n),console.log(`  ğŸ”¢ Created generic input for '${t}': shape=${n}, filled with 0.5`)}}return e}async analyzeModel(){console.log(`
ğŸ” Starting comprehensive model analysis...
`),console.log("Testing temporal variation:");for(const t of[0,.25,.5,.75,1])console.log(`
â° Testing with time = ${t}`),await this.testInferenceWithTime(t);console.log(`
ğŸ“· Testing camera position variation:`);const e=[[0,0,5],[5,0,0],[0,5,0],[-5,0,0]];for(const[t,s,n]of e)console.log(`
ğŸ“ Testing with camera at [${t}, ${s}, ${n}]`),await this.testInferenceWithCamera([t,s,n])}async testInferenceWithTime(e){if(!this.session)return;const t=this.createTestInputs(),s=this.session.inputNames.find(o=>o.toLowerCase().includes("time")||o.toLowerCase().includes("t"));s&&(t[s]=new Fe.Tensor("float32",new Float32Array([e]),[1]));const n=await this.session.run(t);for(const[o,i]of Object.entries(n)){const r=i.data,l=r.reduce((f,h)=>f+h,0)/r.length,u=Math.min(...r),d=Math.max(...r);console.log(`    ${o}: mean=${l.toFixed(4)}, range=[${u.toFixed(4)}, ${d.toFixed(4)}]`)}return n}async testInferenceWithCamera(e){if(!this.session)return;const t=this.createTestInputs(),s=c.mat4.create(),n=new Float32Array(e),o=new Float32Array([0,0,0]),i=new Float32Array([0,1,0]);c.mat4.lookAt(s,n,o,i);const r=this.session.inputNames.find(u=>u.toLowerCase().includes("camera")||u.toLowerCase().includes("view")||u.toLowerCase().includes("matrix"));r&&(t[r]=new Fe.Tensor("float32",s,[4,4]));const l=await this.session.run(t);for(const[u,d]of Object.entries(l)){const f=d.data,h=f.reduce((m,p)=>m+p,0)/f.length;console.log(`    ${u}: mean=${h.toFixed(4)}, size=${f.length}`)}return l}async dispose(){this.session&&(this.session=null,console.log("ğŸ§¹ ONNX session disposed"))}}V.AnimationManager=Xs,V.App=Bo,V.CameraAdapter=Qt,V.CameraManager=Hs,V.FileLoader=qt,V.GaussianRenderer=kt,V.ModelManager=Rt,V.ONNXManager=Kt,V.ONNXModelTester=ko,V.PerspectiveCamera=Ze,V.RenderLoop=Ys,V.UnifiedModelLoader=Js,V.clamp=Ss,V.defaultLoader=De,V.getDefaultOrtWasmPaths=Ms,V.getOrtWasmPaths=st,V.initOrtEnvironment=Cs,V.initThreeContext=Go,V.isOrtConfigured=Mn,V.loadUnifiedModel=Eo,V.setOrtWasmPaths=xs,Object.defineProperty(V,Symbol.toStringTag,{value:"Module"})}));
